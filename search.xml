<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何在 macOS 上面全屏看微信读书]]></title>
    <url>%2F2019%2F10%2F30%2Fweread%2F</url>
    <content type="text"><![CDATA[微信读书 在只能在手机上面看，手机屏幕实在有点小，如果能在电脑上面看就好了。 于是打开 Android Studio 带的 模拟器，结果安装不了。 再看看其它的模拟器吧，发现 MuMu模拟器 可以安装应用商店里面的微信读书。 但是不能翻转，后来发现点点 听 的按钮，神奇的事情发生，居然支持全屏。]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1024 程序员节：代码猜诗词]]></title>
    <url>%2F2019%2F10%2F24%2F1024%2F</url>
    <content type="text"><![CDATA[今天在微信群里面收到这样一张图片，程序员们可以猜出几个答案呢？ 物是人非事事休，欲语泪先流 抽刀断水水更流，举杯消愁愁更愁 寻寻觅觅，冷冷清清，凄凄惨惨戚戚 假作真时真亦假，无为有处有还无 明日复明日，明日何其多。我生待明日，万事成蹉跎。 东风不与周郎便，铜雀春深锁二乔 鱼和熊掌不可兼得 举头望明月，低头思故乡 独乐乐不如众乐乐 欲穷千里目，更上一层楼 ​]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>节日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米手机 MIUI 安装 Google 服务框架和 Google Play 的教程]]></title>
    <url>%2F2019%2F10%2F16%2Fgoogle-play%2F</url>
    <content type="text"><![CDATA[Google Play上的APP普遍比国内应用商店的要干净得多，权限要求更少，这也是促使很多人使用Google Play的原因。步骤如下： 1、打开小米应用商店，搜索“谷歌安装器”，拉到最下面，“去豌豆荚搜索” 2、找到谷歌安装器 3.0 3、开始安装 Google 服务框架和 Google Play 整个过程无需 SS，在国内网络即可完成。 最后，连上 SS，登录 Google Play，开始下载干净的 app 吧，少年。 版权声明：本文为CSDN博主「gdali」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/gdali/article/details/60957755]]></content>
      <categories>
        <category>GFW</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS/iOS 代理 V2Ray 小白级配置]]></title>
    <url>%2F2019%2F07%2F18%2Fv2ray%2F</url>
    <content type="text"><![CDATA[GitHub: https://github.com/V2Ray/v2ray-core官方网站：https://www.v2ray.com/ 服务端 Server 安装Linux 安装脚本1bash &lt;(curl -L -s https://install.direct/go.sh) 编辑 /etc/v2ray/config.json 只要改 port, id 即可。 1234567891011121314151617181920212223242526272829303132&#123; "inbounds": [&#123; "port": 10000, "protocol": "vmess", "settings": &#123; "clients": [ &#123; "id": "uuid, 相关于 password，要与 Client 一致", "level": 1, "alterId": 64 &#125; ] &#125; &#125;], "outbounds": [&#123; "protocol": "freedom", "settings": &#123;&#125; &#125;,&#123; "protocol": "blackhole", "settings": &#123;&#125;, "tag": "blocked" &#125;], "routing": &#123; "rules": [ &#123; "type": "field", "ip": ["geoip:private"], "outboundTag": "blocked" &#125; ] &#125;&#125; 启动 V2Ray 进程12service v2ray startservice v2ray status 运行脚本位于系统的以下位置： /etc/systemd/system/v2ray.service: Systemd /etc/init.d/v2ray: SysV 脚本运行完成后，你需要： 编辑 /etc/v2ray/config.json 文件来配置你需要的代理方式； 运行 service v2ray start 来启动 V2Ray 进程； 之后可以使用 service v2ray start|stop|status|reload|restart|force-reload 控制 V2Ray 的运行。 客户端macOS: V2rayUhttps://github.com/yanue/V2rayU Configure… 生成的 json 格式配置文件只需要关注 outbounds -&gt; settings -&gt; vnext -&gt; address outbounds -&gt; settings -&gt; vnext -&gt; users -&gt; id outbounds -&gt; settings -&gt; vnext -&gt; port 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&#123; "log": &#123; "error": "", "loglevel": "info", "access": "" &#125;, "inbounds": [ &#123; "listen": "127.0.0.1", "protocol": "socks", "settings": &#123; "ip": "", "userLevel": 0, "timeout": 360, "udp": false, "auth": "noauth" &#125;, "port": "1080" &#125;, &#123; "listen": "127.0.0.1", "protocol": "http", "settings": &#123; "timeout": 360 &#125;, "port": "1087" &#125; ], "outbounds": [ &#123; "mux": &#123; "enabled": false, "concurrency": 8 &#125;, "protocol": "vmess", "streamSettings": &#123; "tcpSettings": &#123; "header": &#123; "type": "none" &#125; &#125;, "tlsSettings": &#123; "allowInsecure": true &#125;, "security": "none", "network": "tcp" &#125;, "tag": "agentout", "settings": &#123; "vnext": [ &#123; "address": "服务器的 ip 地址", "users": [ &#123; "id": "与服务端相同的 id", "alterId": 64, "level": 0, "security": "auto" &#125; ], "port": 10000 &#125; ] &#125; &#125;, &#123; "tag": "direct", "protocol": "freedom", "settings": &#123; "domainStrategy": "AsIs", "redirect": "", "userLevel": 0 &#125; &#125;, &#123; "tag": "blockout", "protocol": "blackhole", "settings": &#123; "response": &#123; "type": "none" &#125; &#125; &#125; ], "dns": &#123; "servers": [ "" ] &#125;, "routing": &#123; "strategy": "rules", "settings": &#123; "domainStrategy": "IPIfNonMatch", "rules": [ &#123; "outboundTag": "direct", "type": "field", "ip": [ "geoip:cn", "geoip:private" ], "domain": [ "geosite:cn", "geosite:speedtest" ] &#125; ] &#125; &#125;, "transport": &#123;&#125;&#125; 查看一下网络代理 不用自己修改 不用自己修改 不用自己修改 iOS: Shadowrocket（小火箭）提供一个暂时有效的 Apple ID，不是我的，无效不要来找我哦！ 12帐号：domiso.2019@hotmail.com密码：Good456456 直接用 V2rayU 生成的 Share QR Code 测试一下]]></content>
      <categories>
        <category>GFW</category>
      </categories>
      <tags>
        <tag>V2Ray</tag>
        <tag>Shadowrocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 反编译工具]]></title>
    <url>%2F2019%2F07%2F16%2FDecompiler%2F</url>
    <content type="text"><![CDATA[Apktool A tool for reverse engineering Android apk files / Android apk 文件逆向工程工具 1apktool d ~/path/to/apk_to_decompile.apk dex2jar Tools to work with android .dex and java .class files / android .dex 和 java .class 文件的工具 1sh d2j-dex2jar.sh -f ~/path/to/apk_to_decompile.apk JD-GUI A standalone Java Decompiler GUI / 独立 Java 编译器 GUI 1java -jar jd-gui-x.y.z.jar Apktoolhttps://ibotpeaches.github.io/Apktool/install/ Quick Check Is at least Java 1.8 installed? Does executing java -version on command line / command prompt return 1.8 or greater? If not, please install Java 8+ and make it the default. (Java 7 will also work at this time) Installation for Apktool Windows: Download Windows wrapper script (Right click, Save Link As apktool.bat) Download apktool-2 (find newest here) Rename downloaded jar to apktool.jar Move both files (apktool.jar &amp; apktool.bat) to your Windows directory (Usually C://Windows) If you do not have access to C://Windows, you may place the two files anywhere then add that directory to your Environment Variables System PATH variable. Try running apktool via command prompt Linux: Download Linux wrapper script (Right click, Save Link As apktool) Download apktool-2 (find newest here) Rename downloaded jar to apktool.jar Move both files (apktool.jar &amp; apktool) to /usr/local/bin (root needed) Make sure both files are executable (chmod +x) Try running apktool via cli Mac OS X: Download Mac wrapper script (Right click, Save Link As apktool) Download apktool-2 (find newest here) Rename downloaded jar to apktool.jar Move both files (apktool.jar &amp; apktool) to /usr/local/bin (root needed) Make sure both files are executable (chmod +x) Try running apktool via cli Note - Wrapper scripts are not needed, but helpful so you don’t have to type java -jar apktool.jar over and over. 1apktool ~/path/to/apk_to_decompile.apk dex2jarhttps://github.com/pxb1988/dex2jar/releases Usage1sh d2j-dex2jar.sh -f ~/path/to/apk_to_decompile.apk And the output file will be apk_to_decompile-dex2jar.jar. JD-GUI1java -jar jd-gui-x.y.z.jar jd-gui-1.6.2.jar Size : 2.89 MB jd-gui-1.6.2-min.jar Size : 1.33 MB jd-gui-1.6.2.rpm jd-gui-1.6.2.deb Size : 1.20 MB jd-gui-osx-1.6.2.tar Size : 1.44 MB jd-gui-windows-1.6.2.zip]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Decompiler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS VLC Swift 版 : 使用 cocoapods 集成 MobileVLCKit-3.3.2]]></title>
    <url>%2F2019%2F07%2F16%2Fvlc%2F</url>
    <content type="text"><![CDATA[截图 https://www.videolan.org/vlc/download-ios.html BinaryYou can also get the binary from our servers instead of the App Store: [VLC for iOS 3.1.5 binary](http://get.videolan.org/vlc-iOS/3.1.5/vlc-ios-3.1.5.ipa).A binary version of MobileVLCKit is available through CocoaPods. 创建 VLC 项目12345678910111213pod initcat Podfile# Uncomment the next line to define a global platform for your projectplatform :ios, '9.0'target 'VLC' do # Comment the next line if you don't want to use dynamic frameworks use_frameworks! # Pods for VLC pod 'MobileVLCKit'end 更新 pod1pod repo update 安装 MobileVLCKit1pod install --verbose 下载实在太慢了123cat ~/.cocoapods/repos/master/Specs/b/f/7/MobileVLCKit/3.3.2/MobileVLCKit.podspec.json | grep http... "http": "https://download.videolan.org/pub/cocoapods/prod/MobileVLCKit-3.3.2-e16829a-774a96ae6.tar.xz", 用 Motrix 下载上面的 MobileVLCKit-3.3.2-***.tar.xz更换 http 地址，进入下载好的地址启动 Python3 Http Server1python3 -m http.server 80 更换 http 地址为本地地址1234567891011121314diff --git a/Specs/b/f/7/MobileVLCKit/3.3.2/MobileVLCKit.podspec.json b/Specs/b/f/7/MobileVLCKit/3.3.2/MobileVLCKit.podspec.jsonindex e6f4d118c5f..d3b15240c40 100644--- a/Specs/b/f/7/MobileVLCKit/3.3.2/MobileVLCKit.podspec.json+++ b/Specs/b/f/7/MobileVLCKit/3.3.2/MobileVLCKit.podspec.json@@ -59,7 +59,7 @@ "Benjamin Adolphi": "b.adolphi@gmail.com" &#125;, "source": &#123;- "http": "https://download.videolan.org/pub/cocoapods/prod/MobileVLCKit-3.3.2-e16829a-774a96ae6.tar.xz",+ "http": "http://127.0.0.1/MobileVLCKit-3.3.2-e16829a-774a96ae6.tar.xz", "sha256": "143877baa4e362b673c324d5319983a6023f9ed769c3b045fd49fd5efa53ec0c" &#125;, "ios": &#123;(END) 重新安装1pod install --verbose 终于安装成功了! 使用添加 Project-Bridge-Header.h 头文件这里的是 VLC-Bridge-Header.h 添加 VLC-Bridge-Header.h -&gt; “#import “MobileVLCKit/MobileVLCKit.h”” Build Settings -&gt; Objective-C Bridging Header -&gt; “VLC/VLC-Bridge-Header.h” 源码：https://github.com/iOSDevLog/VLC-iOS微信公众号 LicenseiOSDevLog.github.io is released under the MIT license. See LICENSE for details.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>VLC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 安装解释性数学视频的动画引擎 Manim]]></title>
    <url>%2F2019%2F06%2F29%2Fmanim%2F</url>
    <content type="text"><![CDATA[这篇文章的目的是给出另一个关于如何让 Manim 使用 Python 3.7 在 Mac 上 工作的帐户，仅此而已。我花了几个令人沮丧的夜晚试图让事情发挥作用，我想把我的经验添加到 Manim 不断增长的资源中。我强烈建议将此帖与 Todd Zimmerman 的博客 结合使用，学习如何使用 Grant Sanderson 的代码。 我提前道歉包含了许多更简单的步骤，但这篇文章旨在 让没有编程背景的人可以访问 Manim。 我认为一旦将 Manim 安装到您的计算机上，Manim 相对容易学习，所以我希望那些没有太多编程背景的人不会因为让这个库工作而感到沮丧而且可以专注于做出很棒的内容。 如果按顺序进行，这个过程应该相对简单。一般过程将涉及： 下载并安装 Homebrew 包管理器和 Python 3.7 在整个系统中安装必要的软件包 下载并安装 MacTex 克隆 Manim 库并创建虚拟环境 修改代码 运行测试 第 1 步：下载并安装 Hombrew 和 Python3首先需要的是程序包管理器 Homebrew，它将帮助我们安装一些 pip 无法正确安装的软件包。您可以通过打开终端并运行以下代码行来安装 Homebrew： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装 Homebrew 后，可以通过运行安装 Python： 1brew install python3 如果在此过程中出现任何问题，我建议您转到此视频： https://youtu.be/XqADAxr7LzI 一旦安装了 python，我们需要获得一些软件包。返回终端并运行以下代码行，以获取安装所需的软件包（cairo，pkg-config，virtualenv）。 123brew install cairobrew install pkg-configpip3 install virtualenv virtualenv 是获得 Manim 库之前唯一绝对需要的软件包，但是我个人在安装或推出将上述项目安装到虚拟环境中时遇到了麻烦（稍后会介绍）。这就是为什么我建议在继续本教程之前将它们直接安装到您的系统上。 下一步需要花费大量的试验和错误来解决，特别是因为 3b1b 的 GitHub 上没有文档。Manim 使用不同的 LaTeX 子包，因此 pip3 install latex 可能无法获得所需的所有必需子包。我认为主要的问题是许多人已经在他们的计算机上使用了不同形式的 LaTeX，所以当你认为你已经掌握了所有东西时，很难确保一切都在那里。经过多次安装和卸载后，我发现 MacTex 的完整安装可以解决问题，可以在这里找到： http://www.tug.org/mactex/mactex-download.html 确保你安装了所有东西 - 我尝试了几次快捷方式，并没有结束工作。 现在已经安装了 LaTeX，您可以继续开始获取 Manim 库。通常，在虚拟环境中运行项目是一种很好的做法，这样您就可以轻松控制所有文件和其他软件包的安装位置。以下是我推荐的步骤： 第 2 步：为动画创建文件夹创建您希望存储 Manim 库的文件夹。我在我的主目录中创建了一个名为 animation 的文件夹： 第 3 步：导航终端前往 Manim GitHub 并获取要克隆的 URL。复制后，前往终端并导航到刚刚创建的文件夹。导航到终端内的特定文件夹非常简单。您可以通过键入以下内容找到当前目录（当前文件路径）： 1pwd 您可以通过键入以下内容找到当前目录中的文件夹： 1ls 并且您可以通过运行以下命令更改目录以输入其中一个文件夹： 1cd folder/subfolder/subsubfolder 第 4 步：克隆 Manim 存储库现在在 Terminal 中运行以下命令将 Manim 存储库克隆到您的文件夹中： 1git clone https://github.com/3b1b/manim.git 您的文件夹现在看起来应该是这样的（我将文件夹重命名为 manim37）： 第 5 步：设置虚拟环境现在我们需要建立一个虚拟环境。基本上这将是在 Manim 文件夹中重新安装单独版本的 Python3。在虚拟环境中运行时，您将能够运行 Python 并将软件包安装到该特定文件夹而不是整个系统。这些通常用于确保可以逐个项目地维护特定版本的包。 要创建虚拟环境，请转到终端并导航到 Manim 文件夹。现在继续并将以下命令运行到终端： 1virtualenv venv virtualenv 指的是我们之前安装的软件包。venv 是您将安装虚拟环境的文件夹的名称。 现在，如果您查看 Manim37 文件夹，应该有一个名为 venv 的文件夹。如果没有，并且 venv 文件夹在其他地方结束，您只需单击并将其拖动到 Manim37 文件夹即可。 第 6 步：激活虚拟环境现在您已经设置了虚拟环境，现在需要从终端输入。确保您当前的工作目录是 Manim37，然后运行： 1source venv/bin/activate 您的终端线将更改，并且 （venv） 将出现在提示的开头： 使用 Manim 所做的一切都需要在这个虚拟环境中完成，这意味着安装其他软件包，运行动画代码等。如果重新打开终端，则必须再次激活虚拟环境文件夹。您可以通过执行 deactivate 随时退出虚拟环境。 第 7 步：pip3 安装包现在我们需要获得更多的软件包：sox，ffmepg，latex，pycairo 等。继续运行以下各项： 12345pip3 install soxpip3 install ffmpegpip3 install latexpip3 install pycairopip3 install -r requirements.txt 最后一行代码将运行所需的更多软件包的安装。你可以看看的 requirements.txt 的 Manim37 文件夹内的文件，看看到底需要什么，但是一旦这个过程完成后，你将不需要任何更多的包。 第 8 步：修改代码现在已经下载了所有软件包，我们可以开始修复一些与您的计算机相匹配的代码。首先需要做的是在 Manim37 目录中添加一个名为 “output” 的文件夹。 然后我们需要更改位于 Manim37 文件夹中的文件 constants.py 中的一行代码。 打开后，转到第 23 行，找到 “Dropbox（3Blue1Brown）/ 3Blue1Brown Team Folder” 的行 我们需要更改此行以匹配刚刚创建的 输出 文件夹。在我的例子中，我用 “animation/manim37/output” 替换了那一行。您应该用您的文件路径替换它（请记住，上面一行中的 〜 是主目录的文件路径的缩写）。 第 9 步：测试现在我们需要运行一个快速测试来查看某些动画是否正常工作。仍在虚拟环境中，运行： 1python3 extract_scene.py example_scenes.py SquareToCircle -pl 这应该会启动 QuickTime 来运行您的示例视频。如果您此时遇到问题，我建议您搜索 Manim GitHub 的 问题 部分。 第 10 步：LaTeX所有形状和动画都应该在这一点上起作用。但是，要使单词起作用，我们需要对几个文件进行一些修改。这些变化对我有用。 打开 utils/tex_file_writing.py 并向下滚动到最后两个函数，然后更改它们，使它们看起来像这样（对于截图感到抱歉 - 目前在保持格式化的同时发布代码时出现问题）： 需要修改的最后一个文件是 tex_template.tex。继续前进，让你看起来像： 第 11 步：最终测试既然已经进行了这些更改，请继续尝试运行： 1python3 extract_scene.py example_scenes.py WriteStuff -pl 希望所有人都为你工作！ 如果有问题，我建议在 3b1b 的 GitHub 上发布一个问题。那里有更多知识渊博的人，并且通过综合帮助你解决问题的机会更大。 原文：MANIM FOR MAC 作者：Brian M. Howell]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>Python</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的知乎帐号无故被限制使用]]></title>
    <url>%2F2019%2F06%2F21%2Fzhihu%2F</url>
    <content type="text"><![CDATA[昨天在知乎发了 3 篇文章 SwiftUI 教程 升级 hexo 解决 Upgrade braces to version 2.3.1 “达观杯”文本分类挑战赛新手入门代码 一个想法 #Kindle Oasis（第 3 代）# 买了 Oasis 2，退了换 3，到时候再评论值不值得买吧！ 今天早上起来一看，帐号异常 您的帐号由于存在异常行为暂时被限制使用如需恢复，请 解封帐号 帐号解封如果无法发送短信，可输入验证码后向管理员申诉你的帐号由于存在异常行为已被知乎反作弊系统限制，部分功能暂不可用，如想解除限制，请使用该帐号绑定的手机 158**xxxx 发送短信进行解封 编辑短信内容 460610 请发到 1069 1387 21212 短信发送完毕后，请点击「我已发完短信」。 短信内容 30 分钟内有效。 无法发送短信? 向管理员申诉解封如果无法发送短信，可以输入验证码后向管理员申诉。 写想法时 你的帐号由于存在异常行为暂时被知乎反作弊系统限制使用，我们已收到了您的申诉信息，24 小时内会以私信的方式告知你申诉结果，请耐心等待。 不知道说什么好了最新进展：2019/06/21 09:58 你的知乎帐号被永久禁言 不想说话]]></content>
      <categories>
        <category>感叹</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“达观杯”文本分类挑战赛新手入门代码]]></title>
    <url>%2F2019%2F06%2F20%2Fdaguan-cup%2F</url>
    <content type="text"><![CDATA[任务建立模型通过长文本数据正文(article)，预测文本对应的类别(class) 数据 注 : 报名参赛或加入队伍后，可获取数据下载权限。 数据包含 2 个 csv 文件： train_set.csv：此数据集用于训练模型，每一行对应一篇文章。文章分别在“字”和“词”的级别上做了脱敏处理。共有四列： 第一列是文章的索引(id)， 第二列是文章正文在“字”级别上的表示，即字符相隔正文(article)； 第三列是在“词”级别上的表示，即词语相隔正文(word_seg)； 第四列是这篇文章的标注(class)。 注：每一个数字对应一个“字”，或“词”，或“标点符号”。“字”的编号与“词”的编号是独立的！ test_set.csv：此数据用于测试。数据格式同 train_set.csv，但不包含 class。 注：test_set与train_test中文章id的编号是独立的。 友情提示：请不要尝试用excel打开这些文件！由于一篇文章太长，excel可能无法完整地读入某一行！ 评分标准评分算法binary-classification 采用各个品类F1指标的算术平均值，它是 Precision 和 Recall 的调和平均数。 其中，Pi 是表示第 i 个种类对应的 Precision， Ri 是表示第 i 个种类对应 Recall。 AB 榜的划分方式和比例：【1】评分采用AB榜形式，提交文件必须包含测试集中所有用户的预测值。排行榜显示A榜成绩，竞赛结束后2小时切换成B榜单。B榜成绩以选定的两次提交或者默认的最后两次提交的最高分为准，最终比赛成绩以B榜单为准。【2】此题目的AB榜是随机划分，A榜数据占50%，B榜使用全量测试集，即占100%。 挑战赛任务背景文本分类 这个比赛的任务就是文本分类，是自然语言处理 (NLP) 领域里一项 最最基本的任务。 但这个任务的难点就是在于，文本的长度非常长， 大约3000个词，一般任务也就300词。 而文本的长度过长对文本的 智能解析带来了很多挑战。 概念 字 词 中文分词 用传统的监督学习模型对一段文 本进行分类的基本过程这里提前假设:已经有了一个学习的机器学习模型 f，供你使用 注:函数输出的类别是我们事先人为约定好，比如我让数字4代表政治类， 数字3代表科技类，… 比赛数据训练数据集测试数据集求解问题的本质求一个数学函数(又可称为机器学习模型): y=f\left(x_{1}, x_{2}, x_{3}, \ldots, x_{6}\right)使模型预测能力更强 哪些机器学习算法 传统的监督学习算法(西瓜书各章节都有对应) 比如，对数几率回归/支持向量机/朴素贝叶斯/决策树/集成学习 等 深度学习 比如 cnn/rnn/attention 等模型 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Thu Jun 20 21:17:51 2019@author: iosdevlog"""""" 导入所需要的软件包 """import pandas as pd from sklearn.linear_model import LogisticRegression #导入线性回归库from sklearn.feature_extraction.text import CountVectorizer #导入特征提取库print("开始")"""@ 代码功能简介： 从硬盘上读取已下载好的数据，并进行简单处理@ 知识点定位：数据预处理"""#读取文件，并且删除无关东西df_train = pd.read_csv("./train_set.csv")df_test = pd.read_csv("./test_set.csv")df_train.drop(columns =["article", "id"], inplace = True ) # 为什么要删除这两个列? id 列无意义，不需要用 article，可直接删除df_test.drop(columns =["article"], inplace = True ) """@ 代码功能简介：将数据集中的字符文本转换成数字向量，以便计算机能够进行处理 （一段数字 ---&gt; 一个向量）@ 知识点定位：特征工程"""# 获取特征向量vectorizer = CountVectorizer(ngram_range = (1,2), min_df = 3, max_df = 0.9, max_features = 100000) # 特征提取vectorizer.fit(df_train["word_seg"]) # 为什么要训练这一列内容? 要先学习整个数据集的词的 DF（文档词频）x_train = vectorizer.transform(df_train["word_seg"]) #特征转为特征向量x_test = vectorizer.transform(df_test["word_seg"])y_train = df_train["class"] - 1 # 这里为啥要给所有的类别都减去 1? 减 1 是代码习惯问题，让 class 从 0 计数"""@ 代码功能简介：训练一个分类器@ 知识点定位：传统坚督学习 之 线性逻辑回归模型"""lg = LogisticRegression(C = 4, dual = True) # 逻辑回归初始化lg.fit(x_train, y_train) # 进行训练，模型保存在 lg 里面"""根据上面训练好的分类器对测试集的每个样本进行预测"""y_test = lg.predict(x_test) # 用模型进行测试"""将测试集的预测结果保存至本地"""# 根据上面训练好的分类器对测试集的每个样本进行预测df_test["class"] = y_test.tolist() # 测试结果转为列表，并且放入测试文档的类别里面。问题5：测试文档没有类别这个列。这行代码会自动给测试文档添加一个类别列。df_test["class"] = df_test["class"] + 1 # 为什么又要给所有类别分别加 1df_result = df_test.loc[:, ["id", "class"]] # 从测试集里面拿到 ["id", "class"] 列的内容df_result.to_csv("./result.csv", index = False) #测试结果转为提交的CSV格式print("结束") 如何提高模型性能 数据预处理 特征工程 机器学习算法 模型集成 参考： “达观杯”文本智能处理挑战赛_赛体与数据 Kaggle: Starter:“达观杯”文本分类挑战赛新手入门代码 深度之眼]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级 hexo 解决 Upgrade braces to version 2.3.1]]></title>
    <url>%2F2019%2F06%2F20%2Falert%2F</url>
    <content type="text"><![CDATA[更新 https://2019.iosdevlog.com/ 时提示 GitHub 在 2019 的默认分支上发现了 3 个漏洞（1个高，2个中等）。 赶紧去看一下。 那我还是升级一下好了。 查看 hexo-cli 当前版本123456789101112131415161718192021$ hexo -vhexo: 3.8.0hexo-cli: 1.1.0os: Darwin 18.6.0 darwin x64node: 11.12.0v8: 7.0.276.38-node.18uv: 1.26.0zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 67nghttp2: 1.34.0napi: 4llhttp: 1.1.1http_parser: 2.8.0openssl: 1.1.1bcldr: 34.0icu: 63.1tz: 2018eunicode: 11.0 安装 hexo-cli 新版本12345678910111213141516171819202122$ npm install -g hexo-cli$ hexo -vhexo: 3.8.0hexo-cli: 2.0.0os: Darwin 18.6.0 darwin x64node: 11.12.0v8: 7.0.276.38-node.18uv: 1.26.0zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 67nghttp2: 1.34.0napi: 4llhttp: 1.1.1http_parser: 2.8.0openssl: 1.1.1bcldr: 34.0icu: 63.1tz: 2018eunicode: 11.0 更新 npm 包1npm update 再上传到 GitHub。 警告消失了，这下舒心多了。]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费学习 SwiftUI]]></title>
    <url>%2F2019%2F06%2F20%2FSwiftUI%2F</url>
    <content type="text"><![CDATA[原文：Learn SwiftUI with free tutorials作者：Paul Hudson SwiftUI 是在 WWDC19 的主题演讲期间宣布的，我们已经看过大量的免费教程，如文章，YouTube 视频，书籍等等 - 可以肯定的是，人们很兴奋，并且热衷于分享这种兴奋。世界！ 我自己一直在创建很多 SwiftUI 教程，但我也一直在阅读许多其他开发人员的教程。在本文中，我试图将来自各个人的教程汇集在一起 ​​，因为每个人都学到了不同的东西 - 希望你能找到一个以适合你的方式教授 SwiftUI 的教程。 SwiftUI 示例在 SwiftUI 发布后不久，我发布了一篇名为 Get starts with SwiftUI 的文章，其中概述了创建视图，堆栈，列表等的基础知识。 从那时起，我已经制作了大量的 SwiftUI 示例代码和视频： SwiftUI 示例在线 - 我的 SwiftUI 示例代码集的免费在线版。 SwiftUI 示例电子书 - 本书 的下载版本。 SwiftUI by Example 视频播放列表 - YouTube 视频播放 列表，可帮助您解决常见问题。 最近，我一直致力于在 SwiftUI 中创建完整应用程序的视频，以便人们可以看到行动中的概念，而不是孤立的例子。例如： 使用导航和图像构建动态列表应用程序 用 VStack，图像和警报构建一个标志猜谜游戏 使用对象绑定和自定义修改器构建 iBeacon 检测器 使用堆栈，步进器和日期选择器构建 Core ML 应用程序 这些视频不是太长，但仍然有足够的空间来真实展示 SwiftUI 的强大和简洁。这是一个让你入门的例子： SwiftUI Tutorial: Build a dynamic list app with navigation and images – SwiftUI Complete Apps #1 开始使用 SwiftUI有很多人在编写教程，旨在帮助您开始使用 SwiftUI。他们在构建内容方面遇到各种难度级别 - 它们都旨在帮助您入门，但有些比其他人更容易！ 当然，我应该通过说 Apple 自己的 SwiftUI 教程 非常出色来开始这个列表 - 大量的代码，大量的屏幕截图，甚至测验问题来帮助测试你的学习。 对于绝对的初学者 Santosh Botre 为各种 SwiftUI 组件提供了一些很好的示例代码。 Sai Kambampati 有一个很好的教程，建立一个有剪裁和阴影的漂亮的列表应用程序。 Martin Lasek 撰写了一篇非常轻松的介绍，其中包含大量截图和实验空间。 John Sundell 撰写了一篇精彩的初学者教程，向您介绍了各种 SwiftUI 组件的基础知识。 走得更远 Mischa Hildebrand 编写了一个教程，专注于 SwiftUI 背后的 Swift 语法的一个特定部分：some 关键字。 Majid Jabrayilov 写了一个教程，引导您构建一个用于搜索 GitHub repos 的应用程序。 Rohan Panchal 从 React Native 的角度编写了一个接近 SwiftUI 的教程。 Audrey Tam 有一个非常简单的教程，但随后会通过状态，组合，警报等向上移动。 Benedikt Terhechte 写了一篇文章，从游戏引擎的角度探索 SwiftUI，直接进入堆栈和状态。 影片我们在 Swift 社区拥有各种各样的视频创作者，很高兴看到他们对 SwiftUI 如此兴奋！ 以下是已有的许多 SwiftUI 视频的选择： 你好 SwiftUI！ 作者 Ben Scheirman。 SwiftUI 简介： Kilo Loco 的 简单状态管理 MohamUI Azam 对 SwiftUI 中绑定的介绍 MohamUI Azam 在 SwiftUI 中传递视图之间的数据 Brian Advent 的 简单 SwiftUI 应用程序 SwiftUI：Facebook 复杂布局 - Brian Voong 的 横向滚动视图。 SwiftUI：@state 和 @Binding 由斯科特 · 史密斯 SwiftUI - 理解绑定 - Martin Lasek SwiftUI 初学者 - 构建您的第一个应用程序！ 加里 · 托克曼 Caleb Wells 的 SwiftUI 教程＃1 由 Ben Scheirman 在 SwiftUI 中提示计算器 在 Kilo Loco 的 项目中同时使用 UIKit 和 SwiftUI 每天都会出现包含更多主题的新视频，因此如果您需要定期更新，可能需要订阅其中一些频道。 一般讨论; 一般交流SwiftUI 上没有结束热门话题，但是少数特别有经验的人花了很多时间从各种角度编写一个更加深思熟虑的视图。 特别是，我喜欢这些： Matt Gallagher 对 SwiftUI的 第一印象 将 SwiftUI 与他自己的声明性 UI 工作进行了比较。 RxSwift 与 Shai Mishali 的 Apple 合并 “Cheat Sheet” SwiftUI，个人想法和 David Cordero 的 Model-View-Presenter 了解 SwiftUI 样品 由锐佩雷斯着眼于 SwiftUI 一小段代码，侧重于语言如何 Swift 的特点使它发挥作用。 虽然几乎每个人都对 SwiftUI 持肯定态度，但值得加入一点怀疑 - 请参阅 Jille van der Weerd 对 SwiftUI 的 Skeptics 观点。 现在在哪里？像 JuanpeCatalán 关于 SwiftUI 和 Yogesh Singh 的 Awesome SwiftUI 这样的网站正在出现，以帮助我们跟踪 SwiftUI 可用的许多资源 - 如果你渴望获得更多的 SwiftUI，你应该从那里开始。 但最终，我们只是在 SwiftUI 的早期阶段，我们仍然可以期待在 Xcode 11 GM 的 1.0 版本之前进行大量的更改。我不了解你，但我特别期待 Forms 代码，更多关于常见 UIKit 控件的包装器，以及其余的 Combine 框架掉线！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》第 14 章 聚类方法 KMeans]]></title>
    <url>%2F2019%2F06%2F11%2Fkmeans%2F</url>
    <content type="text"><![CDATA[k-均值聚类n 个样本分到 k 个不同的类或簇，每个样本到其所属类的中心的距离最小。 每个样本只能属于一个类，所有 k-均值聚类 是 硬聚类。 模型 k &lt; n G_{i} \cap G_{j} = \varnothing, \bigcup_{i=1}^{k}G_{i} = X 策略 距离： 欧式距离 损失函数：样本与所属类的中心的距离总保 NP 困难问题 算法目标函数极小化 初始化，随机取 $ k $ 个样本做中心 对样本进行聚类，计算样本到类中心距离，每个样本指派到与其最近的中心的类 计算新的类中心。对聚类结果计算样本的均值，做为新的类中心 如果迭代收敛或符合停止条件，输出。否则，令 $ t = t + 1 $ ，返回 2 123456789101112131415161718192021222324252627def fit(self, X): self._setup_input(X) n_samples, _ = X.shape # 从 X 中随机获取 k 个元素做中心 self._centers = np.array( random.sample(list(np.unique(X, axis=0)), self.k)) old_clusters = None n_iters = 0 while True: new_clusters = [self._min_k(x) for x in X] if new_clusters == old_clusters: print("Training finished after &#123;n_iters&#125; iterations!".format(n_iters=n_iters)) return old_clusters = new_clusters n_iters += 1 for cluster_i in range(self.k): # 计算新的中心 points_idx = np.where(np.array(new_clusters) == cluster_i) xi = X[points_idx] self._centers[cluster_i] = xi.mean(axis=0) self._centers_list.append(np.copy(self._centers)) 源码：https://github.com/iOSDevLog/slmethod]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》使用 Travis-CI 持续集成]]></title>
    <url>%2F2019%2F06%2F05%2Ftravis%2F</url>
    <content type="text"><![CDATA[GitHub 与 持续集成 Travis-CI 的集成非常简单。 构建 Python 项目Building a Python Project 指定 Python 版本使用python密钥指定 python 版本。当我们更新 Python 构建映像时，别名3.6会指向不同的确切版本或补丁级别。 123456789language: pythonpython: - '3.5' - '3.6' - '3.7'install: - pip install -r requirements.txtscript: - pytest slmethod Python 3.7 及更高版本您需要添加 dist: xenial 到您的 .travis.yml 文件以使用 Python 3.7 及更高版本。 例如： 1234dist: xenial # required for Python &gt;= 3.7language: pythonpython: - "3.7" PyPI 部署https://docs.travis-ci.com/user/deployment/pypi/ 成功构建后，Travis CI 可以自动将 Python 包发布到PyPI。 对于最小配置，请将以下内容添加到.travis.yml： 1234deploy: provider: pypi user: "Your username" password: "Your password" 但是，这会将您的 PyPI 密码暴露给全世界。我们建议您加密密码并通过运行以下命令将其添加到.travis.yml： 安装 travis-encrypt 1pip install travis-encrypt 然后在 .travis.yml 所在目录执行： 1travis encrypt your-password-here --add deploy.password 或者 1travis-encrypt --deploy iosdevlog slmethod .travis.yml 这个要按提示输入 pypi 密码。 请注意，如果您的 PyPI 密码包含特殊字符，则需要在加密密码之前将其转义。 部署 tag最有可能的是，当您的软件包的新版本被删除时，您只想部署到 PyPI。为此，您可以告诉 Travis CI 仅部署在标记的提交上，如下所示： 123456deploy: provider: pypi user: ... password: ... on: tags: true 如果在本地标记提交，请记住运行 git push --tags 以确保将标记上载到 GitHub。 部署特定分支您可以使用on选项显式指定要释放的分支： 123456deploy: provider: pypi user: ... password: ... on: branch: master 或者，您也可以将 Travis CI 配置为从所有分支发布： 123456deploy: provider: pypi user: ... password: ... on: all_branches: true 默认情况下，Travis CI 仅从主分支发布。 从 Pull Requests 触发的构建永远不会触发发布。 有条件的发布只有在满足某些条件时才能部署。请参阅条件发布on:。 123456789language: pythondeploy: provider: pypi user: ... password: ... on: python: 3.7 tags: true branch: master 只在 Python 3.7 发布。 最后的示例。 12345678910111213141516171819dist: xenial # required for Python &gt;= 3.7language: pythonpython: - '3.5' - '3.6' - '3.7'install: - pip install -r requirements.txtscript: - pytest slmethoddeploy: provider: pypi user: iosdevlog on: python: 3.7 tags: true branch: master password: secure: xxxx 可以发现 slmethod 升级到了 0.1.3 版本，说明已经部署成功了。 测试一下，先安装 slmethod。 1pip3 install slmethod 显示版本，可以发到已经是 0.1.3。 123456789101112131415161718192021$ python3Python 3.7.3 (default, Mar 27 2019, 09:23:15)[Clang 10.0.1 (clang-1001.0.46.3)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import slmethod&gt;&gt;&gt; slmethod.show_versions()System: python: 3.7.3 (default, Mar 27 2019, 09:23:15) [Clang 10.0.1 (clang-1001.0.46.3)]executable: /usr/local/opt/python/bin/python3.7 machine: Darwin-18.6.0-x86_64-i386-64bitPython deps: pip: 19.0.3setuptools: 40.8.0 numpy: 1.16.2 scipy: 1.3.0 pandas: 0.24.2matplotlib: 3.1.0 sklearn: 0.21.2 slmethod: 0.1.3 添加 GitHub 项目徽章 打开 GitHub: https://github.com/iOSDevLog/slmethod 查看一下，果然显示项目徽章。 如果你喜欢这篇文章，欢迎去 GitHub 给我一个 star。]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》第 2 章 感知机 与 sklearn 对比]]></title>
    <url>%2F2019%2F06%2F05%2Fperceptron-vc-sklearn%2F</url>
    <content type="text"><![CDATA[Statistical Learning Method 统计学习方法 https://pypi.org/project/slmethod/ 1234import numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import make_classification%matplotlib inline 生成数据123456789# X 为样本特征，y 为样本类别输出，共 30 个样本，每个样本 2 个特# 输出有 2 个类别，没有冗余特征，每个类别一个簇，随机状态为小武小久X, y = make_classification(n_samples=40, n_features=2, n_informative=2, n_redundant=0, n_classes=2, n_clusters_per_class=1, random_state=59) 处理 y 值，取值为范围 {-1, 1}1y = np.array([1 if i == 1 else -1 for i in y]) 1X array([[ 1.26654361, 1.20833252], [ 2.06535223, -2.13177734], [ 0.11811139, 0.76083319], [ 0.90184139, -0.93177662], [ 0.96240122, -0.99933393], [ 0.32421018, -0.79732491], [ 0.16465073, -0.67426018], [-0.8393532 , 0.02946355], [ 1.50737475, -1.62701845], [ 1.81169336, -1.46844229], [ 2.63399788, 0.97604937], [ 1.59518059, -1.52110826], [ 1.74505037, 1.46262955], [ 1.86201667, 0.93060442], [ 0.11905276, -0.52595242], [ 1.48508147, -0.97794231], [-0.92705557, 0.39367018], [ 3.42983834, -2.72193889], [ 1.99481682, 1.60244273], [ 2.59197055, 1.29968242], [ 1.60598522, -1.13518763], [ 1.52118196, 1.12174498], [ 0.13097699, -0.58481754], [ 0.84318571, 0.65777867], [ 1.0940501 , -0.02064728], [ 0.36579428, 1.32704784], [ 1.46113021, 1.11893705], [ 0.42126239, -0.25448586], [ 0.97213672, 0.63569881], [ 0.81731191, 0.7569019 ], [ 1.85348049, -1.36379487], [ 0.81830809, 0.89762419], [ 0.9559071 , -1.13200362], [ 1.19788365, 0.24486292], [ 0.43394253, 1.2190042 ], [ 0.75245696, -1.00391468], [ 0.26120942, -0.49444024], [ 0.23915671, 1.72744475], [ 1.33104015, 1.73132756], [ 2.37528241, 1.47588251]]) 1y array([ 1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1]) 1plt.scatter(X[:, 0], X[:, 1], c=y, s=40, marker='o') &lt;matplotlib.collections.PathCollection at 0x129908d68&gt; sklearn 里面的 Perceptron1from sklearn.linear_model import Perceptron 12clf = Perceptron(fit_intercept=True, max_iter=1000, shuffle=False)clf.fit(X, y) Perceptron(alpha=0.0001, class_weight=None, early_stopping=False, eta0=1.0, fit_intercept=True, max_iter=1000, n_iter_no_change=5, n_jobs=None, penalty=None, random_state=0, shuffle=False, tol=0.001, validation_fraction=0.1, verbose=0, warm_start=False) 12# Weights 权重（值）print(clf.coef_) [[2.06165026 2.89632885]] 12# bias 截距print(clf.intercept_) [-1.] 12345678plt.scatter(X[:, 0], X[:, 1], c=y, s=40, marker='o')minX = np.min(X[:, 0])maxX = np.max(X[:, 0])x_points = np.array([minX, maxX])sklearn_y = -(clf.coef_[0][0] * x_points + clf.intercept_) / clf.coef_[0][1]plt.plot(x_points, sklearn_y, 'b-.', label='sklearn', linewidth=0.3) [&lt;matplotlib.lines.Line2D at 0x12bdbe320&gt;] 原始感知机1from slmethod.perceptron import Perceptron 12origin_clf = Perceptron(dual=False)origin_clf.fit(X, y) 1print(origin_clf.w) [0.20616503 0.28963289] 1print(origin_clf.b) -0.1 对偶形式12dual_clf = Perceptron(dual=True)dual_clf.fit(X, y) 1print(dual_clf.w) [0.20616503 0.28963289] 1print(dual_clf.b) -0.1 绘图123456789plt.scatter(X[:, 0], X[:, 1], c=y, s=40, marker='o')sklearn_y = -(clf.coef_[0][0] * x_points + clf.intercept_) / clf.coef_[0][1]origin_y = -(origin_clf.w[0] * x_points + origin_clf.b) / origin_clf.w[1]dual_y = -(dual_clf.w[0] * x_points + dual_clf.b) / dual_clf.w[1]plt.plot(x_points, sklearn_y, 'b*', label='sklearn')plt.plot(x_points, origin_y, 'r.-', label='origin')plt.plot(x_points, dual_y, 'g-.', label='dual')plt.legend()plt.show() slmethod 绘图slmethod 库的 估计器有一个 show2D() 方法，可以绘制动态图。 从上图可以看到 sklearn，原始类型和对偶形式的线几乎重合了。]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》第 2 章 感知机 可视化]]></title>
    <url>%2F2019%2F06%2F05%2Fperceptron%2F</url>
    <content type="text"><![CDATA[源码：https://github.com/iOSDevLog/slmethod原理假设输入空间（特征空间）是 $\mathrm{x} \subseteq \mathrm{R}^{n}$，输出空间是$y={+1,-1}$ 模型 f(x)=\operatorname{sign}(w \cdot x+b)称为 感知机。 $\mathrm{w}$ 和 $\mathrm{b}$ 为感知机模型参数 $\mathrm{w} \subseteq \mathrm{R}^{n}$叫作权重/权值（weight）或权值向量（weight vector） $\mathrm{b} \in \mathrm{R}$ 叫作偏置（bias） $\mathbf{w} \cdot \mathbf{x}$ 表示 $\mathbf{w}$ 和 $\mathbf{x}$ 的内积 $sign$ 是符号函数 \operatorname{sign}(x)=\left\{\begin{array}{ll}{+1,} & {x \geqslant 0} \\ {-1,} & {x]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》slmethod GitHub 模板]]></title>
    <url>%2F2019%2F06%2F03%2Fissue-template%2F</url>
    <content type="text"><![CDATA[GitHub 地址：https://github.com/iOSDevLog/slmethod 关于问题和拉取请求模板使用问题和拉取请求模板，您可以自定义和标准化您希望贡献者在打开问题和在存储库中提取请求时包含的信息。 在存储库中创建问题并提取请求模板后，贡献者可以根据存储库的贡献指南使用模板打开问题或描述其提取请求中的建议更改。有关向存储库添加贡献指南的更多信息，请参阅“ 为存储库贡献者设置指南 ”。 您可以为组织创建默认问题并提取请求模板。有关详细信息，请参阅“ 为组织创建默认社区运行状况文件 ”。 问题模板使用问题模板构建器为存储库创建问题模板时，它们可供贡献者在存储库中打开新问题时使用。 使用模板构建器，您可以为每个模板指定标题和描述，添加模板内容，并将模板提交到默认分支或在存储库中打开pull请求。模板构建器会自动添加模板在新问题页面上显示所需的YAML前端事项标记。有关更多信息，请参阅“ 为存储库创建问题模板 ”。 问题模板存储在存储库的默认分支中，位于隐藏.github/ISSUE_TEMPLATE目录中。如果您在另一个分支中创建模板，则协作者无法使用该模板。问题模板文件名不区分大小写，并且需要.md扩展名。要包含在社区配置文件清单中，问题模板必须位于.github/ISSUE_TEMPLATE文件夹中，并包含有效name:和about:。 创建问题模板12mkdir -p .github/ISSUE_TEMPLATE # 在 .github 中创建模板vim .github/ISSUE_TEMPLATE/Bug_report.md 创建 PR 模板… 参考： Creating a default community health file for your organization About issue and pull request templates]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacBook Pro 安装 Windows 10]]></title>
    <url>%2F2019%2F06%2F02%2Fwindows%2F</url>
    <content type="text"><![CDATA[最近需要在 Windows 10 下开发 C# WinForm 应用，还可能要随身携带。 家里只有一台 Windows 10 台式机，还有 2 台 MacBook：一台 Air 几乎不能用多长时间，还有一台 MacBook Pro。 最终只能在 MacBook Pro 上使用 BootCamp 安装 Windows。 首先去 https://msdn.itellyou.cn 下载 Win10 镜像。 最新版是 Windows 10, Version 1903 2019 年 4 月 19 日发布。 安装过程参照 https://support.apple.com/zh-cn/boot-camp。 安装前最好完整看一遍安装教程。安装前最好完整看一遍安装教程。安装前最好完整看一遍安装教程。 重要的事情说 3 遍。 安装 Windows现在您可以通过以下步骤在 Mac 上安装 Windows 了： 1. 打开“启动转换助理”并创建 BOOTCAMP 分区从“应用程序”文件夹内的“实用工具”文件夹中打开“启动转换助理”，然后按照屏幕上的说明操作。这个应用将协助您在启动磁盘上创建 BOOTCAMP 分区，并下载 Windows 的相关软件驱动程序。 BOOTCAMP 分区创建完成之后就不能再调整大小，因此请确保指定的分区大小符合您的需求。为了获得最佳体验，Apple 建议至少设置 128GB。 如果您在安装期间收到提示，请连接一个空白的 USB 2 闪存驱动器（我的不需要使用 USB）。 2. 对 BOOTCAMP 分区进行格式化在“启动转换助理”完成操作后，Mac 会重新启动并运行 Windows 安装器。在大多数情况下，安装器会自动选择正确的分区并进行格式化。如果您使用闪存驱动器或光盘驱动器来安装 Windows，安装器可能会询问您希望将 Windows 安装到什么位置。请选择 BOOTCAMP 分区，再点按“格式化”。 3. 安装 Windows 和 Windows 支持软件请拔下在安装期间不需要使用的所有外部设备，如显示器和磁盘。然后按照屏幕上的提示来安装 Windows。安装完成后，您的 Mac 会在 Windows 中启动，并打开 Windows 支持软件安装器。 如果屏幕没有自动显示“欢迎使用‘启动转换’安装器”，您需要手动安装 Windows 支持软件。 强烈建议看上一条链接，我就需要 手动安装 Windows 支持软件。 手动安装 Windows 支持软件如果您遇到以上所列症状，或者如果您知道 Windows 支持软件不是通过“启动转换助理”安装的，可以按照以下步骤运行安装器。 由于此时还没有安装 Windows 驱动程序，您可能会发现使用 USB 鼠标可以更轻松地进行浏览。 前往 OSXRESERVED 分区，这通常是 D:\ 驱动器。 打开 OSXRESERVED 分区中的“BootCamp”文件夹，然后运行“Setup”文件。确保您是在“BootCamp”文件夹中运行“Setup”文件，而不是在任何其他位置。 按照屏幕上的提示完成安装适用于“启动转换”的 Windows 支持软件。 如果您愿意，可以在命令行键入 D:\BootCamp\setup.exe 来运行安装器。 有关非 Apple 制造的产品或非 Apple 控制或测试的独立网站的信息仅供参考，不代表 Apple 的任何建议或保证。Apple 对于第三方网站或产品的选择、性能或使用不承担任何责任。Apple 对于第三方网站的准确性和可靠性不作任何担保。互联网的使用具有一定风险。请联系供应商以了解其他信息。其他公司和产品名称可能是其各自所有公司的商标。 如何在 macOS 和 Windows 之间切换重新启动 Mac，然后立即按住 Option 键。当您看到“启动管理器”窗口时，松开 Option 键。选择您的 macOS 或 Windows 启动磁盘，然后点按箭头或按下 Return 键。每当您需要在操作系统之间切换时，请重复这些步骤。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>MacBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》 pip 库]]></title>
    <url>%2F2019%2F05%2F31%2Fpypi%2F</url>
    <content type="text"><![CDATA[新建 GitHub 仓库打开 https://github.com/new，新建一个公共仓库。 仓库名为 slmethod, 统计学习方法（Statistical Learning Method）的简写 Public 公开仓库 勾选 Initialize this repository with a README .gitignore 选择 Python 添加 MIT License 源码地址：https://github.com/iOSDevLog/slmethod 下载代码到本地，使用 ssh 协议。 1git clone git@github.com:iOSDevLog/slmethod.git 使用 cz-cli 提交代码。 1git cz 打包 Python 项目新建虚拟环境1mkvirtualenv slm 创建以下文件结构：12345slmethod├── LICENSE├── README.md└── slm └── __init__.py 编辑 slm/__init__.py 1name = "slm" 创建 setup.pysetup.py 是 setuptools 的构建脚本。它告诉 setuptools 你的包（例如名称和版本）以及要包含的代码文件。 打开 setup.py 并输入以下内容，更新软件包名称以包含您的用户名。 123456789101112131415161718192021222324252627import setuptoolswith open("README.md", "r") as fh: long_description = fh.read()setuptools.setup( name="slm", version="0.0.1", author="iOSDevLog", author_email="iosdevlog@iosdevlog.com", description="Statistical Learning Method package", long_description=long_description, long_description_content_type="text/markdown", url="https://github.com/iOSDevLog/slmethod", packages=setuptools.find_packages(), classifiers=[ "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "License :: OSI Approved :: MIT License", "Operating System :: Microsoft :: Windows", "Operating System :: POSIX", "Operating System :: Unix", "Operating System :: MacOS", ],) setup() 需要几个论点。此示例包使用相对最小的集： name 是包的 分发名称。只要包含字母，数字 _ 和，就可以是任何名称 -。它也不能在 pypi.org 上使用。请务必使用您的用户名更新此内容， 因为这样可确保您不会尝试上传与上传程序包时已存在的程序包相同的程序包。 version 是包版本看 PEP 440 有关版本的更多详细信息。 author 和 author_email 用于识别包的作者。 description 是一个简短的，一句话的包的总结。 long_description 是包的详细说明。这显示在 Python Package Index 的包详细信息包中。在这种情况下，加载长描述 README.md 是一种常见模式。 long_description_content_type 告诉索引什么类型的标记用于长描述。这里是 Markdown 格式。 url 是项目主页的 URL。对于许多项目，这只是一个指向 GitHub，GitLab，Bitbucket 或类似代码托管服务的链接。 packages 是应包含在 分发包 中的所有 Python 导入包 的列表。我们可以使用 自动发现所有包和子包，而不是手动列出每个包。在这种情况下，包列表将是 slm 因为它是唯一存在的包。find_packages() classifiers 给出了指数和 pip 你的包一些额外的元数据。在这种情况下，该软件包仅与 Python 3 兼容，根据 MIT 许可证进行许可，并且与操作系统无关。您应始终至少包含您的软件包所使用的 Python 版本，软件包可用的许可证以及您的软件包将使用的操作系统。有关分类器的完整列表，请参阅 https://pypi.org/classifiers/。 除了这里提到的还有很多。有关详细信息，请参阅 打包和分发项目。 生成分发档案 下一步是为 包 生成分发包。这些是上传到包索引的档案，可以通过 pip 安装。 确保您拥有 setuptools 并 wheel 安装了最新版本： 12python3 -m pip install --user --upgrade setuptools wheel # 不在虚拟环境时python3 -m pip install --upgrade setuptools wheel # 在虚拟环境不需要 --user 小提示 如果您在安装它们时遇到问题，请参阅 安装包 教程。 现在从 setup.py 位于的同一目录运行此命令： 1python3 setup.py sdist bdist_wheel 此命令应输出大量文本，一旦完成，应在 dist 目录中生成两个文件： 123dist├── slm-0.0.1-py3-none-any.whl└── slm-0.0.1.tar.gz 注意 如果您遇到麻烦，请复制输出并提出有关 包装问题的问题，我们会尽力为您提供帮助！ 该 tar.gz 文件是 源存档， 而该 .whl 文件是 构建的分发。较新的 pip 版本优先安装构建的发行版，但如果需要，将回退到源代码存档。您应该始终上传源存档并为项目兼容的平台提供构建的存档。在这种情况下，我们的示例包在任何平台上都与 Python 兼容，因此只需要一个构建的发行版。 上传分发档案 最后，是时候将您的包上传到 Python Package Index 了！ 您需要做的第一件事是在 Test PyPI 上注册一个帐户。Test PyPI 是用于测试和实验的包索引的单独实例。这对于像我们不一定想要上传到真实索引的本教程这样的东西很棒。要注册帐户，请访问 https://test.pypi.org/account/register/ 并完成该页面上的步骤。在您上传任何套餐之前，您还需要验证您的电子邮件地址。有关 Test PyPI 的更多详细信息，请参阅 使用 TestPyPI。 现在您已注册，您可以使用 twine 上传分发包。你需要安装 Twine： 12python3 -m pip install --user --upgrade twinepython3 -m pip install --upgrade twine # 虚拟环境不用 --user 安装完成后，运行 Twine 以上传所有存档 dist： 1python3 -m twine upload --repository-url https://test.pypi.org/legacy/ dist/* 系统将提示您输入使用 Test PyPI 注册的用户名和密码。 12345678python3 -m twine upload --repository-url https://test.pypi.org/legacy/ dist/*Enter your username: iOSDevLogEnter your password:Uploading distributions to https://test.pypi.org/legacy/Uploading slm-0.0.1-py3-none-any.whl100%|██████████████████████████████████████████████████████████████████████████████████| 5.95k/5.95k [00:00&lt;00:00, 12.2kB/s]NOTE: Try --verbose to see response content.HTTPError: 403 Client Error: Invalid or non-existent authentication information. for url: https://test.pypi.org/legacy/ 错误的用户验证信息，你需要创建一个用户验证文件 ~/.pypirc。 1234567[distutils]index-servers=pypi[pypi]repository = https://upload.pypi.org/legacy/username =password = 使用 twine upload dist/* 上传。 123456twine upload dist/*Uploading distributions to https://upload.pypi.org/legacy/Uploading slm-0.0.1-py3-none-any.whl100%|███████████████████████████████████████████████████████████████████████████████| 5.95k/5.95k [00:01&lt;00:00, 3.11kB/s]NOTE: Try --verbose to see response content.HTTPError: 403 Client Error: The user &apos;iosdevlog&apos; isn&apos;t allowed to upload to project &apos;slm&apos;. See https://pypi.org/help/#project-name for more information. for url: https://upload.pypi.org/legacy/ 可能有重名了，我改一下。 1name=&quot;slm&quot; 改为 1name=&quot;slmethod&quot;, 再试一次。 12python3 setup.py sdist bdist_wheeltwine upload dist/* 命令完成后，您应该看到与此类似的输出： 12345Uploading distributions to https://upload.pypi.org/legacy/Uploading slmethod-0.0.1-py3-none-any.whl100%|███████████████████████████████████████████████████████████████████████████████| 6.01k/6.01k [00:00&lt;00:00, 8.88kB/s]Uploading slmethod-0.0.1.tar.gz100%|███████████████████████████████████████████████████████████████████████████████| 4.91k/4.91k [00:01&lt;00:00, 4.19kB/s] 上传后，您的软件包应该可以在 TestPyPI 上查看，例如，https://pypi.org/project/slmethod/ 安装新上传的软件包12345pip install slmethodCollecting slmethod Downloading https://files.pythonhosted.org/packages/14/ab/9cc45b2879bf1e37963c6d36007974b3f9519d6a83169fc4a94252ea9a7c/slmethod-0.0.1-py3-none-any.whlInstalling collected packages: slmethodSuccessfully installed slmethod-0.0.1 或者 1python3 -m pip install --index-url https://test.pypi.org/simple/ --no-deps slmethod 1234Collecting slmethod Downloading https://test-files.pythonhosted.org/packages/.../slmethod-0.0.1-py3-none-any.whlInstalling collected packages: slmethodSuccessfully installed slmethod-0.0.1 确保在包名中指定您的用户名！ pip 应该从 Test PyPI 安装包，输出应该如下所示： 1python3 -m pip install --index-url https://test.pypi.org/simple/ --no-deps slmethod 注意 此示例使用 --index-urlflag 指定 TestPyPI 而不是实时 PyPI。另外，它指定 --no-deps。由于 TestPyPI 与实时 PyPI 没有相同的包，因此尝试安装依赖项可能会失败或安装意外的事情。虽然我们的示例包没有任何依赖关系，但在使用 TestPyPI 时避免安装依赖项是一种很好的做法。 您可以通过导入模块并引用先前 name 放置的属性来测试它是否已正确安装 __init__.py。 运行 Python 解释器（确保你仍然在你的 virtualenv 中）： 1python 然后导入模块并打印出 name 属性。这应该是一样的，不管你的名字你给您的 分发包 中 setup.py（在这种情况下，slm），因为你的导入包 是 slm。 123&gt;&gt;&gt; import slmethod&gt;&gt;&gt; print(slmethod.name)slmethod 后续步骤恭喜，您已经打包并分发了一个 Python 项目！ ✨🍰✨ 请记住，本教程向您展示了如何将程序包上传到 Test PyPI，它不是永久存储。测试系统偶尔会删除软件包和帐户。最好使用 Test PyPI 进行测试和实验，如本教程。 当您准备将真实包上传到 Python 包索引时，您可以像在本教程中那样执行相同操作，但具有以下重要差异： 为您的包装选择一个令人难忘的独特名称。您不必像在教程中那样附加用户名。 在 https://pypi.org 上注册一个帐户 - 请注意，这些是两个独立的服务器，并且测试服务器的登录详细信息不与主服务器共享。 使用上传你的包，并输入您的凭据为你真正的 PyPI 注册的账号。twine upload dist/* 使用真正的 PyPI 安装包。pip install [your-package] 在这一点上，如果你想阅读更多关于包装的 Python 库，你可以做以下事情： 阅读有关使用 setuptools 在打包和分发项目中打包库的 更多信息。 阅读 包装二进制扩展。 考虑诸如 flit，hatch 和poetry 之类的setuptools 的替代方案。]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scikit-learn]]></title>
    <url>%2F2019%2F05%2F28%2Fscikit-learn%2F</url>
    <content type="text"><![CDATA[Scikit-learn 介绍Scikit-learn 是开源的 Python 库，通过统一的界面实现机器学习、预处理、交叉验证及可视化算法。 scikit-learn 网站：https://scikit-learn.org Python 中的机器学习 简单有效的数据挖掘和数据分析工具 可供所有人访问，并可在各种环境中重复使用 基于 NumPy，SciPy 和 matplotlib 构建 开源，商业上可用 - BSD 许可证 分类确定对象属于哪个类别。 应用：垃圾邮件检测，图像识别。算法： SVM，最近邻居，随机森林，…… 回归预测与对象关联的连续值属性。 应用：药物反应，股票价格。算法： SVR，岭回归，套索，…… 聚类将类似对象自动分组到集合中。 应用：客户细分，分组实验结果算法： k-Means，谱聚类，均值漂移，…… 降维减少要考虑的随机变量的数量。 应用：可视化，提高效率算法： PCA，特征选择，非负矩阵分解。 模型选择比较，验证和选择参数和模型。 目标：通过参数调整提高准确性模块： 网格搜索，交叉验证，指标。 预处理特征提取和规范化。 应用程序：转换输入数据（如文本）以与机器学习算法一起使用。模块： 预处理，特征提取。 Scikit-learn 机器学习步骤1234567891011121314151617181920212223242526# 导入 sklearnfrom sklearn import neighbors, datasets, preprocessingfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import accuracy_score# 加载数据iris = datasets.load_iris()# 划分训练集与测试集X, y = iris.data[:, :2], iris.targetX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=33)# 数据预处理scaler = preprocessing.StandardScaler().fit(X_train)X_train = scaler.transform(X_train)X_test = scaler.transform(X_test)# 创建模型knn = neighbors.KNeighborsClassifier(n_neighbors=5)# 模型拟合knn.fit(X_train, y_train)# 预测y_pred = knn.predict(X_test)# 评估accuracy_score(y_test, y_pred) 导入常用库123import numpy as npimport pandas as pdimport matplotlib.pyplot as plt 加载数据Scikit-learn 处理的数据是存储为 NumPy 数组或 SciPy 稀疏矩阵的数字，还支持 Pandas 数据框等可转换为数字数组的其它数据类型。 123X = np.random.random((11, 5))y = np.array(['M', 'M', 'F', 'F', 'M', 'F', 'M', 'M', 'F', 'F', 'F'])X[X &lt; 0.7] = 0 划分训练集与测试集12from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0) 数据预处理标准化1234from sklearn.preprocessing import StandardScalerscaler = StandardScaler().fit(X_train)standardized_X = scaler.transform(X_train)standardized_X_test = scaler.transform(X_test) 归一化1234from sklearn.preprocessing import Normalizerscaler = Normalizer().fit(X_train)normalized_X = scaler.transform(X_train)normalized_X_test = scaler.transform(X_test) 二值化123from sklearn.preprocessing import Binarizerbinarizer = Binarizer(threshold=0.0).fit(X)binary_X = binarizer.transform(X) 编码分类特征123from sklearn.preprocessing import LabelEncoderenc = LabelEncoder()y = enc.fit_transform(y) 输入缺失值123from sklearn.preprocessing import Imputerimp = Imputer(missing_values=0, strategy='mean', axis=0)imp.fit_transform(X_train) 生成多项式特征123from sklearn.preprocessing import PolynomialFeaturespoly = PolynomialFeatures(5)poly.fit_transform(X) 创建模型估计器监督学习123456789101112# 线性回归from sklearn.linear_model import LinearRegressionlr = LinearRegression(normalize=True)# 支持向量机(SVM)from sklearn.svm import SVCsvc = SVC(kernel='linear')# 朴素贝叶斯from sklearn.naive_bayes import GaussianNBgnb = GaussianNB()# KNNfrom sklearn import neighborsknn = neighbors.KNeighborsClassifier(n_neighbors=5) 无监督学习123456# 主成分分析（PCA)from sklearn.cluster import KMeansfrom sklearn.decomposition import PCApca = PCA(n_components=0.95)# K Meansk_means = KMeans(n_clusters=3, random_state=0) 拟合数据监督学习123lr.fit(X, y)knn.fit(X_train, y_train)svc.fit(X_train, y_train) 无监督学习12k_means.fit(X_train)pca_model = pca.fit_transform(X_train) 预测监督学习123456# 预测标签y_pred = svc.predict(np.random.random((2,5)))# 预测标签y_pred = lr.predict(X_test)# 评估标签概率y_pred = knn.predict_proba(X_test) 无监督学习1y_pred = k_means.predict(X_test) 评估模型性能分类指标12345678910# 准确率knn.score(X_test, y_test)from sklearn.metrics import accuracy_scoreaccuracy_score(y_test, y_pred)# 分类预估评价函数from sklearn.metrics import classification_reportprint(classification_report(y_test, y_pred))# 混淆矩阵from sklearn.metrics import confusion_matrixprint(confusion_matrix(y_test, y_pred)) 回归指标12345678910# 平均绝对误差from sklearn.metrics import mean_absolute_errory_true = [3, -0.5, 2]mean_absolute_error(y_true, y_pred)# 均方误差from sklearn.metrics import mean_squared_errormean_squared_error(y_test, y_pred)# R2 评分from sklearn.metrics import r2_scorer2_score(y_true, y_pred) 群集指标123456789# 调整兰德系数from sklearn.metrics import adjusted_rand_scoreadjusted_rand_score(y_true, y_pred)# 同质性from sklearn.metrics import homogeneity_scorehomogeneity_score(y_true, y_pred)# V-measurefrom sklearn.metrics import v_measure_scoremetrics.v_measure_score(y_true, y_pred) 交叉验证123from sklearn.cross_validation import cross_val_scoreprint(cross_val_score(knn, X_train, y_train, cv=4))print(cross_val_score(lr, X, y, cv=2)) 模型调整网格搜索12345678from sklearn.grid search import GridSearchcVparams = &#123;"n neighbors": np.arange(1, 3)， "metric": ["euclidean", "cityblock"]&#125;grid = GridSearchCV(estimator=knn, param_grid-params)grid.fit(X_train, y_train)print(grid.best score)print(grid.best_estimator_.n_neighbors) 随机参数优化123456from sklearn.grid_search import RandomizedSearchCVparams = &#123;"n_neighbors": range(1, 5), "weights": ["uniform", "distance"]&#125;rsearch = RandomizedSearchCV(estimator=knn, rsearch.fit(X_train, y_train) random_state=5)print(rsearch.best_score_)]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学家必备神器：Spyder]]></title>
    <url>%2F2019%2F05%2F27%2FSpyder%2F</url>
    <content type="text"><![CDATA[Spyder 网站：https://www.spyder-ide.org/ 概观 Spyder 是一个用 Python 编写的强大科学环境，用于 Python，由科学家，工程师和数据分析师设计。它将综合开发工具的高级编辑，性能分析，调试和分析功能与数据探索，交互式执行，深度检查以及科学软件包的美观可视化功能相结合。 除了它的许多内置功能外，它的功能还可以通过其插件系统和 API 进一步扩展。此外，Spyder 还可以用作 PyQt5 扩展库，允许开发人员在其功能的基础上构建并将其组件（如交互式控制台）嵌入到他们自己的 PyQt 软件中。 视频介绍 组件强大 IDE 的核心构建块 编辑在多语言编辑器中高效工作，具有功能 / 类浏览器，代码分析工具，自动代码完成，水平 / 垂直分割和定义。 IPython 控制台在完整 GUI 界面的灵活性范围内，利用尽可能多的 IPython 控制台的强大功能; 按行，单元格或文件运行代码; 并以正确的方式渲染绘图。 变量浏览器动态交互并修改变量：绘制直方图或时间序列，编辑日期框架或 Numpy 数组，对集合进行排序，挖掘嵌套对象等等！ 性能分析找到并消除瓶颈以解除代码的性能。 调试器以交互方式跟踪代码执行的每一步。 帮助即时查看任何对象的文档，并呈现您自己的文档。 插件使用这些令人敬畏的第三方插件扩展 Spyder 的功能！ ### Spyder 笔记本 ### Spyder 终端 Spyder 单元测试 Spyder 报告 下载如何获得 Spyder 在任何支持的平台上使用 Spyder 启动和运行的简便方法是将其作为 Anaconda 发行版 的一部分下载，并使用 conda 软件包和环境管理器来保持它和您的其他软件包的安装和更新。我们建议使用最新的 64 位 Python 3 版本，除非您有特殊要求。 Anaconda 的安装请参考：2019 年最新最全的 Anaconda 安装指南]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib 基础]]></title>
    <url>%2F2019%2F05%2F26%2Fmatplotlib%2F</url>
    <content type="text"><![CDATA[Matplotlib 是一个 Python 绘图库，可以跨平台生成各种硬拷贝格式和交互式环境的出版品质数据。 绘图解剖（Plot Anatomy） 工作流程（Workflow）使用 matplotlib 创建绘图的基本步骤 12345678910111213141516171819import matplotlib.pyplot as plt# 1. 准备数据x = [1, 2, 3, 4]y = [10, 20, 25, 30]# 2. 创建绘图fig = plt.figure()# 3. 绘图ax = fig.add_subplot(111)# 4. 自定义绘图ax.plot(x, y, color='lightblue', linewidth=3)ax.scatter([2, 4, 6], [5, 15, 25], color='darkgreen', marker='^')ax.set_xlim(1, 6.5)# 5. 保存图plt.savefig('foo.png')# 6. 显示图plt.show() 准备数据1D数据1234import numpy as npx = np.linspace(0, 10, 100)y = np.cos(x)z = np.sin(x) 2D数据 或 图像12345678from matplotlib.cbook import get_sample_dataimport osdata = 2 * np.random.random((10, 10))data2 = 3 * np.random.random((10, 10))Y, X = np.mgrid[-3:3:100j, -3:3:100j]U = -1 - X**2 + YV = 1 + X - Y**2img = np.load(get_sample_data(os.getcwd() + '/axes_grid/bivariate_normal.npy')) 创建图123import matplotlib.pyplot as plt# 魔法函数（Magic Functions）功能是可以内嵌绘图，并且可以省略掉 plt.show()%matplotlib inline 图形（Figure）1fig = plt.figure() 1fig2 = plt.figure(figsize=plt.figaspect(2.0)) 轴（Axes）所有绘图都是针对 Axes 完成的。 在大多数情况下，子图符合您的需求。子图是网格系统上的轴。 1fig.add_axes() 1ax1 = fig.add_subplot(221) # 行-列-数字 1ax3 = fig.add_subplot(212) 1fig3, axes = plt.subplots(nrows=2, ncols=2) 1fig4, axes2 = plt.subplots(ncols=3) 常规绘制1D 数据1234567891011121314151617fig, ax = plt.subplots()# 用连接它们的线或标记绘制点lines = ax.plot(x, y)# 绘制未连接的点，缩放或着色ax.scatter(x, y)# 绘制垂直矩形（恒定宽度）axes[0, 0].bar([1, 2, 3], [3, 4, 5])# 绘制horiontal矩形（恒定高度）axes[1, 0].barh([0.5, 1, 2.5], [0, 1, 2])# 在轴上绘制一条水平线axes[1, 1].axhline(0.45)# 在轴上绘制一条垂直线axes[0, 1].axvline(0.65)# 绘制填充的多边形ax.fill(x, y, color='blue')# 在 y 值和 0 之间填充ax.fill_between(x, y, color='yellow') 2D数据 或 图像1234567fig, ax = plt.subplots()# 彩色贴图或 RGB 数组im = ax.imshow(img, cmap='gist_earth', interpolation='nearest', vmin=-2, vmax=2) 12345678910# 二维数组的伪彩色图axes2[0].pcolor(data2)# 二维数组的伪彩色图axes2[0].pcolormesh(data)# 绘制轮廓CS = plt.contour(Y, X, U)# 绘制填充轮廓axes2[2].contourf(data)# 标记等高线图axes2[2] = ax.clabel(CS) 向量字段123456# 向轴添加箭头axes[0, 1].arrow(0, 0, 0.5, 0.5)# 绘制箭头的 2D 字段axes[1, 1].quiver(y, z)# 绘制箭头的 2D 字段axes[0, 1].streamplot(X, Y, U, V) 数据分布123456# 绘制直方图ax1.hist(y)# 制作一个箱图ax3.boxplot(y)# 制作小提琴图ax3.violinplot(z) 自定义绘图颜色，彩条（Color bars）和彩图（Color maps）12345plt.plot(x, x, x, x**2, x, x**3)ax.plot(x, y, alpha=0.4)ax.plot(x, y, c='k')fig.colorbar(im, orientation='horizontal')im = ax.imshow(img, cmap='seismic') 标记123fig, ax = plt.subplots()ax.scatter(x, y, marker=".")ax.plot(x, y, marker="o") 线条样式1plt.plot(x, y, linewidth=4.0) 1plt.plot(x, y, ls='solid') 1plt.plot(x, y, ls='--') 1plt.plot(x, y, '--', x**2, y**2, '-.') 1plt.setp(lines, color='r', linewidth=4.0) 文字 &amp; 注释1234ax.text(1, -2.1, 'Example Graph', style='italic') 1234567ax.annotate("Sine", xy=(8, 0), xycoords='data', xytext=(10.5, 0), textcoords='data', arrowprops=dict(arrowstyle="-&gt;", connectionstyle="arc3"),) 数学1plt.title(r'$sigma_i=15$', fontsize=20) 限制，图例 &amp; 布局（Limits, Legends &amp; Layouts）限制 &amp; 自动缩放（Limits &amp; Autoscaling）1234ax.margins(x=0.0, y=0.1)ax.axis('equal')ax.set(xlim=[0, 10.5], ylim=[-1.5, 1.5])ax.set_xlim(0, 10.5) 图例1234# 设置标题和x轴和y轴标签ax.set(title='An Example Axes', ylabel='Y-Axis', xlabel='X-Axis') 12# 不重叠的图元素ax.legend(loc='best', labels='No overlapping plot elements') 刻度（Ticks）123# 手动设置 x-ticksax.xaxis.set(ticks=range(1,5), ticklabels=[3,100,-12,"foo"]) 1234# y-ticks 变长ax.tick_params(axis='y', direction='inout', length=10) 子图间距1234567# 调整子图之间的间距fig3.subplots_adjust(wspace=0.5, hspace=0.3, left=0.125, right=0.9, top=0.9, bottom=0.1) 12# 子图适配图区域fig.tight_layout() 坐标轴（Axis Spines）12# 向下移动底部轴线ax1.spines['top'].set_visible(False) 12# 使图的顶轴不可见ax1.spines['bottom'].set_position(('outward', 10)) 保存图保存图片（Save figures）1plt.savefig('bar.png') 保存透明图（Save transparent figures）1plt.savefig('bar_trans.png', transparent=True) 显示图1plt.show() 关闭 &amp; 清除123456# 清除轴plt.cla()# 清除整个图plt.clf()# 关闭一个窗口plt.close() 示例折线图（Line plot）123456import matplotlib.pyplot as pltimport numpy as npa = np.linspace(0, 10, 100)b = np.exp(-a)plt.plot(a, b)plt.show() 直方图（ Histogram）12345import matplotlib.pyplot as pltfrom numpy.random import normal,randx = normal(size=200)plt.hist(x, bins=30)plt.show() 散点图（Scatter plot）123456import matplotlib.pyplot as pltfrom numpy.random import randa = rand(100)b = rand(100)plt.scatter(a, b)plt.show() 3D 图（3D plot）12345678910111213from matplotlib import cmfrom mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltimport numpy as npfig = plt.figure()ax = fig.gca(projection='3d')X = np.arange(-5, 5, 0.25)Y = np.arange(-5, 5, 0.25)X, Y = np.meshgrid(X, Y)R = np.sqrt(X**2 + Y**2)Z = np.sin(R)surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm)plt.show() 在线预览https://github.com/iOSDevLog/AIDevLog/blob/master/Python%20%E5%9F%BA%E7%A1%80/MatplotlibBasic.ipynb]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas 基础]]></title>
    <url>%2F2019%2F05%2F25%2Fpandas%2F</url>
    <content type="text"><![CDATA[Pandas 简介 Pandas 库基于 NumPy 构建，为 Python 编程语言提供易于使用的数据结构和数据分析工具。 使用以下约定导入 Pandas 1import pandas as pd 帮助1help(pd.Series.loc) Pandas 数据结构序列（Series）能够保存任何数据类型的一维标记数组 1s = pd.Series([1, 3, 5, 7], index=['天', '地', '玄', '黄']) 12# 左侧一列为索引s 天 1地 3玄 5黄 7dtype: int64 数据框（DataFrame）不同类型列的二维标记数据结构，类似 Excel 表格 上面一行为列名 左侧一列为索引 - 姓 名 民族 姓别 年龄 1 贾 小武 汉 男 3 2 贾 小久 汉 男 1 3 张 小鸭 汉 女 - 1234data = &#123;'姓': ['贾', '贾', '张'], '名': ['小武', '小久', '小鸭́'], '民族': ['汉', '汉', '汉'], '年龄': [3, 1, None]&#125; 1data {‘姓’: [‘贾’, ‘贾’, ‘张’], ‘名’: [‘小武’, ‘小久’, ‘小鸭́’], ‘民族’: [‘汉’, ‘汉’, ‘汉’], ‘年龄’: [3, 1, None]} 1df = pd.DataFrame(data, columns=['姓', '名', '年龄']) 1df - 姓 名 民族 姓别 年龄 1 贾 小武 汉 男 3 2 贾 小久 汉 男 1 3 张 小鸭 汉 女 - 文件 I / O读写 CSV12pd.read_csv('file.csv', header=None, nrows=5)df.to_csv('myDataFrame.csv') 读写 Excel1234pd.read_excel('file.xlsx')pd.to_excel('dir/myDataFrame.xlsx', sheet_name='Sheet1')xlsx = pd.ExcelFile('file.xls')df = pd.read_excel(xlsx, 'Sheet1') 读取数据库12345from sqlalchemy import create_engineengine = create_engine('sqlite:///:memory:')pd.read_sql("SELECT * FROM my_table;", engine)pd.read_sql_table('my_table', engine)pd.read_sql_query("SELECT * FROM my_table;", engine) read_sql() 是 read_sql_table() 和 read_sql_query() 的便捷包装器 1pd.to_sql('myDf', engine) 选择获取12# 获取 1 个数据s['天'] 1 12# 获取 DataFrame 的子集df[1:] 选择，布尔索引 &amp; 设置位置按行和列选择单个值 1df.iloc[[0], [1]] 1df.iat[0, 1] ‘小武’ 标签按行和列标签选择单个值 1df.loc[0, '姓'] ‘贾’ 1df.at[0, '姓'] ‘贾’ 布尔索引1s[~(s &gt; 1)] 天 1dtype: int64 1s[(s &lt; -1) | (s &gt; 2)] 地 3玄 5黄 7dtype: int64 1df[df['年龄']&gt;1] 设置将序列 s 的索引 ‘宇’ 设置为 9 12s['宇'] = 9s 天 1地 3玄 5黄 7宇 9dtype: int64 删除（dropping）从行中删除值（axis = 0） 1s.drop(['天', '地']) 玄 5黄 7宇 9dtype: int64 从列中删除值（axis = 1） 1df.drop('姓', axis=1) 排序和排名按轴标签排序 1df.sort_index() 按轴的值排序 1df.sort_values(by='年龄') 从小到大排序的下标 1df.rank() 检索 Series / DataFrame 信息基本信息123df = pd.DataFrame([[1, 2], [4, 5], [7, 8]], index=['cobra', 'viper', 'sidewinder'], columns=['max_speed', 'shield']) （行，列） 1df.shape (3, 2) 描述索引 1df.index Index([‘cobra’, ‘viper’, ‘sidewinder’], dtype=’object’) 描述 DataFrame 列信息 1df.columns Index([‘max_speed’, ‘shield’], dtype=’object’) DataFrame 信息 1df.info() 非 NA 值的数量 1df.count() max_speed 3shield 3dtype: int64 摘要总和 1df.sum() max_speed 12shield 15dtype: int64 累积值 1df.cumsum() 最小值 1df.min() max_speed 1shield 2dtype: int64 最大值 1df.max() max_speed 7shield 8dtype: int64 最小索引值 1df.idxmin() max_speed cobrashield cobradtype: object 最大索引值 1df.idxmax() max_speed sidewindershield sidewinderdtype: object 摘要统计 123456df.describe()均值```pythondf.mean() max_speed 4.0shield 5.0dtype: float64 中位数 1df.median() max_speed 4.0shield 5.0dtype: float64 应用函数1f = lambda x: x*2 应用函数 1df.apply(f) 按元素应用函数 1df.applymap(f) 数据对齐内部数据对齐值 NA 在不重叠的索引中引入 1s3 = pd.Series([7, -2, 3], index=['玄', '黄', '宇']) 1s + s3 地 NaN天 NaN宇 12.0玄 12.0黄 5.0dtype: float64 填充方法的算术运算借助填充方法自行完成内部数据对齐 1s.add(s3, fill_value=0) 地 3.0天 1.0宇 12.0玄 12.0黄 5.0dtype: float64 1s.sub(s3, fill_value=2) 地 1.0天 -1.0宇 6.0玄 -2.0黄 9.0dtype: float64 1s.div(s3, fill_value=4) 地 0.750000天 0.250000宇 3.000000玄 0.714286黄 -3.500000dtype: float64 1s.mul(s3, fill_value=3) 地 9.0天 3.0宇 27.0玄 35.0黄 -14.0dtype: float64 ipynb 请查看：https://github.com/iOSDevLog/AIDevLog/blob/master/Python%20%E5%9F%BA%E7%A1%80/PandasBasic.ipynb]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy 基础]]></title>
    <url>%2F2019%2F05%2F24%2Fnumpy%2F</url>
    <content type="text"><![CDATA[Numpy 简介 Numpy 库是 Python 中科学计算的核心库。它提供了高性能的多维数组对象以及用于处理这些数组的工具。 使用以下约定导入 Numpy 1import numpy as np Numpy 数组 帮助1np.info(np.ndarray.dtype) 创建数组1234a = np.array([1,2,3])b = np.array([(1.5,2,3), (4,5,6)], dtype = float)c = np.array([[(1.5,2,3), (4,5,6)], [(3,2,1), (4,5,6)]],dtype = float) 初始占位符12# 创建一个零数组np.zeros((3,4)) array([[0., 0., 0., 0.],[0., 0., 0., 0.],[0., 0., 0., 0.]]) 12# 创建一个数组np.ones((2,3,4), dtype=np.int16) array([[[1, 1, 1, 1],[1, 1, 1, 1],[1, 1, 1, 1]], [[1, 1, 1, 1],[1, 1, 1, 1],[1, 1, 1, 1]]], dtype=int16) 12# 创建均匀间隔值的数组（步长值）d = np.arange(10,25,5) 12# 创建均匀间隔值的数组（样本数）np.linspace(0,2,9) array([0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) 12# 创建常量数组e = np.full((2,2),7) 12# 创建2X2单位矩阵f = np.eye(2) 12# 创建具有随机值的数组np.random.random((2,2)) array([[0.64234353, 0.07179718],[0.7937333 , 0.13764298]]) 12# 创建一个空数组np.empty((3,2)) array([[0., 0.],[0., 0.],[0., 0.]]) 文件 I / O在磁盘上保存 &amp; 加载123np.save('my_array', a)np.savez('array.npz', a, b)np.load('my_array.npy') array([1, 2, 3]) 保存 &amp; 加载文本文件123np.loadtxt("myfile.txt")np.genfromtxt("my_file.csv", delimiter=',')np.savetxt("myarray.txt", a, delimiter=" ") 数据类型12# 有符号的64位整数类型np.int64 numpy.int64 12# 标准双精度浮点复数np.float32 numpy.float32 12# 由128浮点数表示的布尔类型np.complex complex 12# 存储TRUE和FALSEnp.bool bool 12# 值Python对象类型np.object object 12# 固定长度的字符串类型np.string_ numpy.bytes_ 12# 固定长度的unicode类型np.unicode_ numpy.str_ 检查数组12# 数组尺寸a.shape (3,) 12# 数组长度len(a) 3 12# 数组维数b.ndim 2 12# 数组元素的数量e.size 4 12# 数组元素的数据类型b.dtype dtype(‘float64’) 12# 数据类型的名称b.dtype.name ‘float64’ 12# 将数组转换为其他类型b.astype(int) array([[1, 2, 3],[4, 5, 6]]) 数学运算算术运算123# 减法g = a - bg array([[-0.5, 0. , 0. ],[-3. , -3. , -3. ]]) 12# 减法np.subtract(a,b) array([[-0.5, 0. , 0. ],[-3. , -3. , -3. ]]) 12# 加法b + a array([[2.5, 4. , 6. ],[5. , 7. , 9. ]]) 12# 加法np.add(b,a) array([[2.5, 4. , 6. ],[5. , 7. , 9. ]]) 12# 乘法a * b array([[ 1.5, 4. , 9. ],[ 4. , 10. , 18. ]]) 12# 除法a / b array([[0.66666667, 1. , 1. ],[0.25 , 0.4 , 0.5 ]]) 12# 幂np.multiply(a,b) array([[ 1.5, 4. , 9. ],[ 4. , 10. , 18. ]]) 12# 平方根np.sqrt(b) array([[1.22474487, 1.41421356, 1.73205081],[2. , 2.23606798, 2.44948974]]) 12# 正弦np.sin(a) array([0.84147098, 0.90929743, 0.14112001]) 12# 余弦np.cos(b) array([[ 0.0707372 , -0.41614684, -0.9899925 ],[-0.65364362, 0.28366219, 0.96017029]]) 12# 自然对数np.log(a) array([0. , 0.69314718, 1.09861229]) 12# 点积e.dot(f) array([[7., 7.],[7., 7.]]) 比较12# 元素比较a == b array([[False, True, True],[False, False, False]]) 12# 元素比较a &lt; 2 array([ True, False, False]) 12# 数组比较np.array_equal(a, b) False 聚合函数12# 数组式和a.sum() 6 12# 数组最小值a.min() 1 12# 数组行的最大值b.max(axis=0) array([4., 5., 6.]) 12# 元素的累积总和b.cumsum(axis=1) array([[ 1.5, 3.5, 6.5],[ 4. , 9. , 15. ]]) 12# 均值a.mean() 2.0 12# 中位数np.median(b) 3.5 12# 相关系数np.corrcoef(a, b) array([[1. , 0.98198051, 1. ],[0.98198051, 1. , 0.98198051],[1. , 0.98198051, 1. ]]) 12# 标准差np.std(b) 1.5920810978785667 复制数组123# 使用相同的数据创建数组视图h = a.view()h array([1, 2, 3]) 12# 创建数组的副本np.copy(a) array([1, 2, 3]) 123# 创建数组的深层副本h = a.copy()h array([1, 2, 3]) 排序数组123# 对数组进行排序a.sort()a array([1, 2, 3]) 123# 对数组轴的元素进行排序c.sort(axis=0)c array([[[1.5, 2. , 1. ],[4. , 5. , 6. ]],[[3. , 2. , 3. ],[4. , 5. , 6. ]]]) 切片与索引下标1a[2] 3 1b[1,2] 6.0 切片1a[:2] array([1, 2]) 1b[0:2,1] array([2., 5.]) 1b[:1] array([[1.5, 2. , 3. ]]) 1c[1, ...] array([[3., 2., 3.],[4., 5., 6.]]) 1a[ : :-1] array([3, 2, 1]) 布尔索引1a[a&lt;2] array([1]) 12# 花式索引b[[1, 0, 1, 0],[0, 1, 2, 0]] array([4. , 2. , 6. , 1.5]) 1b[[1, 0, 1, 0]][:,[0,1,2,0]] array([[4. , 5. , 6. , 4. ],[1.5, 2. , 3. , 1.5],[4. , 5. , 6. , 4. ],[1.5, 2. , 3. , 1.5]]) 数组操作转置数组12# 重新排列数组维度i = np.transpose(b) 12# 重新排列数组维度i.T array([[1.5, 2. , 3. ],[4. , 5. , 6. ]]) 改变形状12# 展平数组b.ravel() array([1.5, 2. , 3. , 4. , 5. , 6. ]) 1g.reshape(3, -2) array([[-0.5, 0. ],[ 0. , -3. ],[-3. , -3. ]]) 添加 / 删除元素123# 返回一个形状为新的数组（2,6）h = np.array([1, 2, 3])h.resize((2, 6)) 12# 将元素附加到数组np.append(h, g) array([ 1. , 2. , 3. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , , -0.5, 0. , 0. , -3. , -3. , -3. ]) 12# 在数组中插入元素np.insert(a, 1, 5) array([1, 5, 2, 3]) 12# 从数组中删除元素np.delete(a,[1]) array([1, 3]) 结合数组12# 连接数组np.concatenate((a,d),axis=0) array([ 1, 2, 3, 10, 15, 20]) 12# 垂直堆叠数组（逐行）np.vstack((a,b)) array([[1. , 2. , 3. ],[1.5, 2. , 3. ],[4. , 5. , 6. ]]) 12# 垂直堆叠数组（逐行）np.r_[e,f] array([[7., 7.],[7., 7.],[1., 0.],[0., 1.]]) 12# 水平堆叠阵列（逐列）np.hstack((e,f)) array([[7., 7., 1., 0.],[7., 7., 0., 1.]]) 12# 创建堆叠的列式数组np.column_stack((a,d)) array([[ 1, 10],[ 2, 15],[ 3, 20]]) 12# 创建堆叠的列式数组np.c_[a,d] array([[ 1, 10],[ 2, 15],[ 3, 20]]) 分割数组12# 在第3个索引处水平拆分数组np.hsplit(a,3) [array([1]), array([2]), array([3])] 12hh.resize(2, 6) 12# 在第 2 个索引处垂直拆分数组np.vsplit(c,2) [array([[[1.5, 2. , 1. ],[4. , 5. , 6. ]]]), array([[[3., 2., 3.],[4., 5., 6.]]])]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 基础]]></title>
    <url>%2F2019%2F05%2F23%2Fpython-basic%2F</url>
    <content type="text"><![CDATA[安装 Python https://www.anaconda.com/ 由 Python 提供支持的领先开放数据科学平台 https://www.spyder-ide.org/ Anaconda 附带的免费 IDE https://jupyter.org/ 使用实时代码，可视化，文本创建和共享文档…… 1. 变量和类型变量赋值12x = 5x 5 运算1x + 9 # 加 14 1x - 9 # 减 -4 1x * 9 # 乘 45 1x ** 9 # 乘方 1953125 1x % 9 # 取模 5 1x / float(9) # 除 0.5555555555555556 类型与类型转换 类型转换 示例 类型 str() ‘59’, ‘3.14’, ‘True’ 字符串 int() 5, 9 整型 float() 5.9, 3.14 浮点数 bool() True, True, True 布尔 2. 字符串（String）帮助1help(str) 12zh_string = "最好的人工智能开发"zh_string ‘最好的人工智能开发’ 字符串操作1zh_string * 2 ‘最好的人工智能开发最好的人工智能开发’ 1zh_string + '就在这里了' ‘最好的人工智能开发就在这里了’ 1'我' in zh_string False 字符串方法12345zh_string.upper()zh_string.lower()zh_string.count('在')zh_string.replace('在', ' is ')zh_string.strip() ‘最好的人工智能开发’ 3. 列表（List）1234a = '是'b = '这'zh_list = ['我', '列表', a, b]zh_list2 = [[1, 3, 5, 7], [2, 4, 6, 8]] 元素选择123# 下标zh_list[1] # 索引从 0 开始，这里取第 2 个元素zh_list[-1] # 最后一个元素 ‘这’ 12345# 分片zh_list[1:3] # 索引 1, 2zh_list[1:] # 索引 1 及之后zh_list[:3] # 索引 3 之前zh_list[:] # 所有 / 复制列表 [‘我’, ‘列表’, ‘是’, ‘这’] 123# 子列表zh_list + zh_listzh_list * 2 [‘我’, ‘列表’, ‘是’, ‘这’, ‘我’, ‘列表’, ‘是’, ‘这’] 123456789101112# 列表方法zh_list = [1, 3, 5, 7]zh_list.index(3) # 获取元素下标zh_list.count(3) # 统计元素个数zh_list.append(0) # 追加元素zh_list.remove(0) # 移除元素del(zh_list[:2]) # 删除前 2 个元素zh_list.reverse() # 反转列表zh_list.extend([2, 4, 6]) # 扩展列表zh_list.pop(-1) # 弹出（移除并返回）指定 index 元素zh_list.insert(3, 9) # 在 index 位置新增元素zh_list.sort() # 排序列表 4. 库 导入库12import numpyimport numpy as np 选择性导入1from sklearn import datasets 5. Numpy 数组123zh_list = [1, 3, 5, 7]zh_array = np.array(zh_list)zh_2darray = np.array([[1, 3, 5, 7], [2, 4, 6, 8]]) Numpy 数组元素选择12# 下标zh_list[0] # 索引从 0 开始 1 12# 切片zh_list[:2] [1, 3] 12# 2 维数组下标zh_2darray[:, 1] array([3, 4]) Numpy 数组操作1zh_array &gt; 3 array([False, False, True, True]) 1zh_array * 2 array([ 2, 6, 10, 14]) 1zh_array + np.array([9, 8, 7, 6]) array([10, 11, 12, 13]) Numpy 数组函数123456789other_array = np.array([5, 5, 5, 5])zh_array.shape # 维数np.append(zh_array, other_array) # 追加数组np.insert(zh_array, 1, 5) # 插入元素np.delete(zh_array, [1]) # 删除元素np.mean(zh_array) # 均值np.median(zh_array) # 中位数np.corrcoef(zh_array) # 相关系数np.std(zh_array) # 标准差 2.23606797749979]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 零基础入门]]></title>
    <url>%2F2019%2F05%2F22%2Fpython-zero%2F</url>
    <content type="text"><![CDATA[Photo by Chris Ried on Unsplash Python 是一种易于学习又功能强大的编程语言。它提供了高效的高级数据结构，还有简单有效的面向对象编程。Python 优雅的语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的理想语言。 Python 解释器及丰富的标准库以源码或机器码的形式提供，可以到 Python 官网 https://www.python.org/ 免费获取适用于各个主要系统平台的版本，并可自由地分发。这个网站还包含许多免费第三方 Python 模块、程序和工具以及附加文档的发布页面或链接。 Python 解释器易于扩展，可以使用 C 或 C++（或者其他可以通过 C 调用的语言）扩展新的功能和数据类型。Python 也可用于可定制化软件中的扩展程序语言。 如果你经常在电脑上工作，总会有些任务会想让它自动化。比如，对一大堆文本文件进行查找替换，对很多照片文件按照比较复杂的规则重命名并放入不同的文件夹。也可能你想写一个小型的数据库应用，一个特定的界面应用，或者一个简单的游戏。 如果你是专业的软件开发人员，你可能需要编写一些 C/C++/Java 库，但总觉得通常的开发的流程（编写、编译、测试、再次编译等）太慢了。可能给这样的库写一组测试，就是很麻烦的工作了。或许你写了个软件，可以支持插件扩展语言，但你不想为了自己这一个应用，专门设计和实现一种新语言了。 那么，Python 正好能满足你的需要。 对于这些任务，你也可以写 Unix 脚本或者 Windows 批处理完成，但是 shell 脚本最擅长移动文件和替换文本，并不适合 GUI 界面或者游戏开发。你可以写一个 C/C++/Java 程序，但是可能第一版本的草稿都要很长的开发时间。Python 的使用则更加简单，可以在 Windows，Mac OS X，以及 Unix 操作系统上使用，而且可以帮你更快地完成工作。 Python 很容易使用，但它是一种真正的编程语言，提供了很多数据结构，也支持大型程序，远超 shell 脚本或批处理文件的功能。Python 还提供比 C 语言更多的错误检查，而且作为一种 “超高级语言”，它有高级的内置数据类型，比如灵活的数组和字典。正因为这些更加通用的数据类型，Python 能够应付更多的问题，超过 Awk 甚至 Perl，而且很多东西在 Python 中至少和那些语言同样简单。 Python 允许你划分程序模块，在其他的 Python 程序中重用。它内置了很多的标准模块，你可以在此基础上开发程序——也可以作为例子，开始学习 Python 编程。例如，文件输入输出，系统调用，套接字，甚至图形界面接口工作包比如 Tk 。 Python 是一种解释型语言，在程序开发阶段可以为你节省大量时间，因为不需要编译和链接。解释器可以交互式使用，这样就可以方便地尝试语言特性，写一些一次性的程序，或者在自底向上的程序开发中测试功能。它也是一个顺手的桌面计算器。 Python 程序的书写是紧凑而易读的。Python 代码通常比同样功能的 C，C++，Java 代码要短很多，原因列举如下： 高级数据类型允许在一个表达式中表示复杂的操作； 代码块的划分是按照缩进而不是成对的花括号； 不需要预先定义变量或参数。 Python 是 “可扩展的”：如果你知道怎么写 C 语言程序，就能很容易地给解释器添加新的内置函数或模块，不论是让关键的程序以最高速度运行，还是把 Python 程序链接到只提供预编译程序的库（比如硬件相关的图形库）。一旦你真正链接上了，就能在 Python 解释器中扩展或者控制 C 语言编写的应用了。 顺便提一下，这种语言的名字（Python 意为 “蟒蛇”）来自于 BBC 节目 “Monty Python 的飞行马戏团”，而与爬行动物没有关系。在文档中用 Monty Python 来开玩笑不只是可以的，还是推荐的！ 现在你已经对 Python 跃跃欲试了，想要深入了解一些细节了。因为学习语言的最佳方式是使用它，本教程邀请你一边阅读，一边在 Python 解释器中玩耍。 使用 Python 解释器调用解释器在 Python 可用的机器上，Python 解释器通常放在 /usr/local/bin/python3.7 ; 把 /usr/local/bin 放到你 Unix shell 的搜索路径当中 , 这样就能键入命令: 1python3.7 就能运行了。 安装时可以选择安装目录，所以解释器也可能在别的地方；可以问问你身边的 Python 大牛，或者你的系统管理员。（比如 /usr/local/python 也是比较常用的备选路径） 在 Windows 机器上， Python 安装通常放在 C:\Python37 中，尽管你可以在运行安装程序时更改此设置。要将此目录添加到路径中，可以将以下命令键入 命令提示符窗口: 1set path=%path%;C:\python37 在主提示符中输入文件结束字符（在 Unix 系统中是 Control-D，Windows 系统中是 Control-Z）就退出解释器并返回退出状态为 0。如果这样不管用，你还可以写这个命令退出：quit()。 解释器的行编辑功能也包括交互式编辑，在支持 readline 的系统中，可以回看历史命令，也有 Tab 代码补全功能。要想快速检查是否支持行编辑，在出现提示符后，按键盘 Control-P。如果它 “哔” 了一声，它就是支持行编辑的；关于按键的详细介绍请看附录 交互式编辑和编辑历史。如果什么都没发生，或者显示出 ^P，那么就不支持行编辑功能；你只能用退格（Backspace）键从当前行中删除字符。 解释器运行的时候有点像 Unix 命令行：在一个标准输入 tty 设备上调用，它能交互式地读取和执行命令；调用时提供文件名参数，或者有个文件重定向到标准输入的话，它就会读取和执行文件中的 脚本。 另一种启动解释器的方式是 python -c command [arg] ...，其中 command 要换成想执行的指令，就像命令行的 -c 选项。由于 Python 代码中经常会包含对终端来说比较特殊的字符，通常情况下都建议用英文单引号把 command 括起来。 有些 Python 模块也可以作为脚本使用。可以这样输入：python -m module [arg] ...，这会执行 module 的源文件，就跟你在命令行把路径写全了一样。 在运行脚本的时候，有时可能也会需要在运行后进入交互模式。这种时候在文件参数前，加上选项 -i 就可以了。 关于所有的命令行选项，请参考 命令行与环境。 交互模式在终端（tty）输入并执行指令时，我们说解释器是运行在 交互模式（interactive mode）。在这种模式中，它会显示 主提示符（primary prompt），提示输入下一条指令，通常用三个大于号（&gt;&gt;&gt;）表示；连续输入行的时候，它会显示 次要提示符，默认是三个点（...）。进入解释器时，它会先显示欢迎信息、版本信息、版权声明，然后就会出现提示符： 12345$ python3.7Python 3.7 (default, Sep 16 2015, 09:25:04)[GCC 4.8.2] on linuxType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 多行指令需要在连续的多行中输入。比如，以 if 为例： 12345&gt;&gt;&gt; the_world_is_flat = True&gt;&gt;&gt; if the_world_is_flat:... print("Be careful not to fall off!")...Be careful not to fall off! 有关交互模式的更多内容，请参考 交互模式。 解释器的运行环境 源文件的字符编码默认情况下，Python 源码文件以 UTF-8 编码方式处理。在这种编码方式中，世界上大多数语言的字符都可以同时用于字符串字面值、变量或函数名称以及注释中——尽管标准库中只用常规的 ASCII 字符作为变量或函数名，而且任何可移植的代码都应该遵守此约定。要正确显示这些字符，你的编辑器必须能识别 UTF-8 编码，而且必须使用能支持打开的文件中所有字符的字体。 如果不使用默认编码，要声明文件所使用的编码，文件的 第一 行要写成特殊的注释。语法如下所示： 1# -*- coding: encoding -*- 其中 encoding 可以是 Python 支持的任意一种 codecs。 比如，要声明使用 utf-8 编码，你的源码文件要写成： 1# -*- coding: utf-8 -*- 关于 第一行 规则的一种例外情况是，源码以 UNIX “shebang” 行 开头。这种情况下，编码声明就要写在文件的第二行。例如： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 内置类型 逻辑值检测 布尔运算 —- and, or, not 比较 数字类型 —- int, float, complex 迭代器类型 序列类型 —- list, tuple, range 文本序列类型 —- str 二进制序列类型 —- bytes, bytearray, memoryview 集合类型 —- set, frozenset 映射类型 —- dict 上下文管理器类型 其他内置类型 特殊属性 基本数据类型Python 中的变量不需要提前声明。变量赋值后会自动创建。 不可变 数字（Number） 字符串（String） 元组（Tuple） 可变 列表（List） 字典（Dictionary） 列表（Set） 数字 整数（比如 2、4、20 ） int 类型 有小数部分的（比如 5.0、1.6 ） float 类型 等号 (=) 用于给一个变量赋值 1234&gt;&gt;&gt; width = 20&gt;&gt;&gt; height = 5 * 9&gt;&gt;&gt; width * height900 字符串 单引号（&#39;……&#39;） 双引号（&quot;……&quot;） 反斜杠 \ 可以用来转义 字符串前面加 r 禁止反斜杠 \ 转义 索引从 0 开始，-1 为结尾位置 + 连接字符串 123456789101112&gt;&gt;&gt; 'spam eggs' # single quotes'spam eggs'&gt;&gt;&gt; 'doesn\'t' # use \' to escape the single quote..."doesn't"&gt;&gt;&gt; "doesn't" # ...or use double quotes instead"doesn't"&gt;&gt;&gt; '"Yes," they said.''"Yes," they said.'&gt;&gt;&gt; "\"Yes,\" they said."'"Yes," they said.'&gt;&gt;&gt; '"Isn\'t," they said.''"Isn\'t," they said.' 除了索引，字符串还支持 切片。索引可以得到单个字符，而 切片 可以获取子字符串: 1234&gt;&gt;&gt; word[0:2] # characters from position 0 (included) to 2 (excluded)'Py'&gt;&gt;&gt; word[2:5] # characters from position 2 (included) to 5 (excluded)'tho' 注意切片的开始总是被包括在结果中，而结束不被包括。这使得 s[:i] + s[i:] 总是等于 s 列表Python 中可以通过组合一些值得到多种 复合 数据类型，其中最常用的 列表。 通过方括号括起、逗号分隔的一组值 一个 列表 可以包含不同类型的元素，但通常使用时各个元素类型相同 和字符串一样，列表也支持索引和切片 123&gt;&gt;&gt; squares = [1, 4, 9, 16, 25]&gt;&gt;&gt; squares[1, 4, 9, 16, 25] 元组 元组是不可变序列，通常用于储存异构数据的多项集（例如由 enumerate() 内置函数所产生的二元组） 元组也被用于需要同构数据的不可变序列的情况（例如允许存储到 set 或 dict 的实例）。 Python的元组与列表类似，不同之处在于元组的元素不能修改。 元组使用小括号，列表使用方括号。 元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 123456789&gt;&gt;&gt; brother = ('小武', '小久', 2015, 2019)&gt;&gt;&gt; numbers = (1, 2, 3, 4, 5 )&gt;&gt;&gt; alpha = "a", "b", "c", "d"&gt;&gt;&gt; brother('小武', '小久', 2015, 2019)&gt;&gt;&gt; numbers(1, 2, 3, 4, 5)&gt;&gt;&gt; alpha('a', 'b', 'c', 'd') 字典mapping 对象会将 hashable 值映射到任意对象。 映射属于可变对象。 目前仅有一种标准映射类型 字典。 字典的键 几乎 可以是任何值。 非 hashable 的值，即包含列表、字典或其他可变类型的值（此类对象基于值而非对象标识进行比较）不可用作键。 数字类型用作键时遵循数字比较的一般规则：如果两个数值相等 (例如 1 和 1.0) 则两者可以被用来索引同一字典条目。 （但是请注意，由于计算机对于浮点数存储的只是近似值，因此将其用作字典键是不明智的。） 1234567&gt;&gt;&gt; a = dict(one=1, two=2, three=3)&gt;&gt;&gt; b = &#123;'one': 1, 'two': 2, 'three': 3&#125;&gt;&gt;&gt; c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))&gt;&gt;&gt; d = dict([('two', 2), ('one', 1), ('three', 3)])&gt;&gt;&gt; e = dict(&#123;'three': 3, 'one': 1, 'two': 2&#125;)&gt;&gt;&gt; a == b == c == d == eTrue 集合set 对象是由具有唯一性的 hashable 对象所组成的无序多项集。 常见的用途包括成员检测、从序列中去除重复项以及数学中的集合类计算。 交集 并集 差集 对称差集 无序的多项集 支持 x in set, len(set) 和 for x in set 集合并不记录元素位置或插入顺序 不支持索引、切片或其他序列类的操作 1234567&gt;&gt;&gt; basket = &#123;'apple', 'orange', 'apple', 'grape', 'orange', 'banana'&#125;&gt;&gt;&gt; print(basket)&#123;'orange', 'banana', 'grape', 'apple'&#125;&gt;&gt;&gt; 'orange' in basketTrue&gt;&gt;&gt; 'strawberry' in basketFalse 流程控制if 语句用于有条件的执行: 12345678910111213&gt;&gt;&gt; x = int(input("Please enter an integer:"))Please enter an integer: 42&gt;&gt;&gt; if x &lt; 0:... x = 0... print('Negative changed to zero')... elif x == 0:... print('Zero')... elif x == 1:... print('Single')... else:... print('More')...More 可以有零个或多个 elif 部分，以及一个可选的 else 部分。 关键字 ‘elif‘ 是’else if’ 的缩写，适合用于避免过多的缩进。 一个 if … elif … elif … 序列可以看作是其他语言中的 switch 或 case 语句的替代。 for 语句用于对序列（例如字符串、元组或列表）或其他可迭代对象中的元素进行迭代: 12345678&gt;&gt;&gt; # Measure some strings:... words = ['cat', 'window', 'defenestrate']&gt;&gt;&gt; for w in words:... print(w, len(w))...cat 3window 6defenestrate 12 while 语句用于在表达式保持为真的情况下重复地执行: 12345678910&gt;&gt;&gt; monkeys = 5&gt;&gt;&gt; while monkeys &gt; 0:... print("&#123;&#125; 只猴子当荡秋千，嘲笑鳄鱼被水淹。鳄鱼来了，鳄鱼来了，啊呜!".format(monkeys))... monkeys -= 1...5 只猴子当荡秋千，嘲笑鳄鱼被水淹。鳄鱼来了，鳄鱼来了，啊呜!4 只猴子当荡秋千，嘲笑鳄鱼被水淹。鳄鱼来了，鳄鱼来了，啊呜!3 只猴子当荡秋千，嘲笑鳄鱼被水淹。鳄鱼来了，鳄鱼来了，啊呜!2 只猴子当荡秋千，嘲笑鳄鱼被水淹。鳄鱼来了，鳄鱼来了，啊呜!1 只猴子当荡秋千，嘲笑鳄鱼被水淹。鳄鱼来了，鳄鱼来了，啊呜! break 和 continue 语句 break 语句，和 C 中的类似，用于跳出最近的 for 或 while 循环. 循环语句可能带有一个 else 子句；它会在循环遍历完列表 (使用 for) 或是在条件变为假 (使用 while) 的时候被执行，但是不会在循环被 break 语句终止时被执行。 1234567891011121314151617&gt;&gt;&gt; for n in range(2, 10):... for x in range(2, n):... if n % x == 0:... print(n, 'equals', x, '*', n//x)... break... else:... # loop fell through without finding a factor... print(n, 'is a prime number')...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3 pass 语句pass 语句什么也不做。当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它。例如: 123&gt;&gt;&gt; while True:... pass # Busy-wait for keyboard interrupt (Ctrl+C)... 这通常用于创建最小的类: 123&gt;&gt;&gt; class MyEmptyClass:... pass... pass 的另一个可以使用的场合是在你编写新的代码时作为一个函数或条件子句体的占位符，允许你保持在更抽象的层次上进行思考。 pass 会被静默地忽略: 123&gt;&gt;&gt; def initlog(*args):... pass # Remember to implement this!... 函数我们可以创建一个输出任意范围内 Fibonacci 数列的函数: 1234567891011&gt;&gt;&gt; def fib(n): # write Fibonacci series up to n... """Print a Fibonacci series up to n."""... a, b = 0, 1... while a &lt; n:... print(a, end=' ')... a, b = b, a+b... print()...&gt;&gt;&gt; # Now call the function we just defined:... fib(2000)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 关键字 def 引入一个函数 定义 它必须后跟函数名称和带括号的形式参数列表 构成函数体的语句从下一行开始，并且必须缩进。 函数体的第一个语句可以（可选的）是字符串文字；这个字符串文字是函数的文档字符串或 docstring 有些工具使用文档字符串自动生成在线或印刷文档，或者让用户以交互式的形式浏览代码 在你编写的代码中包含文档字符串是一种很好的做法，所以要养成习惯。 编码风格现在你将要写更长，更复杂的 Python 代码，是时候讨论一下 代码风格。大多数语言都能使用不同的风格编写（或更简洁，格式化的）；有些比其他的更具有可读性。能让其他人轻松阅读你的代码总是一个好主意，采用一种好的编码风格对此有很大帮助。 对于 Python，PEP 8 已经成为大多数项目所遵循的风格指南；它促进了一种非常易读且令人赏心悦目的编码风格。每个 Python 开发人员都应该在某个时候阅读它；以下是为你提取的最重要的几个要点： 使用 4 个空格缩进，不要使用制表符。 4 个空格是一个在小缩进（允许更大的嵌套深度）和大缩进（更容易阅读）的一种很好的折中方案。制表符会引入混乱，最好不要使用它。 换行，使一行不超过 79 个字符。 这有助于使用小型显示器的用户，并且可以在较大的显示器上并排放置多个代码文件。 使用空行分隔函数和类，以及函数内的较大的代码块。 如果可能，把注释放到单独的一行。 使用文档字符串。 在运算符前后和逗号后使用空格，但不能直接在括号内使用： a = f(1, 2) + g(3, 4)。 类和函数命名的一致性；规范是使用 CamelCase 命名类，lower_case_with_underscores 命名函数和方法。始终使用 self 作为第一个方法参数的名称（有关类和方法，请参阅 初探类 ）。 如果你的代码旨在用于国际环境，请不要使用花哨的编码。Python 默认的 UTF-8 或者纯 ASCII 在任何情况下都能有最好的表现。 同样，哪怕只有很小的可能，遇到说不同语言的人阅读或维护代码，也不要在标识符中使用非 ASCII 字符。 Python 之弹12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those! 优美优于丑陋， 明了优于隐晦； 简单优于复杂， 复杂优于凌乱， 扁平优于嵌套， 可读性很重要！ 即使实用比纯粹更优， 特例亦不可违背原则。 错误绝不能悄悄忽略， 除非它明确需要如此。 面对不确定性， 拒绝妄加猜测。 任何问题应有一种， 且最好只有一种， 显而易见的解决方法。 尽管这方法一开始并非如此直观， 除非你是荷兰人。 做优于不做， 然而不假思索还不如不做。 很难解释的，必然是坏方法。 很好解释的，可能是好方法。 命名空间是个绝妙的主意， 我们应好好利用它。 参考：https://docs.python.org/zh-cn/3/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI开发日志 代码资源等]]></title>
    <url>%2F2019%2F05%2F20%2Faidevlog%2F</url>
    <content type="text"><![CDATA[计划 预备知识 Python 基础 数学基础 机器学习 统计学习方法 统计学习（西瓜书） 机器学习实战 深度学习 深度学习（花书） Tensorflow PyTorch CS231n: 计算机视觉 CS224n: 自然语言处理 强化学习 简易 AlphaGo 竞赛 Kaggle 进度https://github.com/iOSDevLog/AIDevLog/projects?query=is%3Aopen+sort%3Aname-asc 联系方式GitHub: https://github.com/iOSDevLog/AIDevLog 网站: http://2019.iosdevlog.com/ Email: iosdevlog[at]iosdevlog.com Twitter: iOSDevLog 微博: iOSDevLog 微信公众号: AI开发日志 LicenseAIDevLog is released under the MIT license. See LICENSE for details.]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云端深度学习]]></title>
    <url>%2F2019%2F05%2F19%2Fcloud%2F</url>
    <content type="text"><![CDATA[有没有觉得一台笔记本电脑不够强大，无法运行你的模型？忘记它吧，来使用 云 GPU 来更快更、更便宜地训练你的模型！ 你还可以了解在哪里可以 部署 你为数百万人服务的模型 查看 免费积分 和 优惠 部分获得一些免费的 gpu 小时 最后更新时间：2019 年 4 月 20 日 # 云供应商 网站 价格 免费试用 / 免费积分 1 Google Colaboratory❤️ https://colab.research.google.com 免费 永久免费* 2 Kaggle Kernels https://www.kaggle.com 免费 永久免费* 3 Tensorpad https://www.tensorpad.com 1080ti at $0.49/hour 5 free GPU hours 4 FloydHub https://www.floydhub.com https://www.floydhub.com/pricing free 2 GPU powerups in 14 days trial plan 5 Onepanel https://www.onepanel.io https://www.onepanel.io/pricing - 6 Nimblebox https://nimblebox.ai https://nimblebox.ai/plans free $5 worth of cloud credits 7 paperspace https://www.paperspace.com https://www.paperspace.com/pricing $10 credits 8 Overture https://www.overture.ai - free credits on signup 9 Dataiku https://www.dataiku.com - Free Plans 10 Cloudalize https://www.cloudalize.com https://www.cloudalize.com/pricing/ - 11 Deepcognition https://deepcognition.ai https://deepcognition.ai/products Desktop version free to use 12 GPUeater https://gpueater.com https://gpueater.com/#pricing - 13 Vast.ai https://vast.ai https://vast.ai/console/create/ - 14 Clusterone https://clusterone.com https://clusterone.com/pricing $25 Sign up credit 15 Snark https://snark.ai https://scale.snark.ai/pricing - 16 Crestle https://crestle.ai https://crestle.ai/#pricing 1 hour of free GPU usage on sign up fast.ai 17 Vector Dash(gaming) https://vectordash.com - free 7 day plan 18 Spell https://spell.run/developers https://spell.run/pricing $10 GPU credit on signup 19 Rapid Switch https://www.rapidswitch.com pricing - 20 Salamander https://salamander.ai https://salamander.ai - 21 Leadergpu https://www.leadergpu.com https://www.leadergpu.com - 22 vscaler https://www.vscaler.com on request - 23 AWS Sagemaker https://aws.amazon.com/sagemaker/ pricing Free plans 24 Exoscale https://www.exoscale.com/gpu/ pricing - 25 Cirrascale http://www.cirrascale.com Work station - 26 Alibaba cloud https://alibabacloud.com pay as you go $300 credits 27 IBM Cloud https://www.ibm.com/cloud/gpu pay as you go $200 credits 28 Google Cloud Platform https://cloud.google.com/gpu/ https://cloud.google.com/pricing/ $300 credits 29 Valohai https://valohai.com https://valohai.com/pricing/ free trial avaliable 30 Nvidia cloud https://www.nvidia.com/en-us/data-center/gpu-cloud-computing/ - - 31 One stop System https://www.onestopsystems.com - - 32 Azure https://azure.microsoft.com/en-in/services/machine-learning-studio/ pricing $200 credits 33 Omnisci https://www.omnisci.com https://www.omnisci.com/cloud 14 day free trial 34 Rendsolve https://rendsolve.com https://rendsolve.com/pricing - 35 Golem https://golem.network - - 将模型部署为 Web 应用有一个想法, 并希望服务于世界 🌎, 创建一个 Webapp, 并将其部署为 flask , Django 等 # 供应商 网站 价格 免费试用 / 免费积分 1 Render https://render.com https://render.com/pricing - 2 Heroku https://www.heroku.com https://www.heroku.com/pricing Free plan (model&lt;500MB) 3 Digtal Ocean https://www.digitalocean.com pay as you go free $100 credits with github student pack 4 Glitch https://glitch.com - - 5 Zeit https://zeit.co https://zeit.co/pricing Free plan available 优惠如果你是学生或研究人员, 你可以获得额外的积分, 请联系提供商 Paperspace 提供 10 美元的免费 Gradient° 积分 fast.ai 链接 你是否有一个 GPU 躺在你的机器使用 Vast.ai 租来赚钱？ 试驾 Nvidia GPU 链接 Google Cloud Research 计划 - 提供 $5000+ 积分 链接 用于研究的 AWS 云积分 - 链接 Nvidia GPU Grant 计划 - 链接 如果您是初创公司，那么谷歌已经为您提供了启动计划，为您提供 1000-100000 美元的积分 - 链接 Google 向研究人员提供 1000 TPU 的集群 总的来说，这个集群总共提供超过 180 petaflops 的初始计算能力 techcrunch 链接 - 应用程序链接 Google 云教育资助 - 链接 Github 教育包 - 以及许多优惠，最高可获得 110 美元的 AWS 积分 - 链接 注意 fast.ai 论坛 获取免费积分的优惠券代码 Valohai 为学生和研究人员提供 研究员许可证 想要使用 超级计算机 但还没有，去 Golem - Golem 是一个 分散的计算能力市场。它能够在 P2P 使用 CPU 和 GPU ，使应用程序所有者和个人用户能够从其他用户机器中租用资源，因此 turbo 会为您的下一次模型培训收费。 备注 Google colab 和 Kaggle 内核的会话时间有限 大多数 gpu 提供程序运行在 AWS，GCP 等之上，因此可能与后者具有或多或少相同的定价 上面给出的信息最适合我的搜索能力，您可以与提供商重新检查定价和其他信息 许可证 作者：zszazi原文：https://github.com/virgili0/Virgilio/blob/master/zh-CN/Topics/Deep%20learning%20in%20cloud/README.md]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github pages 开启 https 及配置 www]]></title>
    <url>%2F2019%2F05%2F13%2Fhttps%2F</url>
    <content type="text"><![CDATA[https://help.github.com/en/articles/adding-or-removing-a-custom-domain-for-your-github-pages-site 配置 www 域名 Setting up a www subdomain To set up a www subdomain, such as www.example.com you must configure a CNAME record with your DNS provider. 警告：如果您的域启用了 HTTPS 强制实施，GitHub Pages 的服务器将不会自动路由重定向。您必须使用 www 域名注册商配置子域名和根域重定向。 开启 httpshttps://help.github.com/en/articles/securing-your-github-pages-site-with-httpshttps://help.github.com/en/articles/setting-up-an-apex-domain 添加 A 记录，至少有一条 A 指向以下 ip 地址。 添加 www 的 CNAME 记录，指向 github pages 地址。 1234185.199.108.153185.199.109.153185.199.110.153185.199.111.153 如果 Enforce HTTPS 不可开启，先把 Custom domain 清空保存，再填入之前的地址，如 www.iosdevlog.com，等上 1，2 分钟应该就可以开启 https 了。 测试一下输入 www.iosdevlog.com 和 iosdevlog.com 都会跳转到 https://www.iosdevlog.com/ 参考：https://help.github.com/en/articles/using-a-custom-domain-with-github-pages]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下载 raywenderlich.com 上的 iOS/Android/Unity 视频、源码]]></title>
    <url>%2F2019%2F05%2F09%2Fraywenderlich%2F</url>
    <content type="text"><![CDATA[raywenderlich 简介https://www.raywenderlich.com 对于 iOS 开发人员来说一定不陌生，这可能是 iOS 初级教程里面被推荐最多的网站了吧。 其实它不仅有 iOS 的开发教程，后面还出了 android 和 Unity 的开发教程。 教程简明实用，有原理介绍还有代码实现，直接可以看到实现效果，非常推荐大家也能写成像它上面的教程。 raywenderlich 官文介绍 90kDAILY PAGEVIEWS 2049ARTICLES 2921VIDEOS &amp; SCREENCASTS 244TEAM MEMBERS raywenderlich.com is a community site focused on creating high quality programming tutorials. We pride ourselves on creating the highest-quality video courses, books, and written tutorials on the Internet. Every tutorial on our site goes through three rounds of editing before publication, to make sure each tutorial works 100%, is technically accurate, and provides comprehensive coverage of the topic. Thousands of developers and designers of all backgrounds, from all over the world, come to raywenderlich.com to teach and learn. We pay our authors and editor for all of their work, using the highest rates in the industry. Our goal is to create an environment where talented developers and teachers can make a living through their work, or advance their career by being recognized as an expert. 下载 raywenderlich 资源5 月 2 日收到 Ray Wenderlich &#114;&#x61;&#121;&#x40;&#114;&#x61;&#121;&#119;&#101;&#x6e;&#x64;&#101;&#114;&#108;&#x69;&#x63;&#104;&#x2e;&#x63;&#x6f;&#x6d; 的订阅邮件。 五一周末免费开放视频 3 天，太好了，为了以后也有时间观看，我决定把视频下载下来。 youtube-dl最先找到 https://github.com/ytdl-org/youtube-dl，这上面提供多种视频下载。 代码 clone 下来一运行，报错！登录不成功。 这个难不倒我，使用 Chrome 开发者工具，找到 Header 里面有一个 1'Authorization': 'Token ..' 打开 Postman，添加 Authorization。 Hersers 界面如下： 得到 json 文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&#123; "video": &#123; "id": 246, "name": "PDF Printing", "description": "Create a PDF file. We’ll create a budget report that you could then share.", "author_notes": "", "duration": 589, "pretty_duration": "9 minutes 49 seconds", "featured": false, "episode": 6, "format": "course", "language": null, "platform": null, "editor": null, "meta_description": null, "released_at": "2016-05-13T16:00:00.000Z", "difficulty": "intermediate", "created_at": "2016-08-04T02:56:51.175Z", "updated_at": "2019-04-28T10:01:25.399Z", "free": true, "attachments": [ &#123; "id": 4605, "url": "https://files.betamax.raywenderlich.com/attachments/videos/246/CG-Int-MyList-06.png", "kind": "watchlist_artwork", "filename": "CG-Int-MyList-06.png", "retina": false &#125;, &#123; "id": 4606, "url": "https://files.betamax.raywenderlich.com/attachments/videos/246/CG-Int-MyList-06%402x.png", "kind": "watchlist_artwork", "filename": "CG-Int-MyList-06@2x.png", "retina": true &#125;, &#123; "id": 4607, "url": "https://files.betamax.raywenderlich.com/attachments/videos/246/CG-Int-VideoBanner-06.png", "kind": "video_banner", "filename": "CG-Int-VideoBanner-06.png", "retina": false &#125;, &#123; "id": 4608, "url": "https://files.betamax.raywenderlich.com/attachments/videos/246/CG-Int-VideoBanner-06%402x.png", "kind": "video_banner", "filename": "CG-Int-VideoBanner-06@2x.png", "retina": true &#125;, &#123; "id": 1736, "url": "https://files.betamax.raywenderlich.com/attachments/videos/246/005_IntCoreGraphics_PDF.zip", "kind": "materials", "filename": "005_IntCoreGraphics_PDF.zip", "retina": false &#125; ], "authors": [ &#123; "id": 25, "role": "instructor", "user": &#123; "id": 9, "external_id": "8f5ca72a-11f3-11e6-b121-2380095a6428", "email": "caroline@archway.com.au", "username": "Caroline", "avatar_url": "https://www.gravatar.com/avatar/bfe2a965cd6136b9e2b485c959a57aff.jpg?d=https%3A%2F%2Fwolverine.raywenderlich.com%2Fv3-resources%2Fimages%2Fdefault-account-avatar_2x.png\u0026s=480", "name": "Caroline Begbie" &#125; &#125; ], "clips": [ &#123; "id": 253, "provider_id": "164661205", "provider_url": "https://vimeo.com/164661205", "pretty_duration": "9m 49s", "clip_type": "primary_content", "attachments": [ &#123; "id": 5470, "url": "https://files.betamax.raywenderlich.com/attachments/clips/253/164661205.vtt", "kind": "subtitles", "filename": "#164661205.vtt", "retina": false &#125;, &#123; "id": 1735, "url": "https://player.vimeo.com/external/164661205.m3u8?s=96740a5872b5272dc2e5b1a29af7b33a92e3739e\u0026oauth2_token_id=897711146", "kind": "stream", "filename": "#164661205", "retina": false &#125;, &#123; "id": 24274, "url": "https://player.vimeo.com/external/164661205.sd.mp4?s=dc9fad611715e5efa3e2544989877c3de083a2a5\u0026profile_id=165\u0026oauth2_token_id=897711146", "kind": "sd_video_file", "filename": "164661205.sd.mp4", "retina": false &#125;, &#123; "id": 24275, "url": "https://player.vimeo.com/external/164661205.hd.mp4?s=327799fd9b66832d7f7a53fa1a3d76cd8f9b902a\u0026profile_id=174\u0026oauth2_token_id=897711146", "kind": "hd_video_file", "filename": "164661205.hd.mp4", "retina": false &#125; ] &#125; ], "categories": [ &#123; "id": 27, "name": "carolus: Graphics \u0026 Animation" &#125;, &#123; "id": 42, "name": "domain: ios" &#125;, &#123; "id": 6, "name": "Graphics" &#125; ] &#125;&#125; 当然现在已经不行了。 123&#123; "error": "video not available"&#125; youtube-dl 是可以登录 raywenderlich，可是又报 Vimeo 登录错误。 叹！ 另辟蹊径吧，我们来解析一下 json 文件吧。我发现 123456789101112131415161718&#123; &quot;video&quot;: &#123; &quot;name&quot;: &quot;PDF Printing&quot;, &quot;clips&quot;: [ &#123; &quot;attachments&quot;: [ &#123; &quot;id&quot;: 1735, &quot;url&quot;: &quot;https://player.vimeo.com/external/164661205.m3u8?s=96740a5872b5272dc2e5b1a29af7b33a92e3739e\u0026oauth2_token_id=897711146&quot;, &quot;kind&quot;: &quot;stream&quot;, &quot;filename&quot;: &quot;#164661205&quot;, &quot;retina&quot;: false &#125; ] &#125; ] &#125;&#125; 找到 &quot;kind&quot;: &quot;stream&quot; 内容，使用 FFmpeg 下载。 1$ ffmpeg -i "https://player.vimeo.com/external/164661205.m3u8?s=96740a5872b5272dc2e5b1a29af7b33a92e3739e\u0026oauth2_token_id=897711146" "PDF Printing.mp4" 好的，可以下载。但是这个下载速度也实在是太慢了吧！ 放我的服务器上面下载，结果 FFmpeg 报 CPU 错误，我… 我在 google 上面找啊找，找啊找，还是找不着解决方法。 实在不行，我多开几个终端慢慢下吧。 下载资源（PDF，源码）通过解析上面的 json 文件，看到还有附件呢，正好前几天有人在 B站 问我要 Ray Wenderlich Video Tutorial - Introducing Custom Controls 的源码，我把源码也下载下来吧。 这个实现比较简单，直接放出源码。 12345678910111213141516171819202122232425262728293031323334353637383940import requestsfrom bs4 import BeautifulSoupimport osbase_url = 'https://www.raywenderlich.com'headers = &#123; "Accept" : "application/json, text/javascript, */*; q=0.01", "Authorization" : "Bearer xxx", "Origin" : "https://www.raywenderlich.com", "Referer" : "https://www.raywenderlich.com/", "User-Agent" : "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36", "X-CSRF-Token" : "qnaS...", "X-Requested-With" : "XMLHttpRequest", &#125;def download(url): r = requests.get(url, headers=headers) result = raywenderlich_from_dict(r.json()) name = result.video.name.replace('&amp;', '').replace(':', '').replace('?', '') attachments = result.video.attachments _id = result.video.id _name = result.video.name.replace('&amp;', '').replace(':', '').replace('?', '') for attachment in attachments: filename = attachment.filename url = attachment.url cmd = 'wget -O "%s. %s %s" %s' % (_id, _name, filename, url) os.system(cmd.encode('utf-8'))if __name__ == '__main__': for i in range(2789): url = 'https://videos.raywenderlich.com/api/v1/videos/%s.json' % I print(url) try: download(url) except: print(i) 这样就可以下载所有附件了。 再战视频下载第二天我又从服务器运行 youtube-dl，居然不报错了，太棒了，赶紧下载。 不过 youtube-dl 只能下 youtube-dl 里面的 Video Course 系列视频，而不能下载 Screencast 单个视频。原来 _VALID_URL 是不匹配，而且里面的内容也不一样。 是可忍，孰不可忍。 直接动手改代码1$ git checkout -b raywenderlich_screencast 修改 raywenderlich.md： 12345678class RayWenderlichIE(InfoExtractor): _VALID_URL = r'''(?x) https?:// (?: videos\.raywenderlich\.com/courses| (?:www\.)?raywenderlich\.com )/ (?P&lt;id&gt;[^/]+) 实现内容比之前更简单了，直接从 thumbnail 中找到 video_id 就好了，不过 thumbnail 有时候是空的，好说，正则表达式大法伺候。 于是又安心的睡觉去了。 嘀嘀嘀！原来是磁盘满了，再哭。 好吧，我一咬牙，一跺脚，再买一个磁盘大点的服务器（就买一个月吧，实在是没钱了）。 慢慢下载去吧。 嘘。嘘。嘘。。。 第二天磁盘又满了，赶紧下载 BaiduPCS-Go。 快点上传啊，我求求你了。结果没用，好的时候有好几 M 的速度，一会儿又只剩下几 k。 最后结果：共有 2K 多的视频，我下载了 1K 多的视频。 总结 时间真的比金钱重要。 提前做好准备。 关注我的公众号，AI开发日志(AIDevLog) / iOS开发日志(iOSDevLog)。 有需要资源的可以联系我，直接共享容易封，我也在慢慢上传 B站。 有条件的请去官网 https://www.raywenderlich.com 观看]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Android</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信发博客]]></title>
    <url>%2F2019%2F04%2F19%2Fwechat%2F</url>
    <content type="text"><![CDATA[Photo by Kevin Bhagat on Unsplash 在小武 2 岁的时候我创建了 《小武成长记》 网站： http://jiaxianhua.com 今年还没有更新一次博文。 http://jiaxianhua.com/jekyll/update/2017/06/06/welcome-to-jekyll.html 记录了网站的创建过程。 当时是用 jekyll 创建的，发 post 的话运行 rake 命令，交互式的创建标题，子标题，分类等，最后生成 post 模板，再写内容。 如果当天没有打开电脑，就发不了文章。 后来发现官方提供 https://github.com/jekyll/jekyll-admin，可以网页发文章。 微信发博客如果有人想要添加小武成长的故事，通过微信把内容发给我，我还要自己更新 github 仓库。 微信收到内容后可以自动发博文就太好了。 如何实现呢？ 简单的三步： 收到微信通知 生成博文 更新博文 搞定！ 1. 收到信息通知这个可以能过 github 上面开源的聊天机器人实现。 https://github.com/littlecodersh/ItChat https://github.com/Urinx/WeixinBot 我之前用过 WeixinBot，这里使用 ItChat。 首先创建一个后台运行的环境。1$ screen -S growth15 安装 itchat1$ pip3 install itchat 测试一下有了 itchat，如果你想要给文件传输助手发一条信息，只需要这样： 12345import itchatitchat.auto_login(True, enableCmdQR=2)itchat.send('Hello, filehelper', toUserName='filehelper') 文本消息如果你想要回复发给自己的文本消息，只需要这样： 12345678import itchat@itchat.msg_register(itchat.content.TEXT)def text_reply(msg): return msg.textitchat.auto_login(enableCmdQR=2)itchat.run() 客服1234567891011121314151617import itchatimport re@itchat.msg_register(itchat.content.TEXT)def text_reply(msg): reply = &#123; "发货|包装": "已经包装好，正在发货！", "功效|使用方法": "你应该这么使用。。。有这些作用。。。" &#125; text = msg.text print(text) for key, value in reply.items(): if (re.search(key, text)): return valueitchat.auto_login(enableCmdQR=2)itchat.run() 2. 生成博文12345678910111213141516171819202122232425import itchatimport reimport timeimport osdef post(text): post_head = """---layout: posttitle: &#123;title&#125;subtitle:author: 小武date: &#123;date&#125;categories:tag:---""" now = time.localtime() title = time.strftime("%Y 年 %m 月 %d 日") date = time.strftime("%Y-%m-%d %H:%M:%S +0800") content = post_head.format(title=title, date=date) content += text filename = time.strftime("_posts/%Y-%m-%d-%H-%M-%S-growth15.md") with open(filename, 'w') as f: f.write(content) 3. 更新博文主要是 git push。 12345commit = "git commit -m '&#123;&#125;'".format(title)os.system("git add -A")os.system(commit)os.system("git push")return '发送成功' 测试一下 http://jiaxianhua.com/2019/04/18/04-41-30-growth15.html 完美！ PS. 这里只是举了一个简单的例子，我并没有处理图片，视频等内容，有需要的赶紧行动起来。]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习-最新论文解释]]></title>
    <url>%2F2019%2F04%2F10%2Fpapers%2F</url>
    <content type="text"><![CDATA[2019 一月 - 3D 姿势估计 姿势估计器将视频作为输入，并输出与视频中存在的人类个体的姿势相对应的图形。 创建可靠且实时的 3D 姿势估计器的当前困难包括这样的事实：几乎没有训练数据，以及必须考虑遮挡的事实。例如，如果特定身体部位被阻挡而不能看到，则姿势估计器仍必须能够从身体其余部分的位置推断出其位置。 该模型优于所有现有模型，因为它创建姿势的 2D 和 3D 表示。它使用初始 2D 姿态估计，然后利用将该 2D 估计转换为 3D 形式的神经网络。然后，它使用 3D 到 2D 神经网络网络将姿势转换回 2D 形式，这有助于通过自我监督校正机制改进中间 3D 姿势预测，该机制可以检测第一个 2D 到 3D 的准确度神经网络。 网络允许在大约 50 毫秒内获得姿势估计，其接近每秒 20 帧。这接近实时，适用于姿势估计的许多应用 二月 - SC-FEGAN：面部编辑 GAN 该 AI 能够从一组可控模式生成逼真的图像。它建立在该领域以前的几篇论文的基础上 - 第一篇是从稀疏描述中生成图像的论文（比如一个判决书），第二篇是允许定制图像上的面部特征的论文（例如合并两个不同的面孔）。 这种技术允许我们编辑更具体的因素 - 例如，在某人的脸上微笑或删除个人的太阳镜。颜色也可以改变 - 例如，可以操纵一只眼睛的颜色。它非常快，使用 512 x 512 图像创建这些图像只需 50 毫秒。 它在电影制作的编辑行业中有应用，但也可以被寻求对其照片进行简单编辑的新颖消费者使用。虽然目前没有可用的网络应用程序，但它确实公开了其源代码。 二月 - 深度规划网络（PlaNet） 谷歌的 PlaNet AI 旨在学习如何规划必须采取的一系列步骤，以执行物理目标 - 执行，杆平衡或像人一样行走。 AI 必须以与人类相同的方式学习 - 通过查看这些图像的像素（这需要对上下文的视觉理解）。 AI 使用稀疏奖励方法，这意味着它几乎无法获得有关这些任务的性能的反馈。然而，这与经典的强化学习方法之间的关键区别在于，这种 AI 使用模型进行学习。这意味着它不是从头开始学习每一项新任务，而是利用它从以前的活动中获得的基本理解（例如引力的性质），并将其应用于未来的任务。因此，它在学习游戏时有一个良好的开端，使其效率通常比从头开始学习的技术高 50 倍。 它在大多数任务中明显优于其他最先进的 AI 系统，例如猎豹跑步或人行走。该代理不需要对每项活动进行单独培训，因为它会混合其培训。此外，它可以仅使用 5 帧参考特定活动来学习它，相当于大约五分之一秒的素材。然后，它可以学习如何在更长的时间内继续此活动。 三月 - 人类可以破译对抗性图像 虽然最近的卷积神经网络系统在图像检测问题上已超过人类表现，但问题确实存在 - 只需修改图像中的一个或两个像素就可以使系统将图像分类为极为不同的东西。例如，重新配置一两个像素就是计算机将苹果分类为汽车所需的全部内容。这种 “愚弄” 图像识别系统的能力被批评为这种系统无法以与人类相同的方式解释图像的迹象，尽管最近的一篇论文表明情况可能并非如此。 在一篇论文中，一对认知心理学家展示了一组超过 1800 个主题的图像，这些图像已经欺骗了计算机，将其分类为错误的标签。他们问人们计算机预测对象的两种选择中的哪一种 - 一种选择是计算机的真实结论，另一种是随机答案。受试者在 75％的时间内选择与计算机相同的答案，其中 98％的人倾向于像计算机那样回答。 接下来，研究人员让受试者在系统的答案和对猜测错误的图像的下一个最佳猜测之间做出选择。再次，受试者再次验证了计算机的选择 - 91％的受试者同意系统的决定。 因此，该研究提供了一定程度的证据表明卷积神经网络架构的明显缺陷可能没有许多人想象的那么糟糕。它提供了一个新的视角，以及一个可以探索的新实验范式。 2018 四月 - ProGanSR 为了实现超分辨率，允许将低分辨率图像转换为更高分辨率的图像，本文建议通过渐进方法改善图像分辨率。它需要几个中间步骤，其中产生的图像略好于前一个，称为 “课程学习”。 本文使用的是 GAN，而不仅仅是 CNN。与最先进的模型相比，使用本文提出的方法生成的图像精度略低，但速度是其 5 倍。 六月 - CIFAR-10 分类器是否适用于 CIFAR-10？ 机器学习模型的最终目标是在新的，看不见的实例上准确地预测输出。因此，在训练机器学习模型时，测试数据不参与创建模型的过程至关重要，因为这会给测试集带来偏差。不幸的是，我们通常只能从同一个发行版访问新数据，导致许多研究人员使用测试集代替验证集。这允许根据所选测试集的分布来优化诸如学习速率的超参数。 该研究论文提出了一个新的测试集，其中包含大约 2000 个实例，这些实例与 CIFAR-10 数据集的测试集的分布相匹配，这是一个众所周知的数据集，许多现代图像分类器模型都经过测试。然后评估 30 种不同的现代图像分类模型的性能。它发现从原始测试集到新测试集的准确性有显着下降 - 例如，VGG 和 ResNet 架构从其完善的 93％精度下降到大约 85％。然而，分类器相对于彼此的性能保持或多或少是恒定的 - 因此，分类器的性能分布可以被认为是简单地水平移位。 结果对当前分类器的稳健性产生了怀疑。广泛使用的模型的分类准确性显着下降 - 例如，VGG 和 ResNet 的准确度损失对应于 CIFAR-10 数据集的多年进展。因此，分配转移质疑当前模型真正推广的程度 六月 - RF-Pose 本文通过墙壁和遮挡提供准确的人体姿势估计。它利用了 WiFi 频率中的无线信号穿过墙壁并反射出人体的事实，并使用深度神经网络方法来解析这些无线电信号以估计 2D 姿势。无论光照条件如何，姿势估计都能很好地工作，并且还可以检测多个人。 在网络中，有一个教师网络，可以查看墙壁的彩色图像，并预测人体所处的姿势。还有一个学生网络将信号作为输入，并了解不同的分布意思是，它们与不同的人类姿势和姿势有何关联。教师网络向学生网络显示正确的结果，学生学习如何通过无线电信号而不是图像来制作它们。 除了用于交互式视频游戏中的动作捕捉，以及帮助为电影创建特殊效果之外，姿势估计还可用于帮助检测患者姿势的问题，跟踪动物的活动，理解手语和自己的行人活动。 - 驾驶汽车。 七月 - 基准神经网络对损坏和扰动的稳健性（Benchmarking Neural Network Robustness to Corruption &amp; Perturbations） 本文强调了一种评估图像分类器在抵抗损坏和扰动能力方面的性能的方法。它创建了两个数据集 - ImageNet-C（用于损坏）和 ImageNet-P（用于扰动） - 这有助于测试图像分类器对这种变化的稳健性，这在现实场景中很常见。 在图像的上下文中，损坏通过扭曲其细节来描述对基本图像的修改。本文在 ImageNet 图像上使用了 15 种不同的损坏函数，每种函数都有 5 个严重级别。这些损坏函数描述的方法包括高斯噪声，雪和像素化的添加。 扰动通过变换方法改变其外观来描述图像的扭曲。本文在 ImageNet 图像上使用了 8 种不同的扰动函数，包括缩放，倾斜和平移。 使用从 ImageNet-C 和 ImageNet-P 数据集中获得的图像测试分类器，通过在每种类型的所有函数和所有严重级别上平均其准确性，本文创建了关于其对损坏和扰动的鲁棒性的鲁棒性评分。 七月 - Phrank 所产生的算法使基因诊断中最劳动密集的部分自动化，即将患者的基因序列和症状与科学文献中描述的疾病相匹配。如果没有计算机帮助，这个匹配过程每个患者需要 20 到 40 个小时 - 这个过程需要专家查看大约 100 名患者可疑的突变列表，做出有根据的猜测，哪一个可能导致疾病，检查科学文学，然后继续下一个。 Bejerano 团队开发的算法将所需时间缩短了 90％。 算法的名称，Phrank，一个 “表型” 和“等级”的混搭，给出了它如何工作的暗示：它将患者的症状和基因数据与医学文献知识库进行比较，然后简单地生成一个排序列表，其中罕见的遗传性疾病最容易引起症状。平均而言，Phrank 在其产生的潜在诊断列表中将真正的诊断排在第 4 位。 十二月 - GAN 剖析 本文提出了一个框架，用于在单元，对象和场景级别可视化和理解 GAN。它提供了生成场景图像，识别对作为场景一部分的特定对象有贡献的 GAN 单元或神经元的能力，然后利用这些来激活或停用该特定对象的存在。因此，这使我们能够在不需要 Photoshop 等工具的情况下操作图像。 例如，如果我们有一个教堂的图像，我们可以向这个框架表明我们希望移除图像中存在的门。因此，框架将移除门，同时以合适的方式保持图像的其余部分的结构。如果需要，我们可以将门添加回去。除此之外，我们可以选择图像的特定区域，我们希望在其中添加新内容 - 例如，我可以在教堂图像的右侧添加一棵树。框架理解树木在地面上有根，因此在指定位置从地面构建。该框架还能够识别添加不适合的地方 - 例如，如果我们希望在天空中绘制一扇门，框架将不接受此请求。 该框架使用分段网络和解剖方法来识别与有意义的对象类（如树）匹配的生成器的各个单元。然后，当它们在图像中被修改时，它激活和停用对应于每个对象类的神经元 - 例如，插入树激活 GAN 中与树对应的神经元。什么被允许，这是本文的一个重要发现 - 相同的神经元控制各种环境中的特定对象类，即使对象的最终外观变化很大。相同的神经元可以打开 “门” 的概念，即使一个巨大的石墙需要一个朝向左侧的大型重型门，或者一个小小屋需要一个面向右侧的小型门帘。 十二月 - 基于样式的生成器 这篇由处理器和显卡公司 Nvidia 的科学家撰写的研究论文展示了从样式转移文献中借鉴的生成对抗网络的替代生成器架构的潜力。它允许对人脸中的特征进行特定的定制和控制。它有可能应用于其他领域，迄今已在汽车和房间上成功测试过。 生成器可以组合图像的不同方面。例如，如果希望将一个面部的性别与另一个面部的性别重叠，则生成器可以这样做。可以转移的方面包括性别，头发长度，姿势和眼镜的存在。 还可以逐个控制发生器的参数而不修改图像的核心内容。例如，可以修改残茬的存在。 生成器也可以执行插值。这意味着如果我们有两个图像 A 和 B，则生成器可以创建将这些图像映射到另一个的中间图像。它甚至可以改变过程中的性别。所有中间图像也都是真实的。 2017 四月 - 联盟学习（Federatred Learning） 当今开发机器学习算法和系统的组织面临的一个大问题是隐私 - 消费者不愿意让他人查看他们的数据，因为这些数据被认为对他们敏感。 Google AI 对联合学习的新研究提出了一个解决方案。 联盟学习技术依赖于分布式训练 - 它允许在通用数据的子集上独立训练模型，然后将这些独立模型组装成单个主模型。 有几个用例可以更好地描述它的功能。首先，医疗患者不愿意将他们的健康记录发送给他们不能信任的其他医院和组织。 联盟学习建议每家医院使用其拥有的有限患者数据构建自己的模型，然后使用 Google 的联合平均算法将每个医院的模型组装成单个统一模型。其次，假设我们希望训练一个预测键盘，以便在我们的智能手机上独特地适合我们的个人打字模式。我们可以使用 Federated 模型，该模型已经根据许多不同用户及其数据的预测模式进行了训练和编译，然后传递我们自己的个人键盘输入数据以更新模型以更好地适应我们的个人打字习惯。 联盟学习技术自那时起就经历了许多更新和改进，并且当人工智能在其开发过程中进入以隐私为中心的时代时，它肯定会保持相关性。 九月 - 深度特征一致的深度图像转换（DFC-DIT） 假设您需要缩小您的图像而不降低主要功能的准确性，或者您希望从图像中删除 RGB 颜色，或者如果您在不支持该范围的屏幕上显示高动态范围的图像。虽然有数百个现有结构可以做到这些，但本文描述了一种方法，与现有方法相比，这些结构非常好。 本文提出了深度特征一致的深度图像变换（DFC-DIT）框架。它利用卷积神经网络（CNN）为输入图像生成三个输出 - 缩小版本，脱色版本和 HDR 色调映射版本。它还使用了另一种采用深度特征一致性原理的预训练和固定深度 CNN - 这确保了所有主要特征都保留在图像中。 原文：https://github.com/iOSDevLog/Virgilio/blob/master/zh-CN/Research/Papers.md]]></content>
      <categories>
        <category>DL</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARKit+Swift 实现机器学习算法 k-NN]]></title>
    <url>%2F2019%2F04%2F08%2Farkit-knn%2F</url>
    <content type="text"><![CDATA[维基介绍在模式识别领域中，最近邻居法（KNN算法，又译K-近邻算法）是一种用于分类和回归的非参数统计方法[1]。在这两种情况下，输入包含特征空间（Feature Space）&amp;action=edit&amp;redlink=1)中的k个最接近的训练样本。 在k-NN分类中，输出是一个分类族群。一个对象的分类是由其邻居的“多数表决”确定的，k个最近邻居（k为正整数，通常较小）中最常见的分类决定了赋予该对象的类别。若k = 1，则该对象的类别直接由最近的一个节点赋予。 在k-NN回归中，输出是该对象的属性值。该值是其k个最近邻居的值的平均值。 最近邻居法采用向量空间模型来分类，概念为相同类别的案例，彼此的相似度高，而可以借由计算与已知类别案例之相似度，来评估未知类别案例可能的分类。 K-NN是一种基于实例的学习，或者是局部近似和将所有计算推迟到分类之后的惰性学习。k-近邻算法是所有的机器学习算法中最简单的之一。 无论是分类还是回归，衡量邻居的权重都非常有用，使较近邻居的权重比较远邻居的权重大。例如，一种常见的加权方案是给每个邻居权重赋值为1/ d，其中d是到邻居的距离。[注 1] 邻居都取自一组已经正确分类（在回归的情况下，指属性值正确）的对象。虽然没要求明确的训练步骤，但这也可以当作是此算法的一个训练样本集。 k-近邻算法的缺点是对数据的局部结构非常敏感。本算法与K-平均算法（另一流行的机器学习技术）没有任何关系，请勿与之混淆。 ARKit + Swift + k-NN 实现创建 KNN 类（结构体 struct 也行，我是为了 与 sklearn 尽量一致）。 123/// KNNpublic struct KNN&lt;Feature, Label: Hashable&gt; &#123;&#125; 属性 123456789101112/// Number of neighbors to use by default for :meth:`kneighbors` queriesprivate var k: Int/// Data setprivate var X = [Feature]()/// Target valuesprivate var y = [Label]()/// distanceprivate let distanceMetric: (_ x1: Feature, _ x2: Feature) -&gt; Double/// draw radius for debugpublic var debugRadiusCallback: (([Double]) -&gt; ())? = nil 数据： k: 指定取 k 个最接近的训练样本 X: 样本特征 （数组）一般要传数组的数组 y: 样本标签 （数组） 辅助： distanceMetric: 用来计算距离的函数 debugRadiusCallback: 调度时候用，主要是画出最近的 k 个样本范围 方法1234567891011121314151617181920/// constructorLabels for xTest////// - Parameters:/// - k: k/// - distanceMetric: distancepublic init (k: Int, distanceMetric: @escaping (_ x1: Feature, _ x2: Feature) -&gt; Double)/// train////// - Parameters:/// - X: Training set/// - y: Target valuespublic mutating func fit(X: [Feature], y: [Label]) /// Labels for xTest////// - Parameter XTest: Test set/// - Returns: Target valuespublic func predict(XTest: [Feature]) -&gt; [Label] init(): 构造函数 需要预先决定 k 和距离计算方法 fit(): 拟合目标函数，kNN 不需要拟合，只要记下数据即可 predict(): 预测给定的特征，返回对应的标签 距离计算1234567891011121314public struct Distance &#123; /// Helper function to calculate euclidian distance /// /// - Parameters: /// - x0: source coordinate /// - x1: target coordinate /// - Returns: euclidian distance public static func euclideanDistance(_ x0: [Double], _ x1: [Double]) -&gt; Double // Convenience public static func euclideanDistance() -&gt; (([Double], [Double]) -&gt; Double) &#123; return &#123; self.euclideanDistance($0, $1) &#125; &#125; 这里使用 欧式距离（Euclidean Distance） KNN 使用： 12345678910func testKNN() &#123; let kNN = KNN&lt;Double, Int&gt;(k: 3) let X = [[1.0], [2], [3], [4]] let y = [0, 0, 1, 1] kNN.fit(X, y) let label = kNN.predict([[1.2], [3]]) XCTAssertEqual([0, 1], label)&#125; 显示 2 维123456789101112131415enum MLStep: Int &#123; case train case predict&#125;enum GeometryType: Int &#123; case box case pyramid case sphere case cylinder case cone case tube case torus...&#125; MLStep： 分成 训练 和 预测 ，训练一次，可以一直预测。 GeometryType： 定义几种形状，这里定义给 ARKIT 使用的 KNNViewController1234567891011121314151617181920212223242526272829303132333435class KNNViewController: UIViewController &#123; let radius: CGFloat = 5 public var X: [[Double]] = [] public var y: [GeometryType] = [] public var XTest: [[Double]] = [] public var yTest: [GeometryType] = [] public var radiuses: [Double] = [] &#123; didSet &#123; for (center, r) in zip(XTest, radiuses) &#123; drawCircle(center: CGPoint(x: center[0], y: center[1]), radius: CGFloat(r)) &#125; &#125; &#125; public var predictLayers: [CALayer] = [] var model = KNN&lt;[Double], GeometryType&gt;(k: 1, distanceMetric: Distance.euclideanDistance()) @IBOutlet weak var kNNPickerView: UIPickerView! @IBOutlet weak var panelView: UIView! @IBOutlet weak var trainBarButtonItem: UIBarButtonItem! var mlStep = MLStep.train &#123; didSet &#123; switch mlStep &#123; case .train: trainBarButtonItem.title = "train" default: trainBarButtonItem.title = "predict" &#125; &#125; &#125;...&#125; 添加 Layer 到 panelView 上实现类别，2D 只分了三个类别，分别用 方形（红），三角形（蓝），花形（绿）表示。 使用 alpha 表示预测类别，以预测样本为中心画一个圈，圈内为最近的 k 个样本。 123456789func drawCircle(center: CGPoint, radius: CGFloat, alpha: CGFloat = 0.1) &#123; let r = self.radius + radius let kNNCircleLayer = CAShapeLayer() kNNCircleLayer.path = UIBezierPath(roundedRect: CGRect(x: center.x - r, y: center.y - r, width: r * 2, height: r * 2), cornerRadius: r).cgPath kNNCircleLayer.fillColor = UIColor(red: 0.1, green: 0.1, blue: 0.1, alpha: alpha).cgColor kNNCircleLayer.borderColor = UIColor(red: 0.8, green: 0.8, blue: 0.8, alpha: 1).cgColor kNNCircleLayer.borderWidth = 1 panelView.layer.addSublayer(kNNCircleLayer)&#125; 圆内为 k 个样本。 ARKit 实现能 3D 展示多好，别急，下面就是用 ARKit 实现的 3D 版本。 1class ARKNNViewController: UIViewController 基本实现和 ARKNNViewController 类似。 12345678910func drawSphere(center: SCNVector3, radius: Float) &#123; let geometry = SCNSphere(radius: CGFloat(radius) + self.radius) geometry.firstMaterial?.diffuse.contents = UIColor(red: 0.1, green: 0.1, blue: 0.8, alpha: 0.7) let node = SCNNode() node.geometry = geometry node.position = center sceneView.scene.rootNode.addChildNode(node)&#125; 这是画最外面的范围球体，球体内为 k 个样本。 视频b站视频：https://www.bilibili.com/video/av48647681/]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法的开源可视化工具: MLDemos]]></title>
    <url>%2F2019%2F04%2F04%2Fmldemos%2F</url>
    <content type="text"><![CDATA[MLDemos 介绍MLDemos 是一种用于机器学习算法的开源可视化工具，用于帮助研究和理解多个算法如何运作以及它们的参数如何影响和修改分类，回归，聚类，降维，动态系统和强化学习(奖励最大化)等问题的结果。 MLDemos 是开源的，可供个人和学术用途免费使用。 由 Basilio Noris 博士在 学习算法和系统实验室创建，该计划的开发得到了以下实体，组织和团体的支持和支持。 安装二进制包： MLDemos 0.5.2 for Windows 最低要求：XP SP3 MLDemos 0.5.2 for Mac 最低要求：Snow Leopard MLDemos 0.3.2_CDE 最低要求：内核 2.6.X感谢 Philip Guo（网站） 合法性这些包包含许多开源库的二进制版本。我将它们包括在这里，并且知道这可能与每个相应库的分发策略不完全兼容。我将尝试联系并从相关方获得必要的许可，在可能的范围内。与此同时，我真诚地分发这个软件，我的目标是让人们能够学习和使用这里实现的不同方法。请参阅下面的确认部分，了解贡献人员的列表。 你可以将此软件用于个人和教育目的，你不得将其用于商业目的。只要你提供此页面的链接，就可以重新分发软件。然后，此页面将始终链接到最新版本的软件，因此你最好还是在这里使用该版本。 源代码：MLDemos 源代码可以直接通过 git 或公共仓库获取（获取最新版本的 devel 分支） 1git clone git：//gitorious.org/mldemos/mldemos.git -b devel public GitHub repository source backup （0.3.0） 必要条件 该代码需要 Qt（5.10）和（部分）OpenCV（3.1）和 Boost（1.47）。这些库的早期版本可能也可以正常工作，但你也可以使用较新的版本。请务必调整 include 和 lib 路径以将它们指向正确的目录。 该软件使用 QtCreator 2.1 和 2.6 在 Mac OSX High Sierra，Windows 10，Gentoo，Ubuntu 和 Kubuntu 10.04 上进行编译和测试。 Windows 为了在 Windows 中编译 MLDemos，你需要 MinGW（通常安装 QGSDK 自带 MinGW) Debian Barak A. Pearlmutter 教授创建了一个 debian 软件包，很快就会推出。同时你可以建立它下面的说明： 123456git clone git://github.com/barak/mldemos.gitcd mldemosgit checkout debiandpkg-checkbuilddepsfakeroot debian/rules binarysudo dpkg --install ../mldemos_*.deb 注意：OpenCV 2.4 不能直接使用（仅 2.1），这将要求你构建 OpenCV2.4。这只是使用 MLP 和 Boosting 所必需的。这是两个重要的算法，所以你最好努力一下： 123456git clone git://github.com/barak/opencv.gitcd opencvgit checkout masterdpkg-checkbuilddepsfakeroot debian/rules binarysudo dpkg --install ../*opencv*.deb 再次，非常感谢 Barak ！ 已知 bug WINDOWS：在 3D 显示中清除画布会留下占用的部分内存，这可能会在多次完成时累积（仅限 Windows 上的内存错误的一部分） LINUX（CDE 包）加载和保存外部文件不起作用 近似最邻近 KNN 分类在某些机器上创建了并带有一些指标的奇怪空白区域，。 保存在 Linux CDE 包上不起作用 在绘制奖励地图时调整画布大小不会更新基础数据（避免这样做）。 在 Boosting 中，更改数据不会重新计算学习器，如果数据显着改变了边界，则可能导致不良结果 新功能 Changelog v0.5.0 新的可视化和数据集功能 添加了样本的三维可视化和分类，回归及最大化结果 添加了可视化面板，其中包含各个图，相关性，密度等 添加了编辑工具来拖动 / 磁化数据，更改类，增加或减少数据集的尺寸 添加了分类维度（带有非数值的索引维度） 添加了 “数据集编辑” 面板以交换，删除和重命名维，类或分类值 用于显示，导入 / 导出 数据，分类性能的 几个错误修复 新的算法和方法 添加了 “网格搜索” 面板，用于批量测试一次最多两个参数的值范围 为非多类算法添加了 One-vs-All 多类别分类 现在可以对新数据进行训练和测试（对一个数据集进行训练，对另一个进行测试） 添加了 RBF 内核的 SVM 自动相关性确定（感谢 Ashwini Shukla！） 添加了成长的分层自组织地图（Michael Dittenbach 的原始代码） 添加了随机森林分类 添加 LDA 作为分类器（除投影仪外） 为 GMM 和 SVM 添加了保存 / 加载模型选项 软件截图MLDemos 图形用户界面不同的可视化和参数效果样本图，密度和相关性的可视化SVM + RBF 分类稀疏高斯过程回归具有避障功能的动力系统（SEDS）核 PCA 等值线基于遗传算法的强化学习(奖励最大化用 RBF 核支持向量回归基于 RBF 核的相关向量机分类随机圈弱学习器的提升具有 RBF 内核的多类 SVM用高斯混合模型聚类越来越多的分层自组织地图 算法实现方法分类 支持向量机（SVM） （C，nu，Pegasos） 相关向量机（RVM） 高斯混合模型（GMM） 多层感知器 + 后向传播 温柔的 AdaBoost + 朴素贝叶斯 近似 K-Nearest Neighbors（KNN） 高斯过程分类（GP） 随机森林 回归 支持向量回归（SVR） 相关向量回归（RVR） 高斯混合回归（GMR） MLP + BackProp 近似 KNN 高斯过程回归（GPR） 稀疏优化高斯过程（SOGP） 局部加权散点图平滑（LOWESS） 局部加权投影回归（LWPR） 动力系统 GMM + GMR LWPR SVR SEDS SOGP（慢！） MLP KNN 增强型 SVM（ASVM） 聚类 K 均值(K-Means) Soft K-Means Kernel K-Means K-Means++ GMM One Class SVM FLAME DBSCAN 预测 主成分分析（PCA） 内核 PCA 独立成分分析（ICA） 典型相关分析（CCA） 线性判别分析（LDA） Fisher 线性判别 EigenFaces 到 2D（使用 PCA） 奖励最大化 （强化学习） 随机搜索 随机漫步 PoWER 遗传算法（GA） 粒子群优化算法 粒子滤波器 Donut（一种基于变分自动编码器的季节性 KPI 的无监督异常检测算法） 无梯度方法（nlopt） 贡献如果你正在开发一种适合 MLDemos 框架的新算法，并希望将其集成到软件中，请与我们联系（参见下面的信息）并描述实现 MLDemos 插件所需的帮助类型。 致谢如果许多人没有投入大量精力来实现这里组合成单个程序的不同算法，那么该程序将不存在。 Florent D’Hallouin (GMM + GMR) - LASA Dan Grollman (SOGP) - LASA Mohammad Khansari (SEDS + DSAvoid) - LASA Ashwini Shukla (ASVM, ARD Kernels) - LASA Stephane Magnenat (ESMLR) - website Chih-Chung Chang and Chih-Jen Lin (libSVM) - website David Mount and Sunik Arya (ANN library) - website Davis E. King (DLIB) - website Stefan Klanke and Sethu Vijayakumar (LWPR) - website Robert Davies (Newmat) - website JF Cardoso (ICA) - website Steven G. Johnson (NLOpt) - website The WillowGarage crowd (OpenCV) - website Trolltech/Nokia/Digia (Qt) - website The authors of several of the icons - website 参加 EPFL 2012 年 ML 课程的博士生（Julien Eberle，Pierre-Antoine Sondag，Guillaume deChambrier，Klas Kronander，Renaud Richardet，Raphael Ullman）此外，如果没有 LASA 的支持和开发团队的工作，该计划本身的性能将大大降低：Christophe Paccolat，Nicolas Sommer 和 Otpal Vittoz。 还要感谢那些没有贡献代码但直接贡献的人：Aude Billard，作为人们所希望的最佳老板之一，FrançoisFleuret，进行了一系列富有成果的讨论，以及 AML 2010 和 2011 年的课程耐心地给它第一次试驾。 快速开始启动该软件通过单击鼠标左键或右键来绘制样本。单击鼠标左键可生成 0 级样本右键单击生成工具栏中所选类的样本（默认值：1）选择 “显示选项” 图标这将允许你显示模型信息，置信度 / 似然图并隐藏原始样本鼠标滚轮将允许你放大和缩小alt + 拖动将允许你平移空间 选择 “算法选项” 图标 选择一个算法图标以打开其各自的选项面板 单击 “分类” 按钮以对当前数据运行算法 导入数据 在 MLDemos 中生成数据有三种不同的方式：手动绘制样本，通过 PCA（通过 PCAFaces 插件）投影图像数据，或通过加载外部数据。可以将逗号分隔值或其他基于文本文件的值表拖放到界面中。在这种情况下，将出现 “数据加载” 对话框，允许选择应加载哪些列或行，解释为类标签或标题等。 或者，软件使用的本机数据格式是基于 ascii 的，包含： 样本数量后跟维度＃ 对于每个样品，一行包含 样本值以空格分隔（浮点数，每个维度一个） 样本类索引（整数 0 … 255） 用于终止该行的标志值（整数 0-3）（暂时未使用） 一个简单的例子是 123454 30.10 0.11 0.12 0 00.14 0.91 0.11 0 00.43 0.74 0.41 1 00.28 0.34 0.33 1 0 它提供 4 个三维样本，两个来自类别 0，1 个来自类别 1 。(原文有问题吧？) 文件保存时从 MLDemos，该软件添加了当前的算法参数（假设选择了算法），这可用于演示目的。如果不存在此类信息，则选择默认算法参数。 手动绘制一些样本，或导入标准数据集并从 MLDemos 中保存它应该为你提供有关文件语法的大量示例。 网站: http://mldemos.b4silio.com/]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github 2019 年最值得关注的数据科学项目 Virgilio(维吉尔) 中文版]]></title>
    <url>%2F2019%2F04%2F03%2Fvirgilio%2F</url>
    <content type="text"><![CDATA[项目地址：https://github.com/clone95/virgilio 目前为止： [7,128] star [1,303] fork，希望你看到之后能给它添加一个 star 。 这个项目首次提交在 2019 年 3 月 12 日，原名叫https://github.com/clone95/Data-Science-Study-Paths-March-2019，一个月的时间就有 6k+ 个 star，经常排在 http://github.com/explorer 的前几位。当然最近被榜单被 996icu 占了。 关于项目改名： 项目作者把项目名改成维吉尔(Virgilio)，这是 13 世纪末意大利诗人但丁所著长诗《神曲》中旦丁的导师。 这是什么地方？通过互联网进行学习意味着在无限的混乱信息丛林中游泳，在快速变化的创新领域更是如此。 当你试图接近一个没有真正 “路径” 的新主题时，你有没有感到不知所措？你是否妨碍获得深厚的知识和应用它的能力？ 嗨，我是 维吉尔(Virgilio) 。 就像几年前我和 但丁(Dante) 一样，在你的互联网旅程中，我将成为你的导师和参考点，为你提供完整的有机学习途径，包括多个领域，工具，技能等。 我是怎么做到的？我试图简明扼要，以避免信息开销。 我按层次结构和复杂程度组织了内容，以便你对事物的运作方式有一个连贯的想法。 你将学习如何通过实践项目理解和应用理论，并仔细遵循我的提示和技巧，你将从头开始掌握新技能。 你不需要任何先前的主题知识，但对编程和高中数学有信心，以理解和实现大多数概念。 此处列出的每个来源都是免费或开源的。 我最感兴趣的是数据科学，因为我试图预测耶路撒冷的陨落，但是你知道，那时我们没有那么多的计算能力！ 你能在这里找到什么？我为你打包了几种类型的指南： 职业：完整的学习路径，指导你从头开始掌握新技能。 主题：关于由子领域组织的特定主题，方法和现实应用的综合指南。 专业化：个人技能的垂直指南。 工具：单一工具或技术的深入指南。 研究：对最新论文和技术文件的最新审查和解释。 元(Meta)：这些主要是关于如何学习和接近新概念的指南。 如果你发现此 repo 有用，我请你 star 一下，与你的朋友和同事分享，然后点击 watch，因为每天都会有更新！ 我的目的是什么？我的目标主要是帮助人们开始使用创新的领域和技术，即使你从未尝试过编写代码，或者你需要深入的数学评介，我也会给你这样的基础。因此，你可以成为一名学生，另一个领域的工作人员或经理，你将在这里找到你需要做好准备，以应对未来几年肯定会发生的破坏性和不可预测的市场和社会转型。 我的价格：我在这里等你，免费。如果你发现我在某种程度上有所帮助，我只要求你留下一个 star ，点击 watch，每次你有机会时请分享我。让我们开始我们的旅程！ 新接触数据科学？基础 Python基础数学 - 即将推出高级 Python - 即将推出高级数学 - 即将推出Python 数据科学数学数据科学 - 即将推出完整的学习路径机器学习研究路径商业智能研究路径 - 即将推出云计算研究路径 - 即将推出专业化数据预处理数据收集 [即将推出 - 下一步]数据可视化 [即将推出]有效沟通 [即将推出]有效陈述 - 新实用决策 [即将推出]工具LatexWolfram AlphaGeoGebra正则表达式即将推出主题DialogFlow 和 Flask 打造 ChatBot研究Zotero最新论文 [即将推出]关于专业化你可以按顺序选择它们或选择最适合你的那个，但我建议你至少要一次把它们都看完。 我计划了两种类型的专业化：硬技能和软技能 前者是关于技术流程，是每个处理数据的人的核心工具包。使用数据是一种艺术形式，经验法则和最佳实践将帮助你了解处理它们的方式。你需要对如何处理数据产生一种 “感觉”，这种 “感觉” 主要是由情况和经验驱动的。因此，这些专业将强烈关注练习和练习。 后者是关于… 所有未写在技术书籍中的东西。使用和掌握它们，因为它们是你真正的价值促成者。你可以成为世界上最好的开发人员或工程师，但如果你无法向受众传达你的建议和发现，或者使用数据来建议现实世界中的实际行动，那么你对公司来说就毫无用处。 关于主题单个主题将按字段分割，它们可以触及实际应用程序，方法，技术栈，最佳实践等。 关于工具“工具” 部分将提供有关你需要了解的特定技术 / 语言 / 方法的所有指南！它们将为你提供彻底探索和掌握手头工具的方法。 订阅我们新闻发布和更新的FACEBOOK组翻译人员@jiaxianhua (iOSDevLog) 在我准备翻译之前就已经有中国人准备翻译成中文，后来共有 4 个中国人想要翻译成中文。 我们重新建了一个 https://telegram.org/ 中文聊天群 Virgilio_cn，并把 @Clone95 拉进群，准备我们的翻译计划。 一开始人打算可以使用有团队协作功能的 蚂蚁笔记 Leanote，它具有以下特性。 Markdown 编辑器实时同步预览，你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式。 详细历史纪录每次保存都在后端备份，轻松查找，一键恢复。 实时同步 － 云协作版丰富的团队权限管理完整的文档树型结构支持Docker，私有云部署实时IM群聊讨论 最重要的是它是开源的：https://github.com/leanote 于是我把它部署在服务器。 后来 @Clone95 找到了 WebLate。 Weblate 是一个基于网络自由软件持续本地化系统。 这个也是开源的，我把它也部署在服务器上http://67.218.132.50/。 部署过程：https://www.jianshu.com/p/f3cd7dfd48d1 Weblate 支持多种翻译格式，我选择把 md 文件改换成 xliff 再上传。 Weblate 还支持机器翻译https://docs.weblate.org/en/latest/admin/machine.html。 大多数翻译 API 要收费，也包括流行的 Google Translate。最终我选用了 Baidu API machine translation ，每月翻译字符数低于200万，享免费服务；超过200万字符，需按照49元人民币/百万字符支付当月全部翻译字符数费用（包括之前免费的200万字符）。 转换几个文件后，翻译群里的小伙伴们就开始翻译。之后又发现 Xliff 要把 md 文件里的 “&lt;&gt;&amp;” 这些符号替换成占位符。好麻烦，还不如直接用 json 格式。 转换方式：https://www.jianshu.com/p/323a5d033767 最终还是用 google translate api 直接翻译 md 文件。 转换过程：https://www.jianshu.com/p/5835eb34cbb1 用 vscode 一边英文，一边中文对照着改通顺。 翻译中肯定有许多不专业的地方，特别是 WolframAlpha 的翻译，请大家将不准确的地方提出，或者加入我们的 Telegram / 微信翻译群。 微信公众号：AI开发日志(AIDevLog) 最后还是请大家 star 并分享给你的好友们！ https://github.com/clone95/virgilio]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务十-BERT]]></title>
    <url>%2F2019%2F03%2F21%2Fnlp-task10%2F</url>
    <content type="text"><![CDATA[Transformer的原理Google Tensor2Tensor系统是一套十分强大的深度学习系统，在多个任务上的表现非常抢眼。尤其在机器翻译问题上，单模型的表现就可以超过之前方法的集成模型。这一套系统的模型结构、训练和优化技巧等，可以被利用到公司的产品线上，直接转化成生产力。 Tensor2Tensor（T2T）是Google Brain Team在Github上开源出来的一套基于TensorFlow的深度学习系统。该系统最初是希望完全使用Attention方法来建模序列到序列（Sequence-to-Sequence，Seq2Seq）的问题，对应于《Attention Is All You Need》这篇论文。该项工作有一个有意思的名字叫“Transformer”。随着系统的不断扩展，T2T支持的功能变得越来越多，目前可以建模的问题包括：图像分类，语言模型、情感分析、语音识别、文本摘要，机器翻译。T2T在很多任务上的表现很好，并且模型收敛比较快，在TF平台上的工程化代码实现的也非常好，是一个十分值得使用和学习的系统。 如果是从工程应用的角度出发，想快速的上手使用T2T系统，只需要对模型有一些初步的了解，阅读一下workthrough文档，很快就能做模型训练和数据解码了。这就是该系统想要达到的目的，即降低深度学习模型的使用门槛。系统对数据处理、模型、超参、计算设备都进行了较高的封装，在使用的时候只需要给到数据路径、指定要使用的模型和超参、说明计算设备就可以将系统运行起来了。 序列到序列（Sequence-to-Sequence）是自然语言处理中的一个常见任务，主要用来做泛文本生成的任务，像机器翻译、文本摘要、歌词/故事生成、对话机器人等。最具有代表性的一个任务就是机器翻译（Machine Translation），将一种语言的序列映射到另一个语言的序列。例如，在汉-英机器翻译任务中，模型要将一个汉语句子（词序列）转化成一个英语句子（词序列）。 ​目前Encoder-Decoder框架是解决序列到序列问题的一个主流模型。模型使用Encoder对source sequence进行压缩表示，使用Decoder基于源端的压缩表示生成target sequence。该结构的好处是可以实现两个sequence之间end-to-end方式的建模，模型中所有的参数变量统一到一个目标函数下进行训练，模型表现较好。图1展示了Encoder-Decoder模型的结构，从底向上是一个机器翻译的过程。 ​ Encoder和Decoder可以选用不同结构的Neural Network，比如RNN、CNN。RNN的工作方式是对序列根据时间步，依次进行压缩表示。使用RNN的时候，一般会使用双向的RNN结构。具体方式是使用一个RNN对序列中的元素进行从左往右的压缩表示，另一个RNN对序列进行从右向左的压缩表示。两种表示被联合起来使用，作为最终序列的分布式表示。使用CNN结构的时候，一般使用多层的结构，来实现序列局部表示到全局表示的过程。使用RNN建模句子可以看做是一种时间序列的观点，使用CNN建模句子可以看做一种结构化的观点。使用RNN结构的序列到序列模型主要包括RNNSearch、GNMT等，使用CNN结构的序列到序列模型主要有ConvS2S等。 BERT的原理BERT的全称是Bidirectional Encoder Representation from Transformers，即双向Transformer的Encoder，因为decoder是不能获要预测的信息的。模型的主要创新点都在pre-train方法上，即用了Masked LM和Next Sentence Prediction两种方法分别捕捉词语和句子级别的representation。 BERT中使用的编码器是一种基于注意力的自然语言处理（NLP）架构，它在一年前的Attention Is All You Need一文中引入。 自今年早些时候ULMFiT发布以来，转学习已迅速成为NLP最先进成果的标准 。之后，通过将变压器与转移学习相结合，取得了显着的进步。 这种组合的两个标志性例子是OpenAI的GPT和Google AI的BERT。 为了解释这种架构，我们将采用一般到具体的方法。我们将通过查看架构中的信息流开始，我们将潜入输入和输出的编码器作为文件中提出。接下来，我们将查看每个编码器块并了解如何使用多头注意。 信息流通过架构的数据流如下： 该模型将每个标记表示为emb_dim大小的向量。对于每个输入令牌使用一个嵌入向量，我们有一个特定输入序列的维度矩阵（input_length）x（emb_dim）。 然后它添加位置信息（位置编码）。此步骤返回维度矩阵（input_length）x（emb_dim），就像上一步骤一样。 数据通过N个编码器块。在此之后，我们获得尺寸矩阵（input_length）x（emb_dim）。 利用预训练的BERT模型将句子转换为句向量，进行文本分类参考transformer github实现：GitHub - Kyubyong/transformer: A TensorFlow Implem… transformer pytorch分步实现：The Annotated Transformer 搞懂Transformer结构，看这篇PyTorch实现就够了：搞懂Transformer结构，看这篇PyTorch实现就够了！ - TinyMind -专注人工智… “变形金刚”为何强大：从模型到代码全面解析Google Tensor2Tensor系统：“变形金刚”为何强大：从模型到代码全面解析Google Tensor2Tensor系统 - 腾讯云技… bert理论： bert系列1：https://medium.com/dissecting-bert/dissecting-bert-part-1-d3c3d495cdb3 bert系列2：https://medium.com/dissecting-bert/dissecting-bert-part2-335ff2ed9c73 bert系列3：https://medium.com/dissecting-bert/dissecting-bert-appendix-the-decoder-3b86f66b0e5f 5 分钟入门 Google 最强NLP模型：BERT：5 分钟入门 Google 最强NLP模型：BERT - 简书 BERT – State of the Art Language Model for NLP：BERT – State of the Art Language Model for NLP | L… google开源代码：GitHub - google-research/bert: TensorFlow code and… bert实践： 干货 BERT fine-tune 终极实践教程：干货 | BERT fine-tune 终极实践教程 - 简书 小数据福音！BERT在极小数据下带来显著提升的开源实现：小数据福音！BERT在极小数据下带来显著提升的开源实现 BERT实战（源码分析+踩坑）：BERT实战（源码分析 踩坑） - 知乎]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务九-Attention原理]]></title>
    <url>%2F2019%2F03%2F19%2Fnlp-task9%2F</url>
    <content type="text"><![CDATA[Attention为什么需要Attention最基本的seq2seq模型包含一个encoder和一个decoder，通常的做法是将一个输入的句子编码成一个固定大小的state，然后作为decoder的初始状态（当然也可以作为每一时刻的输入），但这样的一个状态对于decoder中的所有时刻都是一样的。 attention即为注意力，人脑在对于的不同部分的注意力是不同的。需要attention的原因是非常直观的，比如，我们期末考试的时候，我们需要老师划重点，划重点的目的就是为了尽量将我们的attention放在这部分的内容上，以期用最少的付出获取尽可能高的分数；再比如我们到一个新的班级，吸引我们attention的是不是颜值比较高的人？普通的模型可以看成所有部分的attention都是一样的，而这里的attention-based model对于不同的部分，重要的程度则不同。 Attention-based Model是什么Attention-based Model其实就是一个相似性的度量，当前的输入与目标状态越相似，那么在当前的输入的权重就会越大，说明当前的输出越依赖于当前的输入。严格来说，Attention并算不上是一种新的model，而仅仅是在以往的模型中加入attention的思想，所以Attention-based Model或者Attention Mechanism是比较合理的叫法，而非Attention Model。 基本的Attention原理对于机器翻译来说，比如我们翻译“机器学习”,在翻译“machine”的时候，我们希望模型更加关注的是“机器”而不是“学习” \begin{aligned} u_{t}^{i} &=v^{T} \tanh \left(W_{1} h^{i}+W_{2} Z^{t}\right) \\ \alpha_{t}^{i} &=\operatorname{softmax}\left(u_{t}^{i}\right) \\ c^{t} &=\sum_{i} \alpha_{t}^{i} h^{i} \end{aligned}HAN的原理（Hierarchical Attention Networks）网络结构 包括五层网络： 词向量编码（GRU） 词向量Attention层 句子向量编码（GRU） 句子向量Attention层 softmax输出层 HAN模型结构 HAN模型就是分层次的利用注意力机制来构建文本向量表示的方法。 文本由句子构成，句子由词构成，HAN模型对应这个结构分层的来构建文本向量表达； 文本中不同句子对文本的主旨影响程度不同，一个句子中不同的词语对句子主旨的影响程度也不同，因此HAN在词语层面和句子层面分别添加了注意力机制； 分层的注意力机制还有一个好处，可以直观的看出用这个模型构建文本表示时各个句子和单词的重要程度，增强了可解释性。 这篇论文里面使用双向GRU来构建句子表示和文本表示，以句子为例，得到循环神经网络中每个单元的输出后利用注意力机制整合得到句子向量表示（不使用attention时，一般会使用MAX或AVE），过程如下： \begin{aligned} u_{i t} &=\tanh \left(W_{w} h_{i t}+b_{w}\right) \\ \alpha_{i t} &=\frac{\exp \left(u_{i t}^{\top} u_{w}\right)}{\sum_{t} \exp \left(u_{i t}^{\top} u_{w}\right)} \\ s_{i} &=\sum_{t} \alpha_{i t} h_{i t} \end{aligned}利用Attention模型进行文本分类参考浅谈Attention-based Model【原理篇】Hierarchical Attention Networks for Document Classification]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务八-循环神经网络]]></title>
    <url>%2F2019%2F03%2F17%2Fnlp-task8%2F</url>
    <content type="text"><![CDATA[递归神经网络递归神经网络（RNN）是神经网络的一种。单纯的RNN因为无法处理随着递归，权重指数级爆炸或梯度消失的问题（Vanishing gradient problem），难以捕捉长期时间关联；而结合不同的LSTM可以很好解决这个问题。 时间递归神经网络可以描述动态时间行为，因为和前馈神经网络（feedforward neural network）接受较特定结构的输入不同，RNN将状态在自身网络中循环传递，因此可以接受更广泛的时间序列结构输入。手写识别是最早成功利用RNN的研究结果。 RNN的结构一个简单的循环神经网络，它由输入层、一个隐藏层和一个输出层组成。 这个网络在t时刻接收到输入 x_{t} 之后，隐藏层的值是 s_{t} ，输出值是 o_{t} 。关键一点是， s_{t} 的值不仅仅取决于 x_{t} ，还取决于 s_{t-1} 。我们可以用下面的公式来表示循环神经网络的计算方法： \begin{aligned} O_{t} &=g\left(V \cdot S_{t}\right) \\ S_{t} &=f\left(U \cdot X_{t}+W \cdot S_{t-1}\right) \end{aligned}循环神经网络的提出背景、优缺点。着重学习RNN的反向传播、RNN出现的问题（梯度问题、长期依赖问题）、BPTT算法。 双向RNN在经典的循环神经网络中，状态的传输是从前往后单向的。然而，在有些问题中，当前时刻的输出不仅和之前的状态有关系，也和之后的状态相关。这时就需要双向RNN（BiRNN）来解决这类问题。例如预测一个语句中缺失的单词不仅需要根据前文来判断，也需要根据后面的内容，这时双向RNN就可以发挥它的作用。 双向RNN是由两个RNN上下叠加在一起组成的。输出由这两个RNN的状态共同决定。 从上图可以看出，双向RNN的主题结构就是两个单向RNN的结合。在每一个时刻t，输入会同时提供给这两个方向相反的RNN，而输出则是由这两个单向RNN共同决定（可以拼接或者求和等）。 同样地，将双向RNN中的RNN替换成LSTM或者GRU结构，则组成了BiLSTM和BiGRU。 LSTM、GRU的结构、提出背景、优缺点针对梯度消失（LSTM等其他门控RNN）、梯度爆炸（梯度截断）的解决方案Memory NetworkMemory Networks (2015)对应论文：Memory Networks (2015) Memory Networks 提出的基本动机是我们需要 长期记忆（long-term memory）来保存问答的知识或者聊天的语境信息，而现有的 RNN 在长期记忆中表现并没有那么好。 组件4 个重要组件： I: input feature map把输入映射为特征向量（input -&gt; feature representation）通常以句子为单位，一个句子对应一个向量 G: generalization使用新的输入数据更新 memories O: output给定新的输入和现有的 memory state，在特征空间里产生输出类比 attention RNN decoder 产生 outputs/logits R: response将输出转化为自然语言 流程 Text-RNN的原理利用Text-RNN模型来进行文本分类Recurrent Convolutional Neural Networks（RCNN）原理Rich feature hierarchies for accurate oject detection and semantic segmentation R-CNN 采用 AlexNet R-CNN 采用 Selective Search 技术生成 Region Proposal. R-CNN 在 ImageNet 上先进行预训练，然后利用成熟的权重参数在 PASCAL VOC 数据集上进行 fine-tune R-CNN 用 CNN 抽取特征，然后用一系列的的 SVM 做类别预测。 R-CNN 的 bbox 位置回归基于 DPM 的灵感，自己训练了一个线性回归模型。 R-CNN 的语义分割采用 CPMC 生成 Region 利用RCNN模型来进行文本分类参考递归神经网络 - 维基百科一文搞懂RNN（循环神经网络）基础篇 - 知乎深度学习笔记——RNN（LSTM、GRU、双向RNN）学习总结论文笔记 - Memory Networks 系列 - 知乎【深度学习】R-CNN 论文解读及个人理解一份详细的LSTM和GRU图解 -ATYUNTensorflow实战(1): 实现深层循环神经网络 - 知乎从LSTM到Seq2Seq-大数据算法GitHub - airalcorn2/Recurrent-Convolutional-Neural-Network-Text-ClassifierGitHub - zhangfazhan/TextRCNN: TextRCNN 文本分类GitHub - roomylee/rcnn-text-classification: Tensorflow Implementation of “Recurrent Convolutional Neural Network for Text Classification” (AAAI 2015)]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务七-卷积神经网络]]></title>
    <url>%2F2019%2F03%2F15%2Fnlp-task7%2F</url>
    <content type="text"><![CDATA[卷积运算的定义、动机（稀疏权重、参数共享、等变表示） 定义函数 $f, g$ 是定义在 $\mathbb{R}^{n}$ 上的可测函数（measurable function），$f$ 与 $g$ 的卷积记作 $f * g$，它是其中一个函数翻转并平移后与另一个函数的乘积的积分，是一个对平移量的函数，也就是： (f * g)(t) \stackrel{\mathrm{def}}{=} \int_{\mathbb{R}^{n}} f(\tau) g(t-\tau) d \tau如果函数不是定义在 $\mathbb{R}^{n}$ 上，可以把函数定义域以外的值都规定成零，这样就变成一个定义在 $\mathbb{R}^{n} $ 上的函数。 卷积动画 Blue maps are inputs, and cyan maps are outputs. 注意：蓝色地图是输入，青色地图是输出。 No padding, no strides Arbitrary padding, no strides Half padding, no strides Full padding, no strides No padding, strides Padding, strides Padding, strides (odd) 一维卷积运算和二维卷积运算 反卷积(tf.nn.conv2d_transpose)反卷积(转置卷积)动画 Blue maps are inputs, and cyan maps are outputs. 注意：蓝色地图是输入，青色地图是输出。 No padding, no strides, transposed Arbitrary padding, no strides, transposed Half padding, no strides, transposed Full padding, no strides, transposed No padding, strides, transposed Padding, strides, transposed Padding, strides, transposed (odd) 池化在通过卷积获得了特征 (features) 之后，下一步我们希望利用这些特征去做分类。理论上讲，人们可以用所有提取得到的特征去训练分类器，例如 softmax 分类器，但这样做面临计算量的挑战。例如：对于一个 $96X96$ 像素的图像，假设我们已经学习得到了$400$个定义在$8X8$输入上的特征，每一个特征和图像卷积都会得到一个 (96 − 8 + 1) * (96 − 8 + 1) = 7921 维的卷积特征，由于有 $400$ 个特征，所以每个样例 (example) 都会得到一个 $892 * 400 = 3,168,400$ 维的卷积特征向量。学习一个拥有超过 3 百万特征输入的分类器十分不便，并且容易出现过拟合 (over-fitting)。 为了解决这个问题，首先回忆一下，我们之所以决定使用卷积后的特征是因为图像具有一种“静态性”的属性，这也就意味着在一个图像区域有用的特征极有可能在另一个区域同样适用。因此，为了描述大的图像，一个很自然的想法就是对不同位置的特征进行聚合统计，例如，人们可以计算图像一个区域上的某个特定特征的平均值 (或最大值)。这些概要统计特征不仅具有低得多的维度 (相比使用所有提取得到的特征)，同时还会改善结果(不容易过拟合)。这种聚合的操作就叫做池化 (pooling)，有时也称为平均池化或者最大池化 (取决于计算池化的方法)。 运算的定义、种类（最大池化、平均池化等）、动机。 Text-CNN的原理TextCNN相较于fastText模型的结构会复杂一些，在2014年提出，使用卷积 + 最大池化这两个在图像领域非常成功的好基友组合。我们先看一下他的结构。如下图所示，示意图中第一层输入为7*5的词向量矩阵，其中词向量维度为5，句子长度为7，然后第二层使用了3组宽度分别为2、3、4的卷积核，图中每种宽度的卷积核使用了两个。 其中每个卷积核在整个句子长度上滑动，得到n个激活值，图中卷积核滑动的过程中没有使用padding，因此宽度为4的卷积核在长度为7的句子上滑动得到4个特征值。然后出场的就是卷积的好基友全局池化了，每一个卷积核输出的特征值列向量通过在整个句子长度上取最大值得到了6个特征值组成的feature map来供后级分类器作为分类的依据。 我们知道图像处理中卷积的作用是在整幅图像中计算各个局部区域与卷积核的相似度，一般前几层的卷积核是可以很方便地做可视化的，可视化的结果是前几层的卷积核是在原始输入图像中寻找一些简单的线条。NLP中的卷积核没法做可视化，那么是不是就不能理解他在做什么了呢，其实可以通过模型的结构来来推断他的作用。因为TextCNN中卷积过后直接就是全局max pooling，那么它只能是在卷积的过程中计算与某些关键词的相似度，然后通过max pooling层来得出模型关注那些关键词是否在整个输入文本中出现，以及最相似的关键词与卷积核的相似度最大有多大。我们假设中文输出为字向量，理想情况下一个卷积核代表一个关键词，如下图所示： 比如说一个2分类舆情分析任务中，如果把整个模型当成一个黑箱，那么去检测他的输出结果，会发现这个模型对于输入文本中是否含有“喜欢”，“热爱”这样的词特别敏感，那么他是怎么做到的呢？整个模型中能够做到遍历整个句子去计算关键词相似度的只有卷积的部分，因为后面直接是对整个句子长度的max pooling。但是因为模型面对的是字向量，并不是字，所以他一个卷积核可能是只学了半个关键词词向量，然后还有另外的卷积核学了另外半个关键词词向量，最后在分类器的地方这些特征值被累加得到了最终的结果。 TextCNN模型最大的问题也是这个全局的max pooling丢失了结构信息，因此很难去发现文本中的转折关系等复杂模式，TextCNN只能知道哪些关键词是否在文本中出现了，以及相似度强度分布，而不可能知道哪些关键词出现了几次以及出现这些关键词出现顺序。假想一下如果把这个中间结果给人来判断，人类也很难得到对于复杂文本的分类结果，所以机器显然也做不到。针对这个问题，可以尝试k-max pooling做一些优化，k-max pooling针对每个卷积核都不只保留最大的值，他保留前k个最大值，并且保留这些值出现的顺序，也即按照文本中的位置顺序来排列这k个最大值。在某些比较复杂的文本上相对于1-max pooling会有提升。 利用Text-CNN模型来进行文本分类参考卷积有多少种？一文读懂深度学习中的各种卷积 - 知乎 A technical report on convolution arithmetic in the context of deep learning 池化 达观数据曾彦能：如何用深度学习做好长文本分类与法律文书智能化处理]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务六-简单神经网络]]></title>
    <url>%2F2019%2F03%2F13%2Fnlp-task6%2F</url>
    <content type="text"><![CDATA[文本表示：从one-hot到word2vec One-Hot编码，又称为一位有效编码，主要是采用位状态寄存器来对个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候只有一位有效。 在实际的机器学习的应用任务中，特征有时候并不总是连续值，有可能是一些分类值，如性别可分为“male”和“female”。 Word2vec，为一群用来产生词向量的相关模型。这些模型为浅层双层的神经网络，用来训练以重新建构语言学之词文本。网络以词表现，并且需猜测相邻位置的输入词，在word2vec中词袋模型假设下，词的顺序是不重要的。 训练完成之后，word2vec模型可用来映射每个词到一个向量，可用来表示词对词之间的关系。该向量为神经网络之隐藏层。 Word2vec依赖skip-grams或连续词袋（CBOW）来建立神经词嵌入。Word2vec为托马斯·米科洛夫（Tomas Mikolov）在Google带领的研究团队创造。该算法渐渐被其他人所分析和解释。 词袋模型：离散、高维、稀疏词袋模型（英语：Bag-of-words model）是个在自然语言处理和信息检索(IR)下被简化的表达模型。此模型下，一段文本（比如一个句子或是一个文档）可以用一个装着这些词的袋子来表示，这种表示方式不考虑文法以及词的顺序。最近词袋模型也被应用在电脑视觉领域。[1]词袋模型被广泛应用在文件分类，词出现的频率可以用来当作训练分类器的特征。 分布式表示：连续、低维、稠密。word2vec词向量原理并实践，用来表示文本走进FastTextfastText是一个用于学习由Facebook的AI研究实验室创建的文字嵌入和文本分类的库。该模型允许创建无监督学习或监督学习算法以获得单词的向量表示。 FastText的原理它就是一个softmax线性多类别分类器，分类器的输入是一个用来表征当前文档的向量；模型的前半部分，即从输入层输入到隐含层输出部分，主要在做一件事情：生成用来表征文档的向量。那么它是如何做的呢？叠加构成这篇文档的所有词及n-gram的词向量，然后取平均。叠加词向量背后的思想就是传统的词袋法，即将文档看成一个由词构成的集合。 利用FastText模型进行文本分类参考word2vec1：word2vec 中的数学原理详解（一）目录和前言 - peghoty - CSDN博客 word2vec2：word2vec原理推导与代码分析-码农场 word2vec中的数学原理详解（四）基于 Hierarchical Softmax 的模型：word2vec 中的数学原理详解（四）基于 Hierarchical Softmax 的模型 - … fasttext1：GitHub - facebookresearch/fastText: Library for fa… fasttext2：GitHub - salestock/fastText.py: A Python interface… fasttext3 其中的参考：fastText源码分析以及使用 — 相依 A Neural Network Playground]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务五-神经网络基础]]></title>
    <url>%2F2019%2F03%2F11%2Fnlp-task5%2F</url>
    <content type="text"><![CDATA[神经网络前馈神经网络、网络层数、输入层、隐藏层、输出层、隐藏单元、激活函数的概念 前馈神经网络（英文：Feedforward Neural Network），为人工智能领域中，最早发明的简单人工神经网络类型。在它内部，参数从输入层向输出层单向传播。有异于递归神经网络，它的内部不会构成有向环。 感知机利用tensorflow等工具定义简单的几层网络（激活函数sigmoid），递归使用链式法则来实现反向传播 感知器（英语：Perceptron）是Frank Rosenblatt在1957年就职于康奈尔航空实验室（Cornell Aeronautical Laboratory）时所发明的一种人工神经网络。它可以被视为一种最简单形式的前馈神经网络，是一种二元线性分类器。 激活函数激活函数的种类以及各自的提出背景、优缺点。（和线性模型对比，线性模型的局限性，去线性化） 在计算网络中， 一个节点的激活函数定义了该节点在给定的输入或输入的集合下的输出。标准的计算机芯片电路可以看作是根据输入得到开（1）或关（0）输出的数字电路激活函数。这与神经网络中的线性感知机的行为类似。然而，只有非线性激活函数才允许这种网络仅使用少量节点来计算非平凡问题。 在人工神经网络中，这个功能也被称为传递函数。 深度学习中的正则化 参数范数惩罚 L1正则化、L2正则化 数据集增强 噪声添加 early stop Dropout层 深度模型中的优化 参数初始化策略 自适应学习率算法（梯度下降、AdaGrad、RMSProp、Adam；优化算法的选择） batch norm层（提出背景、解决什么问题、层在训练和测试阶段的计算公式） layer norm层。 参考：https://www.wikipedia.org]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务四-传统机器学习]]></title>
    <url>%2F2019%2F03%2F09%2Fnlp-task4%2F</url>
    <content type="text"><![CDATA[朴素贝叶斯的原理基于朴素贝叶斯公式，比较出后验概率的最大值来进行分类，后验概率的计算是由先验概率与类条件概率的乘积得出，先验概率和类条件概率要通过训练数据集得出，即为朴素贝叶斯分类模型，将其保存为中间结果，测试文档进行分类时调用这个中间结果得出后验概率。 利用朴素贝叶斯模型进行文本分类SVM的原理SVM学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。如下图所示 \boldsymbol{w} \cdot x+b=0即为分离超平面，对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。 利用SVM模型进行文本分类pLSA、共轭先验分布；LDA主题模型原理LDA的算法是基于Gibbs Sampling算法的，Gibbs Sampling算法又是基于MCMC的。LDA的目的是获得满足w和z的联合分布的样本点（词的主题）。而Gibbs Sampling就是通过迭代某个维度的条件概率（每个维度对应某个文档的某个位置的词）获得平稳状态，而这平稳状态的分布即这条件概率对应的联合概率。所以我们可以通过这种方法，得到稳定分布的样本点。 使用LDA生成主题特征，在之前特征的基础上加入主题特征进行文本分类参考朴素贝叶斯1：sklearn：朴素贝叶斯（naïve beyes） - 专注计算机体系结构 - CSDN博客 LDA数学八卦 lda2：用LDA处理文本(Python) - 专注计算机体系结构 - CSDN博客 合并特征：Python：合并两个numpy矩阵 - 专注计算机体系结构 - CSDN博客]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务三-特征选择]]></title>
    <url>%2F2019%2F03%2F07%2Fnlp-task3%2F</url>
    <content type="text"><![CDATA[TF-IDF原理tf-idf（英语：term frequency–inverse document frequency）是一种用于信息检索与文本挖掘的常用加权技术。tf-idf是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。tf-idf加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。除了tf-idf以外，互联网上的搜索引擎还会使用基于链接分析的评级方法，以确定文件在搜索结果中出现的顺序。 在一份给定的文件里，词频（term frequency，tf）指的是某一个给定的词语在该文件中出现的频率。这个数字是对词数（term count）的归一化，以防止它偏向长的文件。（同一个词语在长文件里可能会比短文件有更高的词数，而不管该词语重要与否。）对于在某一特定文件里的词语 $t_{i}$ 来说，它的重要性可表示为： \mathrm{tf}_{\mathrm{i}, \mathrm{j}}=\frac{n_{i, j}}{\sum_{k} n_{k, j}}以上式子中 n_{i, j} 是该词在文件 d_{j} 中的出现次数，而分母则是在文件 d_{j} 中所有字词的出现次数之和。逆向文件频率（inverse document frequency，idf）是一个词语普遍重要性的度量。某一特定词语的idf，可以由总文件数目除以包含该词语之文件的数目，再将得到的商取以10为底的对数得到： \mathrm{idf}_{\mathrm{i}}=\lg \frac{|D|}{\left|\left\{j : t_{i} \in d_{j}\right\}\right|}其中$|\mathrm{D}|$ : 语料库中的文件总数 \left|\left\{j : t_{i} \in d_{j}\right\}\right|包含词语 t_{i} 的文件数目（即 n_{i, j} \neq 0 的文件数目） 如果词语不在数据中，就导致分母为零，因此一般情况下使用 1+\left|\left\{j \: t_{i} \in d_{j}\right\}\right| 然后 \operatorname{tfidf}_{\mathrm{i}, \mathfrak{j}}=\mathrm{t} \mathrm{f}_{\mathrm{i}, \mathrm{j}} \times \mathrm{idf}_{\mathrm{i}}某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的tf-idf。因此，tf-idf倾向于过滤掉常见的词语，保留重要的词语。 文本矩阵化，使用词袋模型，以TF-IDF特征值为权重。（可以使用Python中TfidfTransformer库）互信息的原理在概率论和信息论中，两个随机变量的互信息（Mutual Information，简称MI）或转移信息（transinformation）是变量间相互依赖性的量度。不同于相关系数，互信息并不局限于实值随机变量，它更加一般且决定着联合分布 p(X,Y) 和分解的边缘分布的乘积 p(X)p(Y) 的相似程度。互信息是点间互信息（PMI）的期望值。互信息最常用的单位是bit。 一般地，两个离散随机变量 X 和 Y 的互信息可以定义为： I(X ; Y)=\sum_{y \in Y} \sum_{x \in X} p(x, y) \log \left(\frac{p(x, y)}{p(x) p(y)}\right)其中 p(x,y) 是 X 和 Y 的联合概率分布函数，而 $p(x)$ 和 $p(x)$ 分别是 X 和 Y 的边缘概率分布函数。 在连续随机变量的情形下，求和被替换成了二重定积分： I(X ; Y)=\int_{Y} \int_{X} p(x, y) \log \left(\frac{p(x, y)}{p(x) p(y)}\right) d x d y其中 p(x,y) 当前是 X 和 Y 的联合概率密度函数，而 $p(x)$ 和 $p(x)$ 分别是 X 和 Y 的边缘概率密度函数。 如果对数以 2 为基底，互信息的单位是bit。 直观上，互信息度量 X 和 Y 共享的信息：它度量知道这两个变量其中一个，对另一个不确定度减少的程度。例如，如果 X 和 Y 相互独立，则知道 X 不对 Y 提供任何信息，反之亦然，所以它们的互信息为零。在另一个极端，如果 X 是 Y 的一个确定性函数，且 Y 也是 X 的一个确定性函数，那么传递的所有信息被 X 和 Y 共享：知道 X 决定 Y 的值，反之亦然。因此，在此情形互信息与 Y（或 X）单独包含的不确定度相同，称作 Y（或 X）的熵。而且，这个互信息与 X 的熵和 Y 的熵相同。（这种情形的一个非常特殊的情况是当 X 和 Y 为相同随机变量时。） 互信息是 X 和 Y 的联合分布相对于假定 X 和 Y 独立情况下的联合分布之间的内在依赖性。 于是互信息以下面方式度量依赖性：I(X; Y) = 0 当且仅当 X 和 Y 为独立随机变量。从一个方向很容易看出：当 X 和 Y 独立时，p(x,y) = p(x) p(y)，因此： \log \left(\frac{p(x, y)}{p(x) p(y)}\right)=\log 1=0此外，互信息是非负的（即 I(X;Y) ≥ 0; 见下文），而且是对称的（即 I(X;Y) = I(Y;X)）。 使用第二步生成的特征矩阵，利用互信息进行特征筛选。参考文本挖掘预处理之TF-IDF：文本挖掘预处理之TF-IDF - 刘建平Pinard - 博客园 使用不同的方法计算TF-IDF值：使用不同的方法计算TF-IDF值 - 简书 sklearn-点互信息和互信息：sklearn：点互信息和互信息 - 专注计算机体系结构 - CSDN博客 如何进行特征选择（理论篇）机器学习你会遇到的“坑”：如何进行特征选择（理论篇）机器学习你会遇到的“坑”]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务三-决策树算法梳理]]></title>
    <url>%2F2019%2F03%2F05%2Fbasic-task3%2F</url>
    <content type="text"><![CDATA[信息论基础（熵 联合熵 条件熵 信息增益 基尼不纯度）熵本是热力学中表征物质状态的参量之一，用符号S表示，其物理意义是体系混乱程度的度量。对于机器学习算法来说，熵指代香农熵，是一种不确定性度量。它是表示随机变量不确定的度量，是对所有可能发生的事件产生的信息量的期望。 联合熵联合熵就是度量一个联合分布的随机系统的不确定度。 条件熵条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性。 信息增益表示特征X使得类Y的不确定性减少的程度。（分类后的专一性，希望分类后的结果是同类在一起）其中 I 为不纯度的度量，关于 N 的计算是划分后的个数加权。I 为熵（Entropy）的时候，Delta 为信息增益。 基尼不存度基尼不存度是指来自集合的某种结果随机应用于集合中某一数据的预期误差。（如果集合中所有结果属于同一类，则误差为0） 决策树的不同分类算法（ID3算法、C4.5、CART分类树）的原理及应用场景ID3算法内部使用信息熵以及信息增益来进行构建,每次迭代选择信息增益最大的特征属性作为分割属性。只支持离散的特征属性 优点：决策树构建速度快，实现简单 缺点：算法依赖样本中出现次数较多的特征属性,但是出现次数最多的属性并不一定最优 C4.5算法使用信息增益率来构建,在树的构建过程中会进行剪枝操作的优化,能够自动完成对连续属性的离散化处理。选择信息增益率大的属性进行分割 优点：准确率较高,实现简单 缺点：对数据集需要进行多次顺序扫描和排序,效率较低。 CART算法使用基尼系数作为数据纯度的量化指标来构建,选择GINI增益率来分割，越大的即作为当前数据集的分割属性.可用于分类和回归。（二叉树构建） 回归树原理决策树防止过拟合手段剪枝是决策树学习算法对付过拟合的主要手段。决策树剪枝的基本策略有“预剪枝”和“后剪枝”。 预剪枝指在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶节点。 后剪枝指先从训练集生成一颗完整的决策树，然后自底向上地对非结点进行考察，若讲该结点对应的子树替换成叶节点能带来决策树泛化性能的提升，则将该子树替换成叶节点。 模型评估自助法（bootstrap）：训练集是对于原数据集的有放回抽样，如果原始数据集N，可以证明，大小为N的自助样本大约包含原数据63.2%的记录。当N充分大的时候，1-（1-1/N）^(N) 概率逼近 1-e^(-1)=0.632。抽样 b 次，产生 b 个bootstrap样本，则，总准确率为（accs为包含所有样本计算的准确率。 准确度的区间估计：将分类问题看做二项分布，则有：令 X 为模型正确分类，p 为准确率，X 服从均值 Np、方差 Np（1-p）的二项分布。acc=X/N为均值 p，方差 p（1-p）/N 的二项分布。acc 的置信区间： sklearn参数详解，Python绘制决策树123456789101112DecisionTreeRegressor(criterion=“mse”, splitter=“best”, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0., max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0., min_impurity_split=None, presort=False) 参数含义criterion:string, optional (default=“mse”)它指定了切分质量的评价准则。默认为’mse’(mean squared error)。 splitter:string, optional (default=“best”)它指定了在每个节点切分的策略。有两种切分策咯： splitter=‘best’:表示选择最优的切分特征和切分点。 splitter=‘random’:表示随机切分。 max_depth:int or None, optional (default=None)指定树的最大深度。如果为None，则表示树的深度不限，直到每个叶子都是纯净的，即叶节点中所有样本都属于同一个类别，或者叶子节点中包含小于min_samples_split个样本。 min_samples_split:int, float, optional (default=2)整数或者浮点数，默认为2。它指定了分裂一个内部节点(非叶子节点) 需要的最小样本数。如果为浮点数(0到1之间)，最少样本分割数为ceil(min_samples_split * n_samples) min_samples_leaf:int, float, optional (default=1)整数或者浮点数，默认为1。它指定了每个叶子节点包含的最少样本数。 如果为浮点数(0到1之间)，每个叶子节点包含的最少样本数为ceil(min_samples_leaf * n_samples) min_weight_fraction_leaf:float, optional (default=0.)它指定了叶子节点中样本的最小权重系数。默认情况下样本有相同的权重。 max_feature:int, float, string or None, optional (default=None)可以是整数，浮点数，字符串或者None。默认为None。 如果是整数，则每次节点分裂只考虑max_feature个特征。 如果是浮点数(0到1之间)，则每次分裂节点的时候只考虑int(max_features * n_features)个特征。 如果是字符串’auto’,max_features=n_features。 如果是字符串’sqrt’,max_features=sqrt(n_features)。 如果是字符串’log2’,max_features=log2(n_features)。 如果是None，max_feature=n_feature。 random_state:int, RandomState instance or None, optional (default=None) 如果为整数，则它指定了随机数生成器的种子。 如果为RandomState实例，则指定了随机数生成器。 如果为None，则使用默认的随机数生成器。 max_leaf_nodes:int or None, optional (default=None) 如果为None，则叶子节点数量不限。 如果不为None，则max_depth被忽略。 min_impurity_decrease:float, optional (default=0.)如果节点的分裂导致不纯度的减少(分裂后样本比分裂前更加纯净)大于或等于min_impurity_decrease，则分裂该节点。 min_impurity_split:float树生长过程中早停止的阈值。如果当前节点的不纯度高于阈值，节点将分裂，否则它是叶子节点。这个参数已经被弃用。用min_impurity_decrease代替了min_impurity_split。 presort： bool, optional (default=False)指定是否需要提前排序数据从而加速寻找最优切分的过程。设置为True时，对于大数据集会减慢总体的训练过程；但是对于一个小数据集或者设定了最大深度的情况下，会加速训练过程。 属性feature_importances: array of shape = [n_features]特征重要性。该值越高，该特征越重要。特征的重要性为该特征导致的评价准则的（标准化的）总减少量。它也被称为基尼的重要性 maxfeature: intmax_features推断值。 nfeatures：int执行fit的时候，特征的数量。 noutputs : int执行fit的时候，输出的数量。 Notes 控制树大小的参数的默认值（例如max_depth，min_samples_leaf等）导致完全成长和未剪枝的树，这些树在某些数据集上可能表现很好。为减少内存消耗，应通过设置这些参数值来控制树的复杂度和大小。 方法decision_path(X)返回X的决策路径 fit(X, y)在数据集(X,y)上使用决策树模型 get_params([deep])获取模型的参数 predict(X)预测数据值X的标签 predict_log_proba(X)返回每个类别的概率值的对数 predict_proba(X)返回每个类别的概率值（有几类就返回几列值） score(X,y)返回给定测试集和对应标签的平均准确率 参考资料西瓜书 cs229吴恩达机器学习课程 李航统计学习 谷歌搜索]]></content>
      <categories>
        <category>初级算法梳理</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务二-特征提取]]></title>
    <url>%2F2019%2F03%2F05%2Fnlp-task2%2F</url>
    <content type="text"><![CDATA[基本文本处理技能分词的概念（分词的正向最大、逆向最大、双向最大匹配法）；正向最大匹配法对句子从左到右进行扫描，尽可能地选择与词典中最长单词匹配的词作为目标分词，然后进行下一次匹配。 逆向最大匹配法对句子从右到左进行扫描，尽可能地选择与词典中最长单词匹配的词作为目标分词，然后进行下一次匹配。 双向最大匹配法将正向最大匹配算法和逆向最大匹配算法进行比较，从而确定正确的分词方法。 词、字符频率统计；（可以使用Python中的collections.Counter模块，也可以自己寻找其他好用的库）语言模型语言模型中unigram、bigram、trigram的概念unigram一元分词，把句子分成一个一个的汉字 bigram二元分词，把句子从头到尾每两个字组成一个词语 trigram三元分词，把句子从头到尾每三个字组成一个词语 unigram、bigram频率统计可以使用Python中的collections.Counter模块，也可以自己寻找其他好用的库 文本矩阵化：要求采用词袋模型且是词级别的矩阵化词向量矩阵生成按照以下过程： 加载数据集 分词 生成词汇表 生成word_index 加载预训练词向量模型 生成词向量矩阵 分词（可采用结巴分词来进行分词操作，其他库也可以）；去停用词；构造词表。 每篇文档的向量化。 参考结巴分词介绍和使用：GitHub - fxsjy/jieba: 结巴中文分词]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week4-8 Conclusion 结论]]></title>
    <url>%2F2019%2F03%2F04%2Fweek4-08-conclusion%2F</url>
    <content type="text"><![CDATA[恭喜您收到本课程的最后一个视频。 人工智能是一种超级大国，理解它可以让你做到这个星球上很少有人可以做到的事情。 让我们总结一下本课程中的内容。 在第一周，您学习了人工智能技术，什么是人工智能，什么是机器学习？ 什么是监督学习，即学习输入，输出或A到B映射。 什么是数据符号，以及数据如何提供给所有这些技术？ 重要的是，您还看到了AI能做什么和不能做什么的例子。 在第二周，您了解了构建AI项目的感觉。 您看到了机器学习项目的工作流程，收集数据，构建系统和部署它，以及数据科学项目的工作流程。 在您承诺开展特定的AI项目之前，您还学习了如何进行技术培训以确保项目可行，并与业务尽职调查以确保项目有价值。 在第三周，您了解了这些AI项目如何适应您公司的环境。 您看到了复杂AI产品的例子，例如智能扬声器，自动驾驶汽车，大型AI团队的角色和责任。 你还看到了人工智能转型手册，这是帮助公司成为一家伟大的人工智能公司的五步手册。 我希望这些材料能够在前三周内帮助您集体讨论AI项目或思考如何在公司或组织中使用AI。 在本周，第四周，您了解了人工智能和社会。 您已经看到了AI的一些限制，仅仅是技术限制，还了解了AI如何影响全球发展经济和就业。 你在这四周学到了很多东西，但人工智能是一个复杂的话题。 因此，我希望您继续学习，无论是通过其他在线课程，还是通过Coursera或deeplearning。 ai，或书籍，或博客，或只是通过与朋友交谈。 如果您想尝试构建AI技术，那么现在可以更轻松地学习编码并学习如何通过这些资源实现AI技术。 如果您想继续接收有关AI的信息，您也可以通过deeplearning.ai网站注册deeplearning.ai邮件列表并在那里注册。 我偶尔会通过该邮件列表向您发送有关AI的有用信息。 恭喜你完成这门课程。 现在，您已经明显领先于许多大公司的首席执行官，因为您了解人工智能以及您计划推动人工智能发展的能力。 因此，我希望您为其他人提供领导力，以便解决这些问题。 最后，我想对你说，非常感谢你选修这门课程。 我知道你忙于自己的工作或学校，朋友和家人，我很高兴你花了这么多时间和我一起学习这些与技术和人工智能影响有关的复杂问题。 非常感谢您在本课程中花费的时间和精力。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week4-7 AI and jobs 人工智能和工作]]></title>
    <url>%2F2019%2F03%2F04%2Fweek4-07-ai-and-jobs%2F</url>
    <content type="text"><![CDATA[AI是类固醇的自动化。 在现代人工智能兴起之前，自动化已经对很多工作产生了巨大的影响。 随着人工智能的兴起，我们现在可以实现自动化的一系列事物突然比以前大得多，因此这也对工作产生了加速的影响。 将有多少工作岗位流离失所？将创造多少新工作岗位？我认为任何人都没有对这些问题有坚定的答案，但让我们看看一些研究，试图了解可能会有什么进展。 麦肯锡全球研究院进行了一项研究，估计到2030年将有2亿至8亿个工作岗位被自动化系统取代。 这些是非常大的数字。 另一方面，同样的报告也估计AI可能创造的工作岗位数量更多。 除了麦肯锡全球研究院之外，还有很多研究。 这些工作岗位数量和创造的工作岗位数量估计有一个范围。 例如，只关注美国，这张幻灯片的数字在全球范围内，但我们这里只关注美国，普华永道估计到2030年将有大约1600万人流失。 英格兰银行估计到2035年将有8000万个工作岗位被移除。 因此，没有人能够确切地预测到2030年究竟会发生什么，但是有一种观点认为全球就业的影响将是巨大的。 我希望你发现它令人鼓舞，尽管人工智能正在创造许多工作，即使它取代了一些工作。 我认为未来的许多工作，我们甚至可能都没有名称，无论是无人机流量优化器还是3D打印的服装设计师，就像医疗保健一样，我们将拥有基于定制DNA的药物设计师。 因此，即使人们担心人工智能取代工作，也有许多新工作的希望，甚至可能在未来创造更多的新工作岗位。 现在您可能想知道，我们如何估计有多少工作可能被取代？这些研究的一种典型方式是找工作并考虑构成工作的任务。 例如，您可能会查看放射科医师的任务，或查看出租车司机所做的所有任务。 然后，对于每个任务，估计如何通过AI进行自动化是否合适，如果作业主要包括高度自动化的任务，那么替换作业的风险将更高。 大多数人工智能工程师发现将AI应用于任务而不是人们的工作更有用。 但是这个框架允许我们使用AI的能力来自动化任务，以估计可能有多少工作被取代。 那么最有可能或最不可能通过人工智能和自动化取代的工作是什么呢？经济合作与发展组织是一个备受尊重的政府间机构，它研究了工作类型的数量，以估算其中哪些类型最多，最不可能实现自动化。 未来肯定会有严格的预测，但也许并不奇怪，许多其他包含更多日常重复性工作的工作更适合自动化，而许多重复性较低，日常工作较少或涉及与人们进行更多社交互动的工作可能不太容易实现自动化。 我们如何在人工智能对工作的影响中发挥作用？以下是一些解决方案。 一，有条件的基本收入。 你可能听说过普通的基本收入，政府会向没有附加条件的公民付款。 我认为人们会去安全网。 对于那些失业但能够学习的人，我认为更有效的转变可能是有条件的基本收入，我们确实提供了安全网，但也要求他们继续学习并继续投资自己的发展。 通过提供一个结构来帮助那些可以学习的人，这将增加这些人进入劳动力队伍，为自己，家庭和社会做出贡献的可能性，以及为这一切付出代价的科技空间。 第二，建立终身学习型社会。 由于你现在正在学习这门课程，你可能已经成为这个终身学习社会的一部分。 旧的教育模式，你上大学四年，然后花费剩余的40，这不再适用于这些快速变化的世界。 通过政府，公司和个人意识到所有人都需要继续学习，这增加了每个人都有更好的地位的可能性，即使工作可能会消失。 因此，也要利用正在创建的新工作。 在未来，即使在完成大学学业之后，我认为大多数人应该在整个生命中继续学习。 最后，还有一些政治解决方案正在探索中。 从激励人员帮助创造新的就业机会到立法，确保人们得到公平对待。 我希望社会能够找到正确的政治解决方案，以应对人工智能对工作的影响。 现在有时会问的一个问题是，如果你想在人工智能中工作，你应该怎么做？最近，一位放射科医生在他职业生涯开始时为放射科医师服务。 他居然问我。 他说：“嘿，Andrew，我听到很多关于AI对放射学的影响。“ 他说，”我应该放弃我的职业，只是学习AI并做AI吗？“我对他的回答不是。 你可以这样做。 你可以实际上无论你在做什么，从头开始拾取AI。 完全可以做到这一点。 很多人都这样做了。 这是另一个你可以考虑的另一种选择，也就是说，我对这位放射学家说过，考虑做人工智能和放射学的工作，因为你知道放射学，如果你还学到了关于人工智能的东西，你会更好地安置在放射学的交叉点上工作和AI比其他大多数人一样。 所以，如果你想在AI中做更多的工作，那么今天的世界可以通过在线课程和其他资源从零开始学习AI。 但是如果你采取任何你已经掌握的知识并学习一些人工智能和你的区域以及人工智能，那么通过将AI应用到你已经是专家的任何领域，你可能更有资格从事有价值的工作。 所以，我希望这个视频可以帮助您了解AI在工作中的影响。 让我们继续本课程的下一个最终视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week4-6 AI and developing economies 人工智能和发展中经济体]]></title>
    <url>%2F2019%2F03%2F04%2Fweek4-06-ai-and-developing-economies%2F</url>
    <content type="text"><![CDATA[每次出现诸如人工智能这样的技术性破坏时，它都会让我们有机会重塑这个世界。 人工智能是一项非常先进的技术，是对发达经济体和发展中经济体的影响。 那么，我们怎样才能确保即使人工智能创造了巨大的财富，它也能提升所有国家？让我们一起来看看。 有一个相当可预测的路线图，几乎是一个阶梯，许多发展经济已成功执行，以帮助公民获得技能并攀升到更高的财富水平。 所有国家都开始使用低端农产品，出口农作物，然后转向低端纺织品制造业，如服装制造业。 然后，随着人口开始获得更多财富，变得更健康，转向低端组件制造，例如制造价格低廉的塑料零件。 那么，接下来转向低电子制造，高端电子制造，也许转向汽车制造，等等。 正是这种逐步发展，发展经济体可以希望其公民获得技能并成为经济发达国家。 AI可能导致的一个问题是，梯子的许多较低的梯度特别容易通过AI实现自动化。 例如，随着工厂变得更加自动化，或者随着农业变得更加自动化，可能需要更少的机会，因此这些经济发展中的一些人口中的大部分成员进入经济阶梯的较低阶段的机会较少，然后他们会从中爬升。 因此，如果我们通过人工智能淘汰梯子的一些较低的梯级，通过人工智能提供类固醇自动化，那么我们有责任看看AI是否可以创建一个蹦床以希望一些发展中经济体跳上蹦床然后反弹更快到达这个阶梯的最高阶段。 随着早期技术浪潮的兴起，许多经济体已经表明它们可以超越发达经济体并直接转向更先进的技术。 例如，在美国，我们大多数人都有固定电话。 通过电线连接到墙上的电话。 因为有这么多美国固定电话，实际上需要一段时间才能过渡到无线移动电话。 相比之下，许多发展中的经济体，包括印度和中国的许多其他经济体，并没有费心去建立尽可能多的陆地线，而是直接跳过手机。 因此，这是一个跨越式发展经济体直接冲击上一代技术，并没有费心在每个人的家里铺设如此多的物理电缆，而是直接跳到手机上。 我们看到移动支付的类似情况，许多发达经济体拥有成熟的信用卡系统，与一些尚未在信用卡行业拥有根深蒂固的现有经济体的发展中经济体相比，实际上正在放慢对移动或手机支付的采用。 我也看到在线教育发展中经济体的迅速普及。 在尚未建立所有许多物理学校和大学所需要的国家，许多教育领导者和政府正在寻求更加快速地接受在线教育的方法，而不是那些具有这种建立 - 体育教育基础设施的发展经济学。 虽然发展经济也迅速包含所有这些技术，但发展中经济体的优势之一是，如果没有一个根深蒂固的计算机系统，也许有些领域可以更快地建设。 美国和中国处于领先地位，英国和加拿大以及其他一些国家也拥有充满活力的人工智能社区。 但由于人工智能今天仍然不成熟，我认为所有人工智能社区仍然不成熟。 这意味着即使人工智能正在创造巨大的经济价值，但未来创造的大部分价值仍然存在。 这使得每个国家都有机会成为创造这个尚未创造的价值的重要组成部分，甚至可以捕获大部分价值。 因此，我希望每个国家都能找到如何有效地使用人工智能来继续希望他的公民。 我对发展经济的建议是关注人工智能以加强国家的垂直行业。 例如，我认为今天的大多数国家不应该尝试建立自己的网络搜索引擎。 已经有很多网络搜索引擎，这是最后几十年的竞争。 相反，如果一个国家的咖啡豆制造业拥有非常强大的垂直行业，那么该国实际上有资格在人工智能工作中从事咖啡制造工作，而建立人工智能咖啡制造业甚至可以进一步加强该国已经擅长的目标。 因此，我建议大多数国家使用人工智能来加强该国擅长的国家以及该国未来要做的事情，而不是要求一般国家与美国和中国人工智能竞争。 最后，公私合作关系，即政府和企业合作，可以真正帮助加快垂直行业的发展。 在受到严格监管的行业中，从医疗保健到自驾车等运输，再到融资，我们都希望获得某些成果，以及我们不想要的某些成果。 那些致力于制定衍生规则以保护公民的政府，同时能够在这些行业中采用人工智能解决方案，将会看到更快的地方经济增长以及在其国家内更快的技术发展。 最后，发展经济应该投资于教育，因为AI仍然是如此不成熟。 每个国家都有足够的空间容忍更多人工智能，甚至可能建立自己的工作人员队伍，并在我们正在建设的人工智能世界中以重要方式参与。 在技​​术中断的时刻，领导力很重要。 在美国，我们曾经相信我们的政府会把一个人放在月球上并且有效。 随着人工智能的兴起，它创造了一个空间，在一些国家需要领导，无论是在政府层面，还是在公司，或在教育中帮助一个国家进入人工智能时代，拥抱和采用人工智能来不断提升其公民，甚至可能继续在世界范围内提升其他人。 在这段视频中，我们简要介绍了人工智能和工作问题。 这是目前在许多国家广泛讨论的一个重要的主题。 让我们继续下一个视频，深入了解人工智能和工作。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week4-5 Adverse uses of AI 人工智能的不利用途]]></title>
    <url>%2F2019%2F03%2F04%2Fweek4-05-adverse-uses-of-ai%2F</url>
    <content type="text"><![CDATA[人工智能非常强大，人工智能的绝大多数用户正在使人，公司，国家和社会变得更好。 但是人工智能也存在一些不良现象。 我们来看看其中的一些并讨论我们可以对它们做些什么。 人工智能技术已被用于创建深度伪造，这意味着合成人们做事情的视频，而这些事情从未真正做过。 BuzzFeed网站创建了一个美国前总统巴拉克奥巴马的视频，说他从未做过的事情。 BuzzFeed对此很透明，当他们发布视频时，很明显，因为他告诉大家这是一个虚假的视频。 但是，如果这种类型的技术被用来瞄准一个人，并让别人认为他们说或做过他们从未真正做过的事情，那么这些人可能会受到伤害并留下来防止视频证据显示他们实际上做过的事情。 类似于垃圾邮件与反垃圾邮件的战争，今天有一种人工智能技术用于检测视频是否是一种深刻的伪造。 但在今天的社交媒体世界中，假冒可能在真相可以赶上前在世界范围内传播的速度更快，，很多人都担心深陷伤害个人的可能性。 还有一种风险是使用AI技术来破坏民主和隐私。 例如，世界上许多政府都在努力改善他们的公民生活，并且非常尊重提升他们公民的政府领导人。 但也有一些压迫性的政权没有做公民正确的事情，可能会试图利用这种技术对其公民进行压迫性监视。 虽然政府有改善公共安全和减少犯罪的必要性，但也有使用人工智能的方式比自己的公民更令人沮丧。 与此密切相关的是人工智能可以产生的虚假评论的兴起。 现在可以使用AI技术生成评论。 无论是在商业方面，对产品的虚假评论，还是在政治话语中，对公共话语中的政治问题进行虚假评论，以及产生虚假评论的效率要高于只有人类写作的假评论。 因此，检测这些假冒产品并清除它们是一种重要的技术，可以保持对我们可以在线阅读的评论的信任。 类似于反垃圾邮件与反垃圾邮件和诈骗反欺诈的斗争，我认为对于所有这些问题，双方可能会在未来一段时间内进行竞争。 类似于斯潘与反垃圾邮件，欺诈与反欺诈的斗争，我对这些战斗将如何发挥作用持乐观态度。 因为如果你以过滤过滤器为例，那么有更多的人有动力确保垃圾邮件过滤器能够正常工作，反垃圾邮件确实有效。 然后有较少数量的垃圾邮件发送者试图将此垃圾邮件发送到您的收件箱。 因此，在反垃圾邮件方面，垃圾邮件方面有更多的资源。 因为社会实际上功能更好，如果反垃圾邮件和反欺诈运作良好。 因此，即使AI社区还有很多工作要做，以防范这些不利的用例。 因为社会是最好的，如果我们能够很好地利用人工智能，我乐观地认为资源的平衡意味着善意的一面将占上风，但是在未来的几年里，人工智能社区仍然需要做很多工作。 接下来，人工智能也对发展经济产生了重大影响。 我们来看看下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week4-4 Adversarial attacks on AI 对人工智能的对抗性攻击]]></title>
    <url>%2F2019%2F03%2F04%2Fweek4-04-adversarial-attacks-on-ai%2F</url>
    <content type="text"><![CDATA[尽管现代AI具有令人难以置信的强大功能，但现代AI技术的局限性之一，尤其是深度学习，有时候它可能会被愚弄。 特别是，现代人工智能系统有时会受到对抗性攻击，如果其他人故意故意将人工智能系统用于人工智能系统。 让我们来看看。 让我们给你一个人工智能系统，这张鸟的图片并将其分类。 AI系统输出这是一只蜂鸟。 但是让我们对这张图片做一个小的微观。 通过微小的扰动，我的意思是稍微改变像素值，并且对大多数人来说几乎难以察觉。 相同的AI系统然后说这是锤子。 现在，对于你可能会说，“这怎么可能，右边的图片看起来几乎与左边的图片相同？”事实上，这些变化几乎让人眼不易察觉。 但是人工智能系统对你和我的看法与世界截然不同。 因此，如果对手对你和我不可察觉的图片做出改变，那么它很容易受到影响，但是他们愚弄人们认为这张照片有点不同。 我们称之为人工智能系统的对抗性攻击。 在计算机安全性中，对安全系统的攻击意味着尝试使其执行除了预期之外的其他操作。 同样地，AI系统上的对抗性攻击试图做出除了它想要做的事情以外的其他事情，例如试图欺骗它输出不正确的分类。 这是另一个例子。 这是一张野兔的照片，只是轻微的扰动或像素值的微小变化，而AI则说这是一张桌子。 计算机看到图片与人类不同的事实，给它带来了优点和缺点。 例如，在阅读条形码和QR码时，计算机系统比你和我好得多。 但是，深度学习系统工作的方式也让我们接触到这些特殊形式的攻击，这些攻击都不会被人类所愚弄。 今天，人工智能被用来过滤掉垃圾邮件，试图过滤掉仇恨言论，而攻击这些过滤器会降低这些过滤器的效率。 现在，对此幻灯片的攻击需要能够直接对图像进行修改。 例如，垃圾邮件发送者可能会在尝试将图像上传到网站或通过电子邮件发送之前直接修改图像。 还有一些攻击通过改变物理世界来发挥作用。 例如，Carnegie Mellon大学的一个小组能够设计出像这样的时髦眼镜。 因此，当他戴上这副眼镜的时候，他可以欺骗人工智能系统，让他觉得他是Mact Jovovich。 我认为戴上这样一副眼镜可以欺骗AI系统让人觉得这个男人是众所周知的女演员。 来自加州大学伯克利分校，密歇根大学和其他大学的另一组研究人员表示，如果你影响像这样的贴纸停止标志，你可以欺骗AI系统根本看不到停车标志。 除了停车标志之外还有别的东西。 关于这个例子的一个有趣的事情是它看起来像停车标志只是在它上面涂了一些涂鸦。 大多数人仍然会很容易将此视为停车标志。 但是，如果你有一个内置于自动驾驶车中的计算机视觉系统，那么如果汽车不再停止停车标志将是非常不幸的，因为这些贴纸应用在它上面。 最后一个例子，这是来自Google的一组研究人员，如果你向人工智能系统展示这张图片，它会说这是一个香蕉。 但是研究人员在设计贴纸的过程中，如果你放置到场景中，它会错误地分类这个香蕉。 让我告诉你研究人员制作的录像带。 左边显示的是分类器输入，右边显示的是分类器输出，它认为很可能是香蕉，也许是一个很小的机会。 看起来没问题。 让我们看看当你贴上贴纸或在场景中放一个小补丁时会发生什么。 当贴纸放置在场景中时，AI系统现在几乎可以肯定这张照片是烤面包机的照片。 这项工作的一个有趣的方面是本文的作者在本幻灯片的底部引用，实际上在他们的论文中发表了他们贴纸的图片。 所以，世界上的任何人都可以假设地下载他们的纸张，打印出贴纸，如果他们想要欺骗AI系统认为那里有一个没有的烤面包机，就把它贴在某处。 现在，我不支持任何人攻击AI系统来欺骗他们认为烤面包机在那里或没有，但不幸的是，这显示了人们可以轻易地假装这些AI系统。 我们可以做些什么来抵御这些对抗性攻击？幸运的是，人工智能世界一直致力于开发新技术，以便更难以攻击。 防御往往非常技术性，但有一些方法可以修改神经网络和其他人工智能系统，以使攻击更加困难。 一个缺点是这些缺陷确实会产生一些成本。 例如，AI系统可能运行得慢一点。 但这是一个正在进行研究的领域，我们远没有那些对我们想要应用AI的所有重要应用程序看起来足够好的重型对抗性攻击。 对于许多人工智能系统，可能没有任何激励试图攻击它。 例如，如果您正在运行自动视觉检测系统，以检查咖啡杯是否在您的工厂中有划痕。 也许不是那些有动力试图欺骗你的系统去思考刮刮咖啡杯的人们也没有刮擦它。 但是，人工智能应用程序也会受到攻击。 对于那些应用程序，我认为类似于垃圾邮件与反垃圾邮件，垃圾邮件发送者正在尝试通过垃圾邮件过滤器和垃圾邮件过滤器试图阻止它们。 我认为我们将在军备竞赛中应用，因为人工智能社区正在加强防御，并且有一个攻击行为的社区来愚弄我们的防御。 在我构建人工智能系统的经验中，我觉得自己与其他人完全交战的次数之一就是当我领导反欺诈团队对抗部队时。 不幸的是，互联网上存在大量欺诈行为，人们试图窃取金钱和支付系统或创建欺诈性账户。 我在反欺诈系统上工作的次数是它真正感觉像零和游戏的几次之一，有一个对手，我们会提出防御，他们会做出反应。 他们会发动攻击，我的团队必须做出反应。 有时甚至几个小时来保护自己。 因此，我认为在接下来的几年中，即使在技术发展过程中，也会出现像垃圾邮件这样的垂直行业，就像欺诈行为将会发生战争一样。 在我对对手的零和游戏中感觉如此。 话虽如此，我也不想过度夸大对象AI系统的潜在损害。 这对某些应用程序非常重要。 但也有大量的应用程序不太可能受到对抗性攻击。 现在，除了对抗性攻击外，不幸的是，AI还可以用于一些不利的负面用例。 让我们在下一个视频中看看它们中的一些以及我们应该解决它们的问题。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week4-2 A realistic view of AI 人工智能的现实观点]]></title>
    <url>%2F2019%2F03%2F04%2Fweek4-02-a-realistic-view-of-ai%2F</url>
    <content type="text"><![CDATA[人工智能正在对社会和许多人的生活产生巨大影响。 所以，对于我们所有人做出好的决定，重要的是我们要有一个现实的人工智能观，既不太乐观，也不太悲观。 这就是我的意思。 你有没有读过金发姑娘和三只熊的故事。 故事的一部分是，一碗粥不应该太热也不能太冷，abed既不应该太坚硬也不应该太软。 我认为我们需要一个类似的人工智能的Gililocks规则，我认为重要的是我们对AI技术能做什么或不能做什么既不过于乐观也不过于悲观。 例如，我们不应该对AI技术过于乐观，对人工智能技术持不切实际的看法可能会让人们认为很快就会出现感知或超级智能，人工，一般智能，我们应该投入大量资源来防御反邪恶的杀手机器人。 我认为做一些研究来思考如果人工智能在某一天有所改变，那么遥远的未来会是什么样子并没有错。 做基础研究确实不是问题，但我们不应过度分配资源，以防止实际上不会长期存在的危险。 也许几十年，也许几百年。 我认为对感知，超级情报，人工一般情报的不必要的恐惧正在分散人们对真实问题的注意力，并且在社会的某些部分也引起了对艾滋病的不必要的恐惧。 另一方面，我们也不想对AI进行操作。 人工智能的极端悲观主义观点是人工智能无法做到的一切。 有些东西是不能做的，所以，另一个AI冬天来了。 AI冬季这个术语指的是当人工智能被过度炒作时，以及当人们发现人工智能无法完成他们想到的所有事情时，会发生几次剧情。 这导致了人工智能的丧失和人工投资的减少。 人工智能现在和几十年前的早期冬天之间的一个区别是，今天的人工智能正在创造巨大的经济价值。 我们也看到了一条令人惊讶的明确路径，它继续在多个行业中创造更多价值。 因此，这两件事的结合确保AI在可预见的未来将继续增长。 尽管如此，AI也无法做到。 我对金发姑娘的故事并没有过于乐观或过于悲观，而是了解到中间的事情恰到好处。 我认为我们现在意识到，人工智能无法做到。 事实上，有一个不可能但它会改变行业和社会。 当你和AI的朋友交谈时，我希望你也告诉他们关于AI的这个Goldilocksrule，所以，他们也可以有更真实的人工智能观。 AI存在许多局限性。 您之前已经看到了一些性能限制。 例如，给予少量数据，纯粹的AI可能无法完全自动化呼叫中心，并对任何客户提供非常灵活的响应。 但AI也有其他限制。 AI的局限性之一是可解释性很难，许多高性能的AI系统都是黑盒子。 这意味着它工作得很好，但AI不知道如何解释它为什么会这样做。 这是一个例子。 假设您有一个AI系统，请查看此X射线图像，以诊断患者是否有任何错误。 在这个例子中，一个原始的例子，A​​I系统说它认为患者有右侧气胸。 这意味着右肺塌陷了。 但我们怎么知道AI是否正确，你怎么知道你是否应该相信AI系统的诊断。 在制作AI系统方面做了很多工作。 在这个例子中，热图是AI告诉我们它正在查看图像的哪些部分以便进行诊断。 因为它显然是基于右肺的诊断，实际上是右肺的一些关键特征。 看到这张图片可能会让人更有信心AI正在做出合理的诊断。 现在，公平地说，人类也不太善于解释我们如何自己做出决定。 例如，你在过去几周的视频中已经看过这个咖啡杯，但你怎么知道这是一个咖啡杯？ 人们如何看待这个并说，这是一个咖啡杯？ 你知道有一些你可以指出的东西，有一个液体的空间，它有一个手柄。 但是我们人类不善于解释，我们如何看待它并决定它是什么。 但是因为人工智能是一个相对较新的东西，缺乏可解释性有时候会被接受。 此外，有时如果AI系统不能正常工作，那么它解释自身的能力也会帮助我们弄清楚如何进入并让AI系统更好地工作。 因此，可解释性是主要的开放研究领域之一。 很多研究人员都在努力。 我在实践中看到的是，当AI团队想要部署某些东西时，AI团队必须经常能够提出足够好的解释来使系统能够进行部署。 因此，可解释性是温床，它通常并非不可能但我们确实需要更好的工具来帮助AI系统解释自己。 AI有一些其他的限制。 作为一个社会，我们不希望基于他们的种族歧视基于性别的个人，我们希望人们得到公平对待。 但是，当人工智能系统被输入的数据不能反映这些值时，人工智能就会变成偏见，或者可以学会区别对待某些人。 人工智能社区正在努力工作，并在这些问题上取得了很好的进展，但我们还远未完成，而且还有很多工作要做。 您将在下一个视频中了解有关偏向AI的更多信息，以及如何确保您使用的AI系统偏向性较小的一些想法。 最后，许多人工智能系统正在制定经济上重要的决策，而一些人工智能系统则是开放的对抗性攻击，如果其他人故意愚弄你的人工智能系统。 因此，根据您的应用程序，确保您不会对AI系统上的这些类型的攻击持开放态度可能很重要。 人工智能和歧视，人工智能和偏见以及对人工智能的对抗性攻击问题对你作为潜在的建设者和人工智能以及社会用户都很重要。 在下一个视频中，让我们更深入地探讨人工智能和偏见问题。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week4-3 Discrimination / Bias 歧视/偏见]]></title>
    <url>%2F2019%2F03%2F04%2Fweek4-03-discrimination-bias%2F</url>
    <content type="text"><![CDATA[人工智能系统如何变得偏向并因此歧视某些人？我们如何在人工智能系统中尝试减少或消除这种影响？让我们从示例开始。 微软的一个小组发现了这个非凡的结果，当人工智能从互联网上的文本文件中学习时，它可以学习健康的刻板印象。 值得赞扬的是，他们还提出了减少此类AI系统偏差量的技术解决方案。 这是他们发现的。 通过在互联网上阅读AI文本，它可以学习单词，你可以问它关于类比的理由。 那么，既然你已经在互联网上阅读了所有这些文字，那么你可以对AI系统进行测验。在类比中，男人就像父亲那样是什么？所以，AI会输出单词母，这反映了这些单词通常用于的方式互联网。 如果你问男人是女人，那么国王就是什么呢？那么同样的人工智能系统会说，就像国王对女王一样，相对于这些词在互联网上的使用方式而言，这似乎是合理的。 研究人员还发现了以下结果，即如果你问它，男人是计算机程序女人是什么？同样的AI系统会输出答案，女人是家庭主妇。 我觉得这个答案真的很不幸。 较少偏见的答案可言之，女人是computer programmer。 如果我们希望我们的AI系统能够理解男人和女人同样可以成为computer programmer，就像男人和女人一样是家庭主妇，那么我们希望它输出男人是computer programmer，因为女人是computer programmer，而且男人也是家庭主妇是家庭主妇。 人工智能系统如何从数据中学会变成这样的偏见？让我们更多地了解技术细节。 AI系统存储单词的方式是使用一组数字。 所以，让我们说存储 word man，或者我们有时会说代表两个数字1,1。 AI系统提供这些数字的方式是通过统计数据如何在互联网上使用 word man。 计算这些数字的具体过程非常复杂，我不会在这里讨论。 但这些数字代表了这些词的典型用法。 在实践中，AI可能有数百或数千个数字来存储单词，但我只是在这里使用两个数字来保持示例更简单。 让我把这个数字和它绘制在图表上。 所以，man这个词，我将在右边的图上的位置1,1上绘图。 通过查看短语computer programmer在互联网上如何使用或如何使用的统计数据，AI将有一对不同的数字，例如3,2，用于存储或表示短语computer programmer。 同样地，通过观察使用女性这个词，它会出现一对不同的数字，比如2,3，用来存储或代表女性这个词。 当你要求人工智能系统对上面的类比进行计算时，男人是computer programmer，因为女人要做什么？那么AI系统将做什么，就是构建一个看起来像这样的平行四边形。 它会问，与位置4相关的单词是什么？因为它会认为这是这个类比的答案。 在数学上思考这个问题的一种方法是，人工智能认为人与computer programmer的关系是你从男人这个词开始，向右走两步，然后向上走一步。 那么，为女性找到相同的答案是什么，？你也会向右两步，一步到位。 不幸的是，当这些数字来源于互联网上的文本时，AI系统会发现在互联网上使用单词homemaker的方式导致它被放置到位置4,4，这就是AIsystem提出这种偏见类比的原因。 人工智能系统今天已经做出了重要的决定，并且将来也将继续发挥作用。 所以，偏见很重要。 例如，有一家公司使用人工智能进行招聘，并发现他们的招聘过于歧视女性。 这显然是不公平的，所以这个公司就是他们的工具。 其次，还有一些面部识别系统，对于浅肤色和皮肤黝黑的人来说似乎更准确。 如果AI系统主要是根据打火机个体的数据进行训练，那么对于该类别的个体而言，如果将这些系统用于例如犯罪调查，则这将更加准确，这可能对黑皮肤的个体产生非常有偏见和不公平的影响。 因此，今天许多面部识别团队正在努力确保系统不会出现这种偏见。 还有人工智能或统计数据审批制度最终歧视一些少数民族群体，并引用了更高的利率。 银行也一直致力于确保在其审批系统中减少或消除这种偏见。 最后，我认为人工智能系统对加强健康刻板印象的毒性作用没有贡献是很重要的。 例如，ifan-8岁的女孩去图像搜索引擎并搜索首席执行官，如果他们只看到男人的照片，或者他们看到没有人看起来像是按性别或种族划分，我们不希望他们成为不鼓励追求一个可能导致她有朝一日成为一家大公司的首席执行官的职业。 由于存在这些问题，人工智能社区已经投入了大量精力来打击偏见。 例如，我们正在寻求更好和更好的解决方案，以减少AI系统的偏差。 在这个例子中你看到了AI输出买家类比的视频。 研究人员已经发现，当人工智能系统学习了很多不同的数字来存储单词时，很少有数字与偏差相对应。 如果将这些数字归零，只需将它们设置为零，那么偏差就会显着减小。 第二种解决方案是尝试使用较少偏见和更具包容性的数据。 例如，如果您正在建立一个面部识别系统，并确保包含来自多个种族和所有性别的数据，那么您的系统将更少偏见和更具包容性。 其次，许多人工智能团队使他们的系统更加透明和/或审核过程，这样我们就可以不断检查这些人工智能系统所展示的偏见（如果有的话），这样我们至少可以认识到它存在的问题，如果它存在，然后采取措施解决它。 例如，许多面部识别团队正在系统地检查他们的系统在人口的不同子集上的准确程度，以检查，例如，对于皮肤较暗的对比度较高的个体，它是否更准确或更不准确。 拥有透明的系统以及系统的审计流程会增加至少能够快速发现问题的几率，以防有问题，以便我们可以解决它。 最后，我认为拥有多元化的员工队伍有助于减少偏见。 如果您拥有多元化的员工队伍，那么您的员工中的个人更有可能能够解决不同的问题，并且他们可能会帮助您使数据更加多样化和更具包容性。 通过在建立AI系统时拥有更多独特的观点，我认为我们所有人都希望创建更少的偏见应用程序。 人工智能系统今天做出了非常重要的决定，所以偏见或潜在偏见是我们必须注意并努力减少的。 令人乐观的一件事是，我们今天实际上有更好的想法来减少AI的偏见，而不是减少人类的偏见。 因此，虽然我们不应该满意，直到所有人工智能的偏见都消失了，并且我们需要完成工作才能实现目标，我也很乐观地认为我们可以采用与人类相似的人工智能系统，因为它学到了来自人类，我们可以通过技术解决方案或其他方式减少来自那里的偏见，这样，作为一个社会，我们可以希望通过人类或通过人工智能做出的决定迅速变得更加公平和偏见。 除了偏见问题之外，人工智能的另一个限制是它可能是开放的对抗性攻击。 在下一个视频中，您将了解什么是对抗性攻击，以及您可以采取哪些措施来防范这些攻击。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week4-1 Week 4 Introduction 第 4 周 简介]]></title>
    <url>%2F2019%2F03%2F04%2Fweek4-01-week-4-introduction%2F</url>
    <content type="text"><![CDATA[欢迎回来。 你现在已经进入人工智能的第四周也是最后一周，因此必须完成这门课程。 人工智能是一个超级大国，可以让一个小团队影响到大量人的生活。 因此，无论您是AI的建设者还是用户，或者您是否只是某人关心的是对社会的影响，重要的是您要了解这些趋势，以便您可以使您的工作更好地让社会变得更好。 让我们来看看。 AI改变了世界，但也有很多不必要的炒作。 对于公民和企业领导人以及政府领导人来说，人工智能的兴起，重要的是我们都对人工智能抱有现实的看法。 现在，在第一周，您已经开始了解人工智能的一些技术限制。 AI也有其他限制。 例如，人工智能可能存在偏见，并且歧视不公平地反对少数群体或针对其他群体。 那么，我们如何解决这个问题？人工智能技术也容易受到对抗性攻击，例如，我们的垃圾邮件过滤器，它可以帮助电子邮件系统保持运作。 但是有些垃圾邮件发送者试图攻击垃圾邮件过滤器。 即使我们开发新的人工智能技术，如果人们故意试图愚弄人工智能，一些新技术也可能容易受到新型攻击。 发达经济体如美国和中国，已经广泛使用人工智能，但它们也会对发展中经济体和全球就业前景产生重大影响。 其中许多问题都隐含在人工智能和道德规范中。 确保AI中的工作符合道德标准。 这是一个复杂的主题，并没有简单的答案。 事实上，我认为AI和道德的话题值得拥有它自己的四周或更长的课程。 但我希望本周至少可以解决一些主要问题，因为在构建或使用AI的过程中，您了解与AI兴起相关的一些主要问题。 最后，在本周末，我们将为每个人结束AI。 我期待着花这些最后几段视频。 让我们开始谈论更多关于以一种超越AI的技术和性能限制的方式对AI进行现实观点的讨论。 我们来看下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-10 Survey of major AI techniques (optional) 人工智能主要技术调查（可选）]]></title>
    <url>%2F2019%2F03%2F04%2Fweek3-10-survey-of-major-ai-techniques-optional%2F</url>
    <content type="text"><![CDATA[今天有很多AI和机器学习技术。 而有监督的学习，即学习A到B的映射，是最有价值的，至少在经济上今天，还有许多值得了解的其他技术。 让我们来看看。 无人监督学习的最着名的例子是聚类，这是一个例子。 假设您经营一家专门销售薯片的杂货店。 并且您收集不同客户的数据，并跟踪单个客户购买的薯片的不同包装数量，以及该人员为其薯片支付的每包的平均价格。 因此，你出售一些低端，更便宜的薯片，以及一些高端，更昂贵的薯片包。 不同的人可能会购买不同数量的薯片，这是典型的杂货店之旅。 给定这样的数据，聚类算法会说你的数据看起来像两个簇。 你的一些顾客倾向于购买价格相对便宜的薯片，但买了很多包。 例如，如果您的杂货店靠近大学校园，您可能会发现许多大学生购买更便宜的薯片，但他们肯定会购买很多。 在这个不同购物者群体的数据中有第二个集群购买更少的薯片包，但购买更昂贵的包。 聚类算法查看数据，并自动将数据分组为两个聚类或更多聚类，并且通常用于市场细分。 如果你有一个购买某种类型的薯片的大学生观众，以及一个购买较少薯片而且愿意支付更多费用的专业观众，你会发现这些事情。 这可以帮助您对这些细分市场进行不同的营销。 这称为无监督学习的原因如下。 有监督的学习算法运行A到B的映射，而你必须告诉算法你想要的输出B是什么，一个无监督的学习算法不能完全按照它想要的方式输出AI系统。 相反，它为AI系统提供了大量数据，例如此客户数据，它告诉AI在数据中找到有趣的东西，在数据中找到有意义的东西。 在这种情况下，聚类算法事先并不知道有大学生人口统计和工作专业人口统计。 相反，它只是试图找到不同的细分市场而不被告知它们是什么。 因此，无监督学习算法，给定没有任何特定设计输出标签的数据，没有目标标签B，可以自动找到有关数据的东西。 我曾经研究过的无监督学习的一个例子就是那只略显臭名昭着的Google猫。 在这个项目中，我让我的团队在一大堆YouTube视频上运行无监督学习算法，我们询问了算法，告诉我们你在YouTube视频中找到了什么。 YouTube视频中的许多内容之一就是猫，因为有点刻板印象，YouTube显然有很多猫视频。 但这是一个非凡的结果，没有事先告诉它它应该找到猫，AI系统，无监督的学习算法，能够自己发现猫的概念。 只是看了很多YouTube视频并发现了这个，男孩，YouTube视频中有很多猫。 很难准确地想象出AI算法有时会想到什么，但右边的图片是系统学到的猫概念的可视化。 尽管有人监督学习是一种非常有价值和强大的技术，但对监督学习的批评之一是它只需要一些标记数据。 例如，如果您正在尝试使用监督学习将AI系统转换为公认的咖啡杯，那么您可以给它1000张咖啡杯照片或10,000张咖啡杯照片。 而这只是咖啡杯咖啡杯的很多图片我们将提供我们的AI系统。 对于那些作为父母的人，我最近向你保证，这个星球上没有任何父母，无论多么爱和关心，都曾向他们的孩子指出过10,000个独特的咖啡杯，尝试给孩子们带来什么是咖啡杯。 因此，今天的人工智能系统需要更多的标记数据来学习，而不是大多数动物的人类孩子。 这就是为什么人工智能研究人员为无人监督学习提供了很多希望，可能在未来，人工智能可以用更人性化的方式更有效地学习，而更像生物学的方式可以形成更少标记的数据。 现在，我们几乎没有理解生物大脑的作用，因此要实现这一愿景，我们将在人工智能方面取得重大突破，而今天我们所知道的如何实现。 但是，我们中的许多人对无监督学习的未来抱有很大的希望。 话虽如此，无监督学习在今天很有价值。 例如，存在一些特定的应用和自然语言处理，其中无监督学习有助于网络搜索的质量。 但是，今天监督学习的价值远远低于通过监督学习创造的价值。 另一个重要的AI技术是转移学习。 让我们看一个例子。 假设你买了一辆自动驾驶汽车，你已经训练过你的AI系统来检测汽车。 但是你并没有将你的车辆部署到一个新的城市，不知怎的，这个新的城市有很多高尔夫球车，所以你需要建立一个高尔夫球车检测系统。 您的汽车检测系统可能包含大量图像，比如100,000张图像，但在这个新开始运营的新城市中，您可能拥有更少数量的高尔夫球车图像。 转移学习是让您从任务A（例如汽车检测）中获取技术并利用知识帮助您完成不同任务B（例如高尔夫球车检测）的技术。 如果从一个非常大的汽车检测数据集（任务A）中学习，转移学习真的很有吸引力，即使你有一个更小的高尔夫球车数据集，你也可以在高尔夫球车检测上做得很好。 因为从第一项任务中学到了一些知识，车辆的样子，车轮的样子，车辆的运动方式。 也许这对于高尔夫车检测也很有用。 转学习不是很多新闻，但它是当今人工智能中非常有价值的技术之一。 例如，许多计算机视觉系统都是使用传输学习构建的，这对他们的性能产生了很大的影响。 您可能还听说过一种称为强化学习的技术。 那么，什么是强化学习？ 让我用另一个例子来说明。 这是斯坦福自治直升机的照片。 所以它配备了GPS，加速度计和指南针，所以它总是知道它在哪里。 而且，假设你想要编写一个程序让它自己飞行。 使用有监督的学习输入/输出，A到B映射很难，因为很难指定什么是最佳方式。 当飞机在某个特定位置时，飞行直升机的最佳方式是什么？ 强化学习提供了不同的解决方案。 我认为强化学习类似于训练宠物狗的表现方式。 我的家人，在我长大的时候，有一只宠物狗。 所以，你怎么跟踪狗的行为？ 好吧，我们让狗不管它想要做什么，然后只要它表现得好，我们就会赞美它。 你去，好狗，每当它做坏事你都会去，坏狗。 加班时，它学会了做更多的好狗，事情和害怕坏狗的事情。 强化学习采用相同的原理，并将其应用于直升机或其他两件事。 所以，我们会在模拟器中绕过直升机，这样它就可以在不伤害任何人的情况下坠毁。 但是我们会让人工智能飞机一次飞过直升机，每当它飞好直升飞机时，我们都会去，好直升机。 如果它崩溃了，我们会变坏直升机。 然后，人工智能的工作是学习如何驾驶直升机获得更多的直升机奖励，以及更少的直升机负面奖励。 更正式地说，强化学习算法使用奖励信号，告诉AI何时或者表现良好。 这意味着只要它表现良好，你给它一个大的正数，给它一个很大的积极奖励。 每当它做得非常糟糕时，你给它发一个负数，给它一个负面的奖励。 AI是自动学会表现以最大化奖励的工作。 因此，好狗回应给出正数，坏狗或坏直升机对应玩具给出负数。 并且人工智能将学习更多导致大量正数或大量积极奖励的行为。 在我们这样做之后，让我给你看一下斯坦福自主直升机的视频。 这是直升机飞行增援学习控制的视频。 那天我是摄影师，当你缩小相机时，你会看到树木指向天空。 所以，我们实际上给了它一个奖励信号，奖励直升机飞来飞去。 通过强化学习，我们建造了世界上最强大的自主直升机之一。 除了机器人控制之外，强化学习在玩游戏，奥赛罗或西洋跳棋或国际象棋或围棋等游戏中也有很大的吸引力。 您可能听说过AlphaGo，它在使用强化学习方面做得很好。 强化学习在玩视频游戏方面也非常有效。 增强学习算法的一个缺点是它们可能需要大量数据。 所以，如果你正在玩视频游戏，强化学习算法基本上可以玩无限数量的视频游戏。 因为它只是一个计算机游戏的计算机游戏，并获得大量的数据容忍如何表现更好。 或者用于玩跳棋或其他游戏等游戏。 它可以针对自己玩很多游戏，并且免费获取大量数据以提供强化学习算法。 在自主直升机的情况下，我们有直升机的模拟器，所以它可以长时间模拟飞行，以弄清楚什么有效，什么对飞行直升机不起作用。 有很多令人兴奋的研究工作可以使强化学习工作，即使对于你可能没有精确模拟器的环境也是如此。 而获取大量数据的难度更大。 尽管媒体对强化学习的关注程度很高，但至少在今天，它创造的经济价值显着低于有监督的学习。 但未来可能会有突破，可能会改变这一点。 人工智能正在迅速发展，我们所有人当然希望我们所谈论的所有这些领域都会有突破。 GAN或生成对抗网络是另一种令人兴奋的新AI技术。 他们是由我的学生Ian Goodfellow创建的。 GAN非常擅长从头开始合成新图像。 让我向您展示一个由NVIDIA团队制作的视频，该视频使用GAN来合成名人的图片。 这些都是以前从未存在的人的照片。 但通过从数据库名人图像中了解名人的外观，它能够合成所有这些全新的图片。 现在将GAN应用于娱乐业的不同事情令人兴奋。 从计算机图形到计算机游戏，到媒体，再到从头开始构建这样的新内容，应有尽有。 最后，知识图是另一种重要的AI技术，我认为它非常低估。 如果您在Google上搜索Leonardoda Vinci，您可能会在右侧有关达芬奇的信息中找到这组结果。 如果您在Ada Lovelace上搜索，您也可以在右侧找到一组附加信息。 此信息来自知识图，它基本上是指列出人员和关于这些人的关键信息的数据库。 比如他们的生日，他们过世时，他们的生物，以及这些人的其他属性。 今天，不同的公司已经建立了许多不同类型的事物的知识图，而不仅仅是人。 但他们也建立了这些电影，名人，酒店，机场，景区，以及等等的数据库。 例如，带有酒店信息的知识图表可能包含大型酒店数据库以及有关这些酒店的关键信息。 因此，如果您在地图上查看它们，您可以相对快速地找到正确的信息。 知识图这个术语最初是由谷歌推广的，但这个概念已经传播到许多其他公司。 有趣的是，尽管KnowledgeGraphs在这一点上为多家大公司创造了许多经济价值，但这是学术界相对较少研究的一个主题。 因此，相对于当今的实际经济影响，您在知识图上看到的研究论文数量似乎不成比例地小。 但是，根据您所从事的行业，可能还有一些构建知识图表的技术，对于构建与您公司相关的大量信息数据库也很有用。 在本视频中，您学习了无监督学习，转移学习，强化学习，GAN和知识图表。 好像很多，不是吗？ 我希望其中一些想法对您的项目有用，并且知道这些算法是什么，将使您更容易与AI工程师进行富有成效的讨论。 在本周，我们已经谈论了人工智能如何影响公司。 也许你如何使用AI来影响你的公司。 人工智能也对社会产生巨大影响。 那么，我们怎样才能理解人工智能对社会的影响，以及确保我们做出道德的事情呢？ 我们只使用人工智能来帮助人们并让人们变得更好？ 下周我们将谈论AI和社会。 感谢与我一起到此为止，我期待在最后一周的视频中看到你为这门课程。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-9 Survey of major AI application areas (optional) 人工智能主要应用领域调查（可选）]]></title>
    <url>%2F2019%2F03%2F04%2Fweek3-09-survey-of-major-ai-application-areas-optional%2F</url>
    <content type="text"><![CDATA[今天的AI正成功应用于图像和视频数据，语言数据，语音数据以及许多其他领域。 在本视频中，您将看到应用于不同应用领域的人工智能调查，我希望这可能会引发一些关于如何能够在某一天将这些技术用于您自己的项目的想法。 让我们来看看。 深度学习的主要成就之一就是计算机视觉。 我们来看一下计算机视觉应用的一些例子。 图像分类和对象识别是指将这样的图像作为输入，并告诉我们图片中的内容。 在这种情况下，它是一只猫。 我不仅仅是识别猫，我已经看到人工智能算法能够识别花的特定类型，人工智能能够识别特定类型的食物，能够将输入图像并将其归类为对象类型，并且这种算法在所有应用中都有用。 一种具有很大吸引力的特定类型的图像分类是面部识别。 这就是当今人脸识别系统的工作方式。 用户可以注册他们脸部的一张或多张图片以显示AI看起来像什么。 给定一个新的图像，AI系统可以说这是同一个人？ 这是你吗？ 或者这是一个不同的人，以便它可以决定一个决定，解锁门或解锁手机，解锁笔记本电脑或其他根据人的身份。 当然，我希望脸部识别只会以尊重个人隐私的方式使用，我们下周也会更多地讨论人工智能的问题。 不同类型的计算机视觉算法称为对象检测。 因此，不是仅仅尝试对对象进行分类或识别，而是试图检测对象的出现。 例如，在建造一辆自动驾驶汽车时，我们已经看到了AI系统如何将这样的图片作为输入而不仅仅是说是或否，是否有车。 是或否，是否有行人，但实际上告诉了汽车的位置以及此图像中行人的位置，并且物体检测算法也可以作为输入图像那样，只是说，不，我没有找到任何车辆或那个图像中的任何行人。 因此，不是拍摄图片并标记整个图像的图像分类，而是一个物体检测算法将我们输入图像并告诉我们图像中的不同对象在哪些对象的类型。 图像分割更进了一步。 给定这样的图像，我们输出的图像分段算法，它告诉我们不仅仅是汽车和行人的位置，而是告诉我们每一个像素，是这辆汽车的这个像素部分还是行人的这个像素部分。 因此，它不仅仅在对象周围绘制矩形并进行检测，而是在它找到的对象周围绘制精确的边界。 因此，例如，在阅读x射线时，它将是一种图像分割算法，可以查看x射线扫描或人体的其他图像，并仔细分割出来，肝脏或心脏的位置或此图像中的骨骼位置。 计算机视觉也可以处理视频和跟踪的一个应用程序。 在这个例子中，它不仅仅是检测这个视频中的跑步者，而且还在视频中跟踪跑步者是否随着时间的推移而移动。 因此，红色框下面的那些小尾巴显示该算法正在跟踪视频中几秒钟内运行的不同人。 因此，在视频中跟踪人物和汽车以及其他移动物体的能力有助于计算机找出事情的进展。 例如，如果您正在使用摄像机跟踪野生动物，比如说鸟儿在飞来飞去，那么跟踪算法也可以成为帮助您追踪视频帧的个体鸟类。 这些是计算机视觉的一些主要领域，也许其中一些对您的项目有用。 人工智能和深度学习在自然语言处理方面也取得了很大进展。 自然语言处理或NLP是指AI理解自然语言，意味着您和我可能用来相互交流的语言。 一个例子是文本分类，其中AI的工作是输入一段文本，例如电子邮件，并告诉我们这个电子邮件的原因或类别是什么，例如垃圾邮件或非垃圾邮件。 还有一些网站会输入产品说明。 例如，你可能会写，我有一个二手手机销售，并自动找出列表是产品的产品类别。 那么，这会是更硬的手机或电子产品，或者如果你写，我有一件新的T恤出售然后它会自动列在衣服上。 一种受到很多关注的文本分类是情感识别。 例如，情感识别算法可以将餐厅的评论作为输入，食物是好的并且自动地试图告诉我们该评论可能获得多少个星星。 食物是好的，因为相当不错的评论可能是四个过度的明星评论。 然而，如果有人写服务很糟糕，那么情绪识别算法应该能够告诉我们这可能是一个一星评价。 第二种类型的NLP或自然语言处理是信息检索。 网络搜索可能是您在文本查询中键入的信息检索的最着名的示例，您希望AI帮助您查找相关文档。 许多公司还将拥有内部信息检索系统，您可以在其中使用界面来帮助您在公司的文档集中搜索与您可能输入的查询相关的内容。 名称实体识别是另一种自然语言处理技术。 让我们用一个例子来说明它。 假设你有这句话，你想在句子中找到所有人的名字。 所以，伊丽莎白女王的第二个人是保罗·麦卡特尼爵士。 因此，伊丽莎白女王，第二个晚上保罗麦卡特尼为白金汉宫提供音乐服务，这将是一个名称实体识别系统，将所有人的姓名限制在这样的句子中。 如果你想找到所有的位置名称，所有地名都在这样的句子中，命名实体识别系统也可以这样做。 名称实体识别系统还可以自动提取公司名称，电话号码，国家/地区名称等等，如果您有大型文档集并且您想要自动查找公司名称，或者所有公司名称一起出现或者所有人的名字，那么名称实体识别系统将是您可以用来做的工具。 另一个主要的AI应用程序是机器翻译。 因此，例如，如果您在日语中看到这句话，AI [音频不清晰]。 然后希望机器翻译系统可以输入并输出翻译AI在电力中。 本幻灯片中的四个项目：文本分类，信息检索，名称实体识别和机器翻译，是有用的NLP应用程序的四个主要类别。 如果您与NLP团队合作，您也可以听到他们谈论解析和部分语音标记技术。 让我告诉你这些是什么。 我们来看一个例句，“垫子上的猫”。 一个词性标记算法将遍历所有单词并告诉你这些单词中哪些是名词，这些单词中哪些是动词，依此类推。 例如，在英语语言中，猫和席子就是名词。 因此，我们会将这两个词标记为名词。 根据英语语言理论，这个词是一个决定因素。 不要担心，如果你以前从未听说过一个限定词，这是英语语言理论中的一个词，而on on这个词是一个介词。 因此，部分演讲者会将这些单词标记为这样。 好吧，你为什么关心？ 如果你正在为餐馆评论构建一个句子分类器，那么一个词性标记算法就能告诉你哪些是名词，哪些是动词，哪些是形容词，哪个是副词，等等，因此，帮助你的AI系统找出哪个词更受关注。 例如，你应该更多地关注名词，因为这些看起来像是重要的词。 也许是动词。 当然，形容词，好的，坏的，美味的词都是形容词，你的AI系统可能会忽略决定者。 就用户实际感受到餐馆的感觉而言，这些词可能不那么重要。 讲话系统的一部分通常不是最终的应用程序。 你几乎没有在早上醒来，并想：“男孩，我希望我可以得到所有的句子在我的句子标签。“ 通常有一个重要的预处理步骤。 在较长的AI管道中通常有一个重要的中间步骤，其中第一步是语音标记或解析，我们将在一秒钟内进行跟踪，然后后续步骤是类似于句子分类或机器翻译的应用程序，或者网络搜索。 现在，什么是解析器？ 鉴于这五个单词，解析器有助于将这些词组合成短语。 例如，猫是短语，垫子是短语。 因此，解析器会在单词的上方绘制这些行，然后将这些单词放在一起。 在垫子上是另一个短语。 最后，两个短语，猫，以及在垫子上，这两个短语然后组合形成整个句子。 所以，我用这句话画上了这个东西，告诉你什么词会说什么，以及不同的词如何相互关联。 虽然解析算法也是另一种最终用户产品，但它通常是帮助其他AI算法的常用步骤。 这就是分类标签的翻译方式，等等。 现代人工智能，特别是深度学习也彻底改变了软件处理音频数据的方式。 演讲如何在电脑中代表？ 这是我的一个朋友说的短语机器的听力波形。 这里的x轴是时间，垂直轴是麦克风录制的。 麦克风的记录是微小的变化，气压的变化非常快，你的一年和你的brainthen解释为声音。 该图显示了作为时间的函数，横轴，空气压力如何响应有人说文字机器学习而变化非常快。 语音识别的问题，也称为语音到文本，是将这样的情节作为输入，并弄清楚有人说的话是什么的问题。 许多语音识别的最新进展源于深度学习。 一种特定类型的语音识别是触发字检测或唤醒字检测。 您在之前的视频中看到了这一点，其中AI系统检测到触发词或唤醒词，例如Alexa，或者Hey Google，或者嘿设计。 演讲者ID是一个专门的语言问题，其任务是倾听别人说话并弄清楚演讲者的身份。 正如面部识别有助于通过拍照来验证您的身份，演讲者ID也可以通过向您说话来帮助验证您的身份。 最后，语音合成，也称为文本转语音或TTS也具有很大的吸引力。 文本到语音是输入用文本写的句子并将其转换为音频文件的问题。 有趣的是，虽然文本到语音缩写为TTS，但我并不经常看到语音缩写为STT。 一个简单的例子。 让我们来看看这句话，“快速的棕色狐狸越过懒狗。“ 这是一个有趣的句子，你经常看到NLP人使用，因为这句话包含从A到Z的每一个字母。 所以，那就是ABC，直到X，Y和Z. 您可以查看此句中出现的所有26个字母。 有些字母出现不止一次。 如果你将这个句子解析为TTS系统，那么你可能会得到像这样的音频，快速的棕色狐狸跳过懒狗。 现代TTS系统的声音越来越自然，越来越像人类。 AI也适用于机器人技术中的许多应用，你已经在自动驾驶汽车中看到了一个例子。 在机器人技术中，termperception意味着根据你拥有的感觉，无论是相机，还是雷达，还是激光雷达，找出你周围的世界。 右侧显示的是自动驾驶汽车的3D激光扫描或激光雷达扫描，以及中间在汽车附近检测到的自动驾驶汽车的车辆。 运动规划是指为您的机器人寻找路径。 所以，如果你的车要转左转，那么运动规划师可能会计划一条路径以及一辆车的速度，以便左转弯。 最后，控制是指向您的方向盘电机，油门踏板和制动电机等电机发送命令，以使汽车顺畅地沿着您想要的路径行驶。 在这张幻灯片中，我将重点介绍机器人技术的软件和AI方面。 当然，为机器人技术构建硬件也有很多重要的工作要做。 但很多工作AI的感知，运动规划和控制都集中在软件而不是机器人的硬件上。 除了这些主要的应用领域，机器学习也被广泛使用。 您在此视频中看到的示例主要涉及非结构化数据，如图像，音频和文本。 机器学习至少应用于结构化数据，这意味着您在早期视频中看到的这些数据表。 但是因为图像之类的非结构化数据很容易被人类理解，所以当我们谈论识别猫的AI系统时，任何人都会非常普遍，非常容易理解和理解。 因此，大众媒体对非结构化数据的AI进展比对结构化数据的AI更为重要。 结构化数据也往往对单个公司更具体。 因此，人们难以理解或理解，但结构化数据上的人工智能或结构化数据的机器学习正在创造巨大的经济价值以及AI的结构化数据。 我希望通过对人工智能应用领域的这一调查，让您感觉到人工智能成功应用于今天的各种数据，这甚至可以激发您想到这些应用领域中的一些如何对您自己的项目有用。 现在，到目前为止，我们花费最多时间谈论的一种AI技术是有监督的学习。 这意味着从标记数据中学习输入，输出或A到B映射，其中您为AI系统提供A和B. 但那并不是那种唯一的技术。 实际上，“监督学习”这个术语几乎引发了无监督学习的问题，或者你也可能从媒体文章中听到关于强化学习的新闻。 那么，这些其他技术是什么？ 在下一个视频，本周最后一个可选的视频，我们将对人工智能技术进行调查，我希望通过这个可能你会看到其他一些人工智能技术和监督学习是否对你的项目也有用。 让我们继续本周的最终视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-8 Taking your first step in AI 迈出人工智能的第一步]]></title>
    <url>%2F2019%2F03%2F04%2Fweek3-08-taking-your-first-step-in-ai%2F</url>
    <content type="text"><![CDATA[本周，您看到了构建复杂AI产品（如智能扬声器或自动驾驶汽车）的例子。 您还了解了大型AI团队的角色和职责，也许是建立一个大型AI团队的人员，并看到了AItransformation手册，帮助一家伟大的公司成为一家伟大的AI公司。 如果其中一些看似令人生畏，因为其中一些可能需要两到三年才能执行。 如果这些看似令人畏惧，那就没关系，因为更重要的是你能够迈出第一步。 事实上，通过这门课程，你已经迈出了第一步。 所以，我希望你在这个课程之后也能采取同样好的第二步。 因此，在本视频中，我想与您分享一些具体的建议，以便下一步为您的公司为您提供AI。 以下是我要求你采取的一些初步措施。 考虑在公司中与朋友或在工作之外的私人朋友一起学习人工智能，而不是单独行动。 这可能意味着，要求他们在您或您之后接受本课程，或者开始阅读小组阅读一些关于AI的书籍或其他材料。 根据你在本课程中学到的知识，你也将，特别是如果你有工程学的朋友，能够开始创建项目。 没有一个项目不是从小开始并取得成功比从大开始而不成功要好。 许多项目可以由您或您或您的朋友完成。 如果您和/或朋友参加了机器学习的在线课程，那么您就可以开始学习许多可能非常有价值的AI项目。 在公司中，除了提供内部培训以培养内部人才之外，您还可以雇用一些机器学习或数据科学人员来帮助他们。 在公司中，除了提供内部培训以培养内部人才外，您还可以雇用一些机器学习或数据科学人员来帮助他们。 当您准备好变大时，您可能还会尝试让您的公司雇用或指定AI领导者，例如AI副总裁或首席AI官员。 但也许你不需要一个非常高级的人工智能领导者才能雇用一些机器学习或数据科学家让人们更快地前进。 最后，我和许多CEO和董事会讨论了关于转型的问题。 如果您希望您的公司成为更高的AI，您还可以考虑尝试与您的CEO讨论尝试执行AI转换的可能性。 我认为向您的首席执行官或董事会提出的关键问题是，如果您的公司在AI方面表现出色，那么您的公司是否会更有价值和/或更有效。 如果你和他们认为答案是肯定的，那么这可能是公司尝试执行AI转换的一个很好的理由。 这个列表中的不同项目具有不同程度的难以执行，但我希望你能够尽可能地开始，然后从那里开始你的AI工作。 我看到很多人，一些非技术性的技术人员，帮助他们的公司了解AI并开始有效使用。 在这些视频之后，您现在拥有了相同的具体工具。 所以，我希望你能利用它们，帮助你的公司，帮助自己，并帮助他人。 最后，本周我们还有两个关于主要人工智能应用领域以及主要人工智能技术的调查视频。 那么，如果您曾经想过，计算机视觉和自然语言处理这两个术语是什么意思？ 或者，什么是强化学习？ 或者，什么是无监督学习？ 请关注这些视频，因为我们将在接下来的两个视频中教您这些应用领域以及技术。 我们制作这些视频是可选的，因为它们更具技术性，但在观看之后，您将能够更好地与AI工程师沟通。 所以，我希望你看看。 无论哪种方式，感谢您本周观看所有这些视频，并期待在下周的视频中看到您。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-7 AI pitfalls to avoid 要避免的人工智能陷阱]]></title>
    <url>%2F2019%2F03%2F04%2Fweek3-07-ai-pitfalls-to-avoid%2F</url>
    <content type="text"><![CDATA[我希望你能够使用人工智能为你自己或你的公司建立令人兴奋和有价值的项目，让自己和他人的生活更美好。 一路上，我希望你能够避免一些陷入困境的人工智能团队陷入困境。 如果您正在尝试为您的公司制造AI，那么让我们重温五次。 首先，不要指望AI解决所有问题。 你已经知道人工智能可以做很多事了，但是AI也做不了。 相反，考虑到技术，数据和工程资源的限制，您应该对AI扫描或不能执行的操作采取现实的态度。 这就是为什么我认为除了商业努力之外，技术勤勉对于选择可行和有价值的人工智能项目也很重要。 其次，不要只雇用两到三名机器学习工程师，只依靠他们来为您的公司提供用例。 机器学习工程师是一种稀缺资源，但你应该让工程人才与业务人才交流，跨职能工作，寻找可行和有价值的项目。 往往是机器学习者的组合工作于商业人才，可以选择最有价值和可行的项目。 第三，不要指望AI项目第一次工作。 正如您已经看到的那样，AI开发通常是一个迭代过程，因此应该通过一个需要多次尝试才能成功的过程来规划它。 第四，不要期望传统的计划流程在没有变化的情况下应用。 相反，您应该与AI团队一起制定时间表估计，里程碑，KPI或有意义的指标。 与AI项目相关的时间线估计，里程碑和KPI或度量的类型与非AI项目相关的事物有点不同。 因此，希望与一些个人合作有关AI的知识可以帮助您提出更好的计划AI项目的方法。 最后，在你可以做任何事情之前，不要以为你需要超级巨星AI工程师。 相反，继续建立团队并与团队合作，你已经意识到当今世界上有许多AI工程师，包括许多从在线课程中学到的人。 他们可以很好地建立有价值和可行的项目。 如果你可以避免这些AI陷阱，那么与许多其他公司相比，你已经领先于游戏。 重要的是开始。 你是第二个AI项目比你的第一个好。 你的第三个AI项目比第二个更好。 因此，重要的是开始并尝试第一个AI项目。 在本周的最后一个视频中，我想与您分享一些您可以在AI中采取的具体的第一步。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-6 AI Transformation Playbook (Part 2) 人工智能转型手册（第2部分）]]></title>
    <url>%2F2019%2F03%2F04%2Fweek3-06-ai-transformation-playbook-part-2%2F</url>
    <content type="text"><![CDATA[在上一个视频中，您学习了如何执行试点项目以获得内部AI团队的动力，并提供广泛的AI培训。 但是你想要你的业务，不仅仅是在短期内使用人工智能获得动力，而且从长远来看，这是一个非常有价值的，甚至可能是防御性的业务。 你能做什么？让我们谈谈人工智能战略以及对一些公司来说可能很重要的内部和外部通信相对于人工智能。 回顾一下，这是五步AI转型手册，在本视频中，我们将深入探讨最后两步。 AI转型手册的第四步是制定AI策略，我希望你可以利用AI来创造一个特定的玩具行业优势。 这本手册的一个不同寻常的部分是制定人工智能战略是第四步，而不是第一步。 当我与许多CEO分享这个请求反馈前请求反馈时，请你把策略作为第一步吗？因为我想弄明白我的公司策略是什么，然后我想找到资源，然后执行策略。 但我发现那些试图将策略定义为第一步的公司，然后才开始尝试知道什么是可行的AI项目。 像公司这样的公司最终会遇到一些有时甚至不符合生活的学术策略。 因此，例如，我看到一些CEO将报纸头条复制并粘贴到此策略中。 我们读到数据是重要的，他说，“我的策略是专注于收集大量数据，但对于您的公司而言，这些数据可能或可能不具有价值，可能也可能不是您公司的良好策略。 所以，我倾向于建议公司先启动其他步骤，执行试点项目。 开始建立一个团队的一点点。 开始提供一些培训，这样只有在您了解AI并了解它如何适用于您的业务之后，您才能制定您的策略。 我认为这对你的公司来说比你尝试制定人工智能战略要好得多，在你的公司包括特别是执行团队之前，对于人工智能能为你的工业部门做什么和不能做些什么稍微深入了解。 此外，您可以考虑设计一种与人工智能的良性循环相一致的策略。 让我用网络搜索来举例说明。 网络搜索是一个非常难以理解的业务的原因之一，意味着新进入者与现有的大型网络搜索引擎竞争现在非常困难，这就是：如果公司有更好的产品，可能是稍微好一点的产品，那么网络搜索引擎可以获得更多用户。 拥有更多用户意味着您收集更多数据，因为您可以观察不同用户在搜索不同术语时点击的内容，并且可以将数据输入AI引擎以生成更好的产品。 因此，这意味着公司产品稍好一些，最终会有更多用户，最终会获得更多数据，并且通过现代AI技术创建更好的产品。 这使得新进入者很难进入这种自我强化的反馈循环，称为人工智能的良性循环。 幸运的是，人工智能的这种良性循环也可以被小型团队用于新的垂直行业。 因此，我认为今天很难建立一个新的网络搜索引擎来与谷歌，百度，Bing或Yandex竞争。 但是，如果你正在进入一个新的垂直领域，一个没有根深蒂固的现有领域的新应用领域，那么你可能真的开发出一种策略，让你成为利用这种良性循环的人。 让我举例说明一下。 有一家名为Blue River的公司被John Deerefor收购超过3亿美元，Blue River使用人工智能制造农业技术。 因此，他们所做的就是建造这些机器，这些机器可以拖在拖拉机后面的农田里。 这台机器将拍摄作物的图片并找出哪种作物和哪种是杂草，并使用精确的AI来除去杂草，而不是作物。 所以，我知道蓝河的一些创始人，而他们是斯坦福大学的学生，正在上课。 因此，为了让这个项目开始，他们实际上只是使用他们的汗水，他们使用他们的个人相机，去了一堆农场，并在这些农业领域拍摄了大量作物的照片。 因此，他们开始收集白菜头和白菜杂草的头像。 一旦他们有足够的数据，从一个小的数据集开始，他们可以训练一个基本的产品。 第一个产品，坦率地说并不那么好。 它是在一个小数据集上训练的，但它运作得很好，开始说服一些农民，一些用户开始使用他们的产品，拖拉拖拉机后面的这台机器，以便为农民开始杀戮。 一旦这个东西在农场通过拍摄卷心菜和杀死杂草的过程，他们自然获得了越来越多的数据。 在接下来的几年里，他们所做的一切都能够进入这个积极的反馈循环，拥有更多的数据可以让你拥有更好的产品。 拥有更好的产品可以让您说服更多的农民使用它。 让农民使用它可以让你收集更多的数据。 几年之后，进入良性循环[听不清]，可以让您收集庞大的数据资产，从而使您的业务可以防御。 事实上，在收购的时候，我很确定他们有一个更大的数据资产，比起大型科技公司所拥有的卷心菜头的图片，并且实际上使得业务相对防御甚至大型科技公司有另一个网站搜索数据，但没有像这家公司在农业领域的白菜头一样多的图片。 还有一条建议。 很多人都认为一些大型科技公司非常擅长AI，我认为这是真的。 一些最大的技术公司非常擅长人工智能，但这并不意味着您需要或应该尝试与人工智能的大型科技公司竞争，因为人工智能需要专业化或垂直化为您的行业。 因此，对于大多数公司来说，最好的兴趣是为您的行业建立专门的AI，并为您的应用领域做AI的伟大工作，而不是试图竞争或感觉您需要与大型技术左右竞争 关于AI的公司在大多数公司都不适用的地方。 人工智能战略的其他要素。 我们将生活在人工智能世界中，正确的策略可以帮助您的公司更有效地应对这些变化。 您还应该考虑创建数据策略。 领先的AI公司非常擅长战略数据采集。 例如，一些面向消费者的大型AI公司将提供服务，如免费电子邮件服务，或免费的照片共享服务，或许多其他免费服务，这些服务不会货币化，但允许他们以各种方式收集数据，让我们学习更多关于你的信息，因此他们可以为你提供更多而不是补充，从而以与产品直接货币化完全不同的方式获取数据。 您获取数据的方式因行业垂直而异，但我参与了这些多年的国际象棋游戏，其他公司竞争对手和我正在玩多年游戏，看谁能获得最具战略意义的数据资产。 您还可以考虑构建统一的数据仓库。 如果你有50个不同的副总裁控制着50个不同的数据仓库，那么AI工程师几乎不可能将所有这些数据整合在一起来连接这些数据。 例如，如果用于制造的数据仓库与客户投诉的数据仓库完全不同，那么AI工程师如何将这个数据计算结合在一起，无论制造中可能出现的问题是什么，导致您发送故障手机这导致客户在两个月后蠢蠢欲动。 因此，许多领先的AI公司已经投入大量的前期努力将数据转换为单个数据仓库，因为这增加了工程师一个软件的可能性，可以连接点并发现今天制造中温度升高的模式可能会导致在一个错误的设备中导致客户在未来两个月内投诉，从而让您回过头来改善您的制造流程。 在多个行业中有很多这样的例子。 您还可以使用AI创建网络效果和平台优势。 在具有winnertake所有动态的行业中，AI可以成为一个巨大的加速器。 例如，分享乘车共享或乘车招聘业务。 今天，像Uber，Lyfts，Ola，DiDi和Grab这样的公司似乎拥有相对难以置信的业务，因为它们是将驾驶员与乘客联系起来的平台，并且很难有新的参与者积累大量的骑手观众和大型乘客观众同时。 像Twitter和Facebook这样的社交媒体平台也非常具有防御性，因为它们具有非常强大的网络效应，在一个平台上有很多人使这个平台对其他人更具吸引力。 因此，新进入者很难突破。 如果您正在与这些类​​型的获胜者开展业务，那么所有动力学获胜者将获得最大的动力，那么如果AI可以用来帮助您提高我们的成长速度。 例如，庆祝用户获取，然后可以通过转换为更大的机会，您的公司将成为这个业务垂直行业的成功者。 战略非常舒适，行业和情况具体。 因此，很难将战略顾问完全归功于每一家公司。 但我希望这些原则为您提供一个框架，让您可以考虑为您的公司制定人工智能战略的一些关键要素。 现在，AI也可以适应更传统的策略框架。 例如，许多年前迈克尔波特写过关于低成本和高价值策略的文章。 如果您的公司有低成本战略，那么也许人工智能可以用来降低您的业务成本，或者如果您的公司有高价值战略来提供成本更高的真正有价值的产品，那么您可能会使用AI专注于增加您的产品价值。 因此，人工智能能力也可以帮助论证更广泛的企业战略的现有要素。 最后，当你正在建立这些有价值和无法辩护的业务时，我希望你们也只建立能让人们变得更好的企业。 人工智能是超级大国。 这是一个非常强大的东西，你可以做一个伟大的人工智能公司，所以我希望无论你做什么，你只能通过让人类更好的方式做到这一点。 AI转型手册的最后一步是开发内部和外部通信。 人工智能可以改变公司及其产品，重要的是与相关的利益相关者就此进行适当的沟通。 例如，这可能包括投资者关系，以确保您的投资者可以作为AI公司适当地评估您的公司。 投资者关系还可能包括政府关系。 例如，人工智能正在进入医疗保健领域，这是一个高度监管的行业，因为政府有合法的需要保护患者，因此，如果AI影响这些高度管制的行业，我认为公司与政府沟通，并在公共场合与他们合作非常重要。 - 私人合作伙伴关系，以确保人工智能解决方案为人们带来可带来的好处，同时也确保政府可以保护消费者并保护患者。 因此，这对于医疗保健来说是真的，或者对于自动驾驶汽车来说也是如此，对于金融和许多其他AI行业垂直行业来说也是如此。 如果您的产品发生变化，那么消费者或用户教育将变得非常重要。 人才是非常稀缺的世界，所以，如果你能够获得一些真正有助于收集和招募的初步成功。 最后，如果你在公司转移，内部沟通也很重要，那么很多人内部可能会有担忧，有些人合法，有些人对人工智能和内部沟通不太理性，所以向人们保证适当的只会有所帮助。 通过这五个步骤，我希望它能让您了解公司如何成为AI的佼佼者。 如果您有兴趣阅读详细的AI转型手册，您也可以从这个登陆AI网站下载。 我希望你在AI转型手册中享受这两个视频。 我已经看到公司通过拥抱和擅长人工智能变得更有价值和更有效，我希望这些理想希望你迈出第一步，帮助你的公司擅长人工智能。 话虽如此，我还有许多常见的陷阱，这些公司在尝试实施人工智能时会遇到困难。 让我们看看下一个视频中的一些常见陷阱，希望你可以避免它们。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-5 AI Transformation Playbook (Part 1) 人工智能转型手册（第1部分）]]></title>
    <url>%2F2019%2F03%2F04%2Fweek3-05-ai-transformation-playbook-part-1%2F</url>
    <content type="text"><![CDATA[你怎么能帮助你的公司擅长AI？ 根据我的经验，开始领导谷歌大脑团队以及百度的AI小组，这些小组分别是帮助谷歌和百度在人工智能方面变得更好和更深入的主要力量。 我花了很多时间思考如何让伟大的公司成为一家伟大的人工智能公司，并且我最终编写了一本AI转型手册来帮助其他国家。 在本视频中，我想与您分享AItransformation手册的详细信息，以便您更好地了解您的公司可能需要擅长AI。 如果有些事情看起来像只有CEO需要知道的事情，我认为情况并非如此，对公司中的每个人都有用了解是否可能需要让您的工作不仅影响一些项目而且可能对公司产生更大的影响作为一个整体。 让我们开始吧。 以下是AItransformation手册的五个步骤。 我们将稍微深入一些，但简单地说，第一步是让贵公司执行试点项目以获得动力。 开始了解处理AI项目的感觉。 第二步，是建立内部AI团队。 第三步，提供全面的人工智能培训，不仅仅是工程师，而是包括高管在内的公司内部的多个层面。 第四步，是制定你的策略和第五步，就是开发关于你公司和AI的内部和外部沟通。 公司执行这些步骤的方式可能不完全是顺序的，因此不同的步骤可能会重叠。 但是这个编号给出了我认为你可以做这些步骤的顺序的粗略意义。 在这个视频中，我们将在这三个步骤中的前三个步骤以及下一个视频以及五个步骤中显示步骤。 让我们从第一步开始，执行试点项目以获得动力。 如果您希望您的公司获得AI的动力，那么初始投影机项目最重要的考虑因素是让他们成功而不是最有价值的。 例如，当我加入谷歌大脑团队时，当时仍然有很多人怀疑深度学习。 所以，我的第一个内部客户是谷歌的语音识别团队，语音识别很高兴有这个有用，但它实际上并不是公司底线最重要或最重要的项目。 它没有价值，例如网络搜索或在线开胃。 但是通过让我的团队让Google Speech团队更成功，它开始了飞行轮滑，帮助它获得动力，因为同伴和其他团队是兄弟和演讲团队开始看到我的团队使演讲团队更成功，所以他们也开始了在AI中获得青睐，并希望与我们合作。 因此，我的第二个内部客户是谷歌地图团队，他们利用深度学习和第一次成功来提高地图数据的质量。 然后，我开始与在线广告团队进行其他对话。 因此，在选择您的初始项目时，请尝试选择您认为具有成功优势的内容。 即使它可能不是最终为公司服务的最有价值的项目，他们也可以开始进行翻车。 因为前几个项目的目标只是为了获得动力，现在你看看你是否可以选择能够在12个月内显示出牵引力的东西。 所以你可以快速开始飞轮转动。 最后，您的第一个或两个试点项目可以是内部或外部。 如果您还没有庞大的内部人工智能团队，那么可能甚至可能会将您的前几个AI项目的部分或全部外包，以便在内部获得更多专业知识，并让您更快地开始建立这种动力。 现在，超过某一点，您将需要您自己的内部AI团队来执行可能包含许多AI项目的长期序列。 因此，第二步是建立内部人工智能团队。 许多公司都是这样组织的，其中有一个CEO和多个业务部门，我将简要介绍BU，并向CEO报告。 因此，我推荐的formost公司是建立一个集中的AI团队，然后将矩阵组织中的人才纳入其中，并将两个矩阵分解为这些不同的业务部门以支持他们的工作。 为什么要人工智能？ 我们来举个例子吧。 也许这个单位是你的快乐卡业务部门，而且无论她或她做什么，BU领导者都可能很棒。 他们可能是更大的信用卡业务。 但除非他或她知道人工智能，并且知道如何建立留住和管理人工智能团队，否则业务部门负责人可能很难聘请和保留适当管理他们自己的人才。 因此，在这种情况下，如果您发现人工智能团队负责人能够负责制定一致的公司明智的招聘，保留标准，我认为您的成功要高得多。 拥有必要的人工智能团队，让团队社区相互交流，了解AI如何应用我们的业务激进。 将AI人才纳入您的集中式AI单元并将其矩阵化为礼品卡业务单元可能更有效，这样您的AI人才可以与礼品卡domainexperts一起工作，以便共同开发有趣的AI项目。 AI部门的另一个职责是建立一个全公司范围的平台。 如果有软件平台或其他工具或数据基础设施可能对整个公司有用，那么单个业务单元可能没有资源或激励来构建这些可以支持整个公司的公司范围的平台和资源，但是本质化的AI团队可能会帮助构建了这些可以帮助多个业务部门的公司范围的工具或平台。 最后，这个newAI业务部门可以是首席信息官，首席信息官，首席数据官或首席数字官，也可以是新的首席人事官。 CAIO首席人工智能官是一个在不同公司中越来越常见的角色，但如果其他一些高级管理人员拥有合适的技能，他们也可以管理AI单位。 最后，最后一个建议，即我认为，如果让AI单位启动，公司或首席执行官提供资金来建立AI单位，而不是要求AI部门从业务部门获得资金，这是有希望的。 最终，在初始投资之后和最初的增长之后，人工智能部门将不得不展示他为业务部门创造的价值，但是在首席执行官注入资金时他们可以继续投资，通常会帮助你更快地获得初始动力。 除了建立内部人工智能团队外，我还建议您提供广泛的人工智能培训。 现在，为了擅长人工智能，不仅仅是你需要知道人工智能，你需要多个人在公司的多个层面来了解AI如何与他们的角色互动。 例如，对于高管和高级业务负责人，我建议他们了解人工智能可以为您的企业做些什么，他们学习了这些人工智能战略的基础知识，并且他们学到了足够的人工智能来做出资源分配决策。 那么，高管高管领导应该接受多少培训？ 我认为培训的数小时并不是衡量培训的一种很好的方法，但有了这个警告，我认为你可以通过四个小时的培训来完成这项培训。 人工智能项目的分工领导者也需要知道如何与人工智能相互作用。 我认为这些领导者需要了解如何设置项目方向。 那么，如何进行技术和业务的努​​力，以便在部门层面做出资源分配决策，以及如何跟踪和监控AI项目的进展。 所以，我认为这需要至少12个小时的培训。 虽然，再次使用小时数并不是一个很好的追踪指标，但他们获得了很多收益。 最后，许多公司正在从外部招聘人才，但我也不会低估培养你现有的工程人员和人工智能技能对软件工程师熟练掌握人工智能的影响确实需要一段时间才能计划至少100小时的培训。 但是我看到很多公司为帮助工程师提供培训，学习构建和运送人工智能软件以收集和管理数据，这有助于他们有效地执行特定的AI项目。 当今世界没有足够的AI工程师，所以内部培训是许多公司建立其内部AI能力的关键部分。 最后，你如何完成这项培训？ 由于在线数字内容的兴起，当然还包括在线课程，书籍，YouTube视频和博客文章。 关于所有这些主题，网上有很多很棒的内容，我认为一个优秀的CLO应该由专家组成，以策划这种类型的内容，并激励团队完成这些学习活动，而不是必须创建更昂贵的内容。 因此，AI传输的第一步到第三步是有利的。 好的，我希望您的公司能够开始执行初始项目，建立团队，提供培训并真正开始获得大量动力，帮助您使用AI变得更有价值或更有效。 从更广泛的角度来看，人工智能还会影响公司战略以及如何让不同的利益相关者（包括投资者，员工，客户）与公司的这种转型保持一致。 让我们继续下一个关于人工智能战略的视频讲座。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-4 Example roles of an AI team 人工智能团队的示例角色]]></title>
    <url>%2F2019%2F03%2F04%2Fweek3-04-example-roles-of-an-ai-team%2F</url>
    <content type="text"><![CDATA[你从最后两个视频中看到，一些人工智能产品可能需要一个大型的AI团队，也许你有100名工程师，或者有时甚至超过100人。 我想在这个视频中做的是分享你这样一个大型AI团队的典型角色和职责，这样你就能更好地理解构建这些复杂AI产品所需的工作类型。 现在，即使您将在一个规模小得多的团队中工作，也许在可预见的未来可能会有一两个或五个人团队，我希望这个视频对您仍然有用，因为我希望它能让您了解不同类型的AIteam可能需要做的工作，即使你最终以更小的团队执行此类工作。 有一点需要注意，因为AI的发展如此之快，职称和各种责任还没有100％定义，而且他们在不同的公司之间有点不同。 所以，你的公司可能会以不同于我在这里展示的职位来使用他们的职位，但我想分享一个观点，即如何在许多公司中经常使用工作机会，以便如果你有一天建立自己的AI团队，我们会听到这些角色你至少会对这些职称的含义有一些更深刻的理解。 那么，让我们开始吧。 许多AI团队中都会有软件工程师。 因此，例如，对于智能扬声器，我们需要编写专用软件来执行笑话或设置计时器或回答有关当今天气的问题。 所以，那些是传统的软件工程任务。 或者你正在制造一辆自动驾驶汽车，以确保你的自动驾驶汽车软件可靠并且不会崩溃。 这些是软件工程任务。 因此，AI团队的扩展分数有时会达到50％，有时远远超过其中50％的软件工程师，这一点并不少见。 第二个共同角色是机器学习工程师。 因此，Machine LearningEngineer可能编写负责生成A到B映射器的软件，用于构建产品所需的其他机器学习算法。 因此，他们可能会收集汽车图片和汽车位置的数据，训练神经网络或训练深度学习算法并迭代工作以确保学习算法具有准确的输出。 您经常听到的另一个角色是MachineLearning Researcher。 机器学习研究员的典型行是扩展机器学习的最新技术。 更广泛的机器学习和人工智能正在迅速发展。 因此，许多公司为盈利和非营利组织，更多的机器学习研究人员负责扩展最先进的技术。 一些机器学习研究人员将发表论文，但许多公司也有机器学习研究人员做研究，但不太专注于出版。 另外还有一个工作岗位，就是应用机器学习科学家，它们介于机器学习工程师和机器学习研究员之间。 机器学习科学家有点兼顾两者。 他们经常负责阅读学术文献或研究文献，找到稳定的VR技术，并找到方法使他们适应他们所面临的问题，如如何获得最前沿，触发柳条检测算法的位置，以及适应那些玩具智能扬声器。 让我们看看其中的更多内容。 今天，有许多数据科学家在工业中工作。 数据科学家的角色定义不明确，其意义仍在不断发展。 我认为数据科学家的主要职责之一是检查数据并提供见解，并向团队或高管提出陈述，以帮助推动业务决策。 今天还有Data Scientist做其他任务。 因此，今天还有数据科学家的工作看起来更像机器学习工程师，他们在上一张幻灯片中有描述。 这个职位的意义今天仍在发展。 随着大数据的兴起，还有越来越多的数据工程师，其主要作用是帮助您组织数据，这意味着确保您的数据得到保存，并且易于访问，安全且经济高效。 那么，为什么保存数据是一件大事呢？难道你不能将它们保存在硬盘中并完成它。 在一些公司中，数据量已经变得如此之大。 实际上有很多工作要管理它们。 为了给你一种规模感，在计算机科学中，一个MB可以容纳一兆字节，所以你的音乐播放器上的典型歌曲就像一个典型的MP3文件，可能只有几兆字节，比如五兆字节就是非常不寻常的MP3文件大小。 1000兆字节被称为千兆字节。 一百万兆字节被称为1兆字节，十亿兆字节被称为千兆字节。 凭借今天的硬盘大小，节省几兆字节并不是什么大问题。 它就像一个MP3文件，但存储1000兆字节，也称为千兆字节，开始有点慢。 您通过互联网流式传输的典型小时长电话可能超过千兆字节。 所以，这是非常多的数据。 为了让您了解规模，自动驾驶汽车每运行一分钟就可以收集数千兆字节的信息。 因此，就像每一分钟自动驾驶汽车产生足够的数据来存储多个长达一小时的电影一样。 因此，自动驾驶汽车实际上会产生大量数据并将数据保存数天或数周或数月或数年的运行开始需要严格的数据工程。 一个太字节比1000倍大，而另一个千兆字节比那些负责每天节省几千兆字节信息的团队大1000倍，但除了相当大的互联网公司之外，一个公司产生多个PB的信息并不常见每天。 当你将这个规模向下移动到更大的数据集时，确保数据以易于访问，安全且经济高效的方式存储变得更加困难和困难，这就是数据工程师变得越来越重要的原因。 最后，你也会听到人们提到的AI产品经理，他们的工作是帮助决定建立什么。 换句话说，它们有助于弄清楚什么是可行和有价值的。 传统的ProductManager的工作已经决定要建立什么以及其他一些角色，但AI ProductManager现在必须在AI时代这样做，并且他们需要新的技能组合来根据whatAI可以和不能来计算什么是可行的和有价值的今天做。 因为我们的领域仍在不断发展，所以这些职位都没有完全被钉在石头上，不同的公司将以不同的方式使用这些职业。 但我希望这能让您了解构建非常复杂的AI产品所需的一些不同类型的工作，以及一些工作职位的演变。 尽管如此，我还是要再次强调你可以从一个小团队开始。 您不需要100个人来完成大多数AI项目。 所以，无论你是只有一个软件工程师，或者只是一个机器学习工程师，或者只是一个数据科学家，或者只有一个数据科学家，或者没有人，但你自己，如果你或与你一起工作的工程师已经参加了一些关于机器学习或深度学习的在线课程或者数据科学，这通常足以让你自己或你和一个工程师开始查看一些较小的数据，开始做出相关的结论或开始交易一些机器学习模型以便开始。 所以，尽管我已经尝试在这里画出一个大型AI团队可能会是什么样子的愿景，即使你只有一个小型的AI团队，也可能没有人，我仍然鼓励你开始并开始探索你能做的项目做。 在这个视频中，你看到了AI团队的样子，但是当你看到一个更大的公司时，一个AI团队并不孤立。 那么，AI团队如何融入更大的公司以帮助整个公司擅长人工智能？您可能还记得在第一周我简要提到了一个AI转型手册，这是一个帮助公司帮助公司的路线图。公司在AI工作得很好。 既然你已经了解了人工智能，如何进行人工智能项目，甚至公司的AI团队以及能力AI项目和能力可能会是什么样子，那么让我们回到他们的AI转型手册，深入了解手册的各个步骤，这样你就可以了解如何帮助一家公司在未来几年内成为优秀人工智能，并希望在这方面变得更有价值，更有效。 让我们在下一个视频中进入AI转型手册。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-2 Case study: Smart speaker 案例研究：智能扬声器]]></title>
    <url>%2F2019%2F03%2F04%2Fweek3-02-case-study-smart-speaker%2F</url>
    <content type="text"><![CDATA[在复杂的AI产品上感受到什么样的感觉，不仅仅是使用单个机器学习算法从A映射到B，而且学习算法是更大更复杂的项目或产品的一部分。 我想本周开始讨论buildingcomplex AI产品的两个案例研究。 首先，建立一个智能扬声器，以便您可以开始了解我是否有一天希望在您自己的公司中使用复杂的AI产品。 让我们开始吧。 像这样的智能扬声器和语音激活设备正在风靡世界，如果你家里还没有它，也许你有一天会买一个。 我想通过案例研究来了解如何编写AI软件以让智能扬声器响应口头命令，例如“嘿设备，告诉我一个笑话。“ 对于这个例子，使用Alexa，或者Okay Google，或者Hey Siri，或者Hello Baidu作为唤醒词或触发词，更多的设备不可知，我只是将”嘿设备“作为触发词或唤醒工作。 醒来说一个聪明的演讲者，让我们说你想告诉你一个笑话。 那么你如何建立一个人工智能软件来理解命令并在其上执行呢？ 这些是处理命令所需的步骤。 可以有四个步骤。 第一步是触发词或唤醒词检测。 扬声器使用机器学习算法输入音频和输出。 他们只是唤醒唤醒词或触发词“嘿设备”，所以o加0或1，一旦听到触发词或唤醒词，一旦听到“嘿设备”，它就必须执行第二步，即语音承认。 所以该软件必须做的是采取“嘿设备”之后的音频并将其映射到“告诉我一个笑话。“ 这也是通过机器学习完成的。 然而，这里的第一步使用A到B映射来告诉它它听到了触发词。 这使用了一个不同的A到B映射来将音频映射到你刚才所说的文本转换，在这种情况下是四个字告诉我一个笑话。 现在，算法必须通过说出这四个单词来弄清楚你真正想要的东西，所以第三步是意图识别。 这意味着你要说什么，并弄清楚你实际想做什么。 因此，今天的智能扬声器有一组有限的命令，例如他们可以说出一个笑话，或者他们可以告诉时间。 所以你可以说“嘿设备是时候了。“ 他们可以播放音乐。 他们有时可以帮助您拨打电话。 他们可以告诉你天气是什么，“嘿设备，明天天气怎么样？”所以意图识别的作用是采用四个词，即语音识别的输出，并使用另一个AI软件，另一个A到B的映射输入这四个单词并输出这五个或其他意图中的哪一个。 因此，在机器学习算法的这种实现中，输入A是文本转录本告知的笑话，输出B是用户刚刚说出的这五种命令中的哪一种。 当然，你的智能扬声器可能更容易理解甚至更多的命令，在这种情况下，B可以是智能扬声器知道如何执行的五个或20个或100个命令中的任何一个。 无论你如何要求智能发言人开玩笑，希望意图识别组件能够正确识别你的意图。 所以你也可以说不只是“嘿设备，告诉我一个笑话”，但也要“嘿设备，你知道任何好话”或“嘿设备，告诉我一些有趣的东西。“ 事实证明，有很多方法可以让一个聪明的演讲者开个玩笑，一个精心设计的意图识别系统应该能够识别出大部分内容。 最后，现在你的智能音箱已经发现你真的，真的想听一个笑话，最后一步是会有一个软件工程师写了一段代码来随机选择一个笑话并通过扬声器播放笑话。 换句话说，他们会开玩笑。 仅仅是为了记录，我最喜欢的笑话是为什么我在AI中有令人震惊的结果，因为人工智能是新的电力，令人震惊的电力，得到它？ 希望你喜欢这个。 所以，好吧，并且认真地，你可以想到这四个步骤的算法的四个步骤，其中第一步是触发词检测，第二步是语音识别，然后是意图识别，然后最后，执行什么是命令用户要求智能扬声器执行。 因此，在这个或多个步骤的AI系统中有四个步骤的过程，这有时被称为AI管道，其中有多个AI组件。 是的，可能的机器学习组件一步一步地处理数据，并且在公司中有四个不同的团队，每个团队关注这个AI管道的一个组件，这并不罕见。 这就是我们经常在大公司内组织项目的方式。 现在让我们看一个更复杂的例子。 你们中的一个发出更复杂的命令，比如“嘿设备，设置计时器10分钟。“ 这些是处理命令所需的步骤。 第一步，与之前相同的是触发字检测。 所以输入一个音频，当有人说触发器嘿设备时让我知道。 然后语音识别，你输入其余的音频和转录其余的声音，其余的音频，设置计时器10分钟，现在，意图识别hasto输入文本和输出你的意图是你想要设置计时器。 设置计时器10分钟与之前的例子之间的一个区别是告诉我一个笑话，你需要知道实际设置计时器的时间。 所以在执行步骤中，你实际上需要做两件事。 一个是提取持续时间。 这意味着，查看文本，设置计时器10分钟并拉出短语，告诉你实际设置计时器的时间长度，因此如果用户说“嘿设备，让我知道什么时候10分钟”，那么这个提取持续时间步骤必须再次拉出，10分钟的短语权利，当然，有很多方法可以使用10分钟的计时器。 你也可以说，让我知道，从现在开始10分钟或者10分钟后设置闹钟，希望，意图识别和提取持续时间组件都足够强大，可以识别所有这些都是要求10分钟计时器的不同方式。 最后，为了执行该命令，智能扬声器中应该有一个专门的软件组件可以启动具有设定持续时间的计时器，并且在它已经提取了你的意图和持续时间之后，它只是启动具有该持续时间的计时器。 这样警报在10分钟结束时就会消失。 今天的智能音箱有很多功能。 除了谈论讲笑话和设置计时器之外，还有一些其他功能，今天许多智能扬声器都可以执行，执行这些命令的键步骤是触发词或唤醒词检测，语音识别以转录命令中的文本，意图识别，确定您希望执行哪些功能或哪些命令，然后执行专门的程序来执行您发出的任何命令。 智能扬声器世界面临的挑战之一是，如果您希望您的智能扬声器拥有许多不同的功能，例如20种不同的功能，那么您需要软件工程团队才能编写20个专用软件。 一个播放音乐，一个设置音量，一个拨打电话，一个拨打当前时间，一个用于转换单位，如从一个汤匙到汤匙，或者回答非常简单的问题，等等。 因此，编写所有这些专用程序以执行您可能希望在第四步执行的所有不同命令实际上要做很多工作，而今天的智能扬声器实际上做了很多事情，许多用户难以直接提示 他们能做什么，不能做什么。 许多智能扬声器公司已经在用户培训上投入了大量资金，试图让用户知道智能扬声器可以做什么，因为一方面他们无法做到。 有很多事情你不能问聪明的演讲者，因为请打电话给我所有的三个朋友，看看他们所有人都能见面吃饭。 因此，智能扬声器的持续过程是向用户解释他们可以做什么和不能做什么。 尽管如此，通过使用语音来指挥这些扬声器可以让许多人的生活更加便利。 我希望这段视频让您了解如何构建复杂的AI产品，如智能扬声器。 为了帮助您更好地了解这些复杂产品的工作原理，让我们继续看看如何拼凑多个AI组件以构建自动驾驶汽车的二次研究。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-3 Case study: Self-driving car 案例研究：自动驾驶汽车]]></title>
    <url>%2F2019%2F03%2F04%2Fweek3-03-case-study-self-driving-car%2F</url>
    <content type="text"><![CDATA[AI时代最令人兴奋的产品之一就是自动驾驶汽车。 自动驾驶汽车也是人们在AI中听到的最神秘的事情之一。 在这个视频中，我想与您分享一个简单的自动驾驶汽车描述，以便您了解如何拼凑多个AI组件以构建这些惊人的东西。 让我们开始吧。 这些是决定如何驾驶自动驾驶汽车的关键步骤。 汽车将输入各种传感器，例如汽车前面或侧面或后面的图片，以及雷达或激光雷达意义激光传感器读数。 鉴于图片的这些输入和其他东西，它必须检测其他车辆。 所以考虑到这一点，希望你会想到那里有一辆车，以及行人在哪里，因为我们想要避开其他车辆以及避免行人。 汽车检测和行人检测都可以通过机器学习来使用输入/输出或A到B的映射，这些映射将图像作为输入，也可能是雷达和激光雷达，发送输入并告诉我们其他车辆和行人在哪里。 最后，既然您知道其他车辆在哪里以及行人在哪里，您就可以将这些信息提供给另一个专门的软件，它被称为运动规划软件，用于计划运动或计划您想要的车辆路径，这样您就可以在避免任何碰撞的情况下向目的地前进。 一旦你计划了你的汽车的运动，你可以将其转换为方向盘的特定转向角度，加速和制动指令，以及加油踏板的多少，以及制动多少以使汽车移动在所需的角度以及速度。 让我们更详细地看一下汽车检测，行人检测和运动计划的三个关键步骤。 汽车检测使用监督学习。 所以，你已经看到了学习算法如何作为这样的输入图像并输出检测到的汽车。 对于大多数自动驾驶汽车而不是仅使用前置摄像头，因此向前看的摄像头也经常使用向左看，向右看以及向后看的摄像头，因此它可以检测到汽车，而不仅仅是前面的所有周围。 这通常不仅使用相机而且使用其他传感器，如雷达和激光雷达。 接下来是行人检测，使用非常相似类型的传感器和技术，自动驾驶汽车可以检测到行人。 最后，我简要提到了一个运动规划步骤。 那么，那是什么？这是一个例子。 假设你正在驾驶你的车，而且你身边有一个浅蓝色的车。 运动规划软件的工作是告诉你路径是什么，这里以红色显示，你应该开车以便沿路而不是意外。 因此，运动规划软件的工作是输出路径以及您应该驾驶汽车的速度，以及跟随道路的速度，并且应该设置速度以便您不会跑到另一辆车，但是您也以合理的速度行驶在这条路上。 这是另一个例子。 如果这辆灰色的车停在道路的右侧，那么你想超越这辆停下来的车，那么运动规划软件的工作就是绘制一条这样的路径，让你向左转一点，然后安全地超车停下来。 到目前为止，我已经给出了自驱动的简化描述，主要包括这三个组件。 让我们看一下实际的自动驾驶汽车如何工作的更多细节。 这是你到目前为止看到的一幅画面。 将输入图像，雷达或激光雷达，传感器读数输入汽车检测和行人检测，然后将其输入运动规划，以帮助您选择路径和速度。 现在，在一辆真正的自动驾驶汽车中，您通常不仅仅使用相机，雷达和激光雷达。 大多数自动驾驶汽车今天也将使用GPS来感知它的位置以及加速度计，有时也称为IMU，这意味着加速度计，陀螺仪以及地图，因为我们知道汽车更容易被发现在路上，行人更多可能会在人行道上发现，虽然它们有时也会在路上发现。 所有这些通常都是附加的信息，用于检测汽车和行人以及其他物品。 为了安全驾驶，您不仅要检测汽车和行人，还需要知道这些汽车和行人在未来的发展方向。 因此，自动驾驶汽车的另一个​​常见组成部分是轨迹预测，其中有另一个组件，不仅告诉你你找到的汽车和行人，还告诉你他们可能会在接下来的几秒内到达的地方，这样你就可以避免像他们那样的人。重新开始。 驾驶安全需要的不仅仅是导航其他同步车和行人。 您还需要知道车道在哪里，以便您可以检测车道标记。 如果有交通信号灯，你还需要找出交通信号灯的位置，并显示红色，黄色或绿色信号。 有时候还有其他的障碍，例如意外的交通锥体，或者可能在你的车前有一群鹅步行者。 这也需要被检测到，以便您的汽车甚至可以避免除了汽车和行人之外的其他障碍。 在一个大型的自动驾驶汽车团队中，如果有一个团队或者很少有人在这里展示的每个盒子上都是红色的，那就不是出乎意料了，而是通过构建所有这些组件并将它们放在一起来构建一个自我-驾车。 正如您可以从这个相当复杂的AI管道示例，以及智能扬声器的四步AI管道的早期示例中所说，有时需要团队来构建复杂AI产品的所有这些不同组件。 我想在下一个视频中做的是与大家分享大型AI团队的关键角色。 如果你现在是一个人或小型人工智能团队，那没关系，但是我想让你有一个愿景，即建立一个大型人工智能团队，或许在遥远的未来，可能会是这样的。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-1 Week 3 Introduction 第 3 周 简介]]></title>
    <url>%2F2019%2F03%2F04%2Fweek3-01-week-3-introduction%2F</url>
    <content type="text"><![CDATA[欢迎回来。 在过去的两周里，您学习了什么AI，以及如何构建AI项目。 本周我们将看看我们已经讨论过的项目，并讨论项目如何适应公司的背景。 无论是营利性，非营利性，还是政府实体。 为了具体起见，无论你在哪种类型的组织，我都会谈论为公司建立人工智能同样适用。 现在，如果你本周听到的一些内容听起来像CEO级别的话题，请不要被吓倒。 这实际上非常有用，每个人都知道，希望，您的公司将帮助您的组织改善使用AI。 一家公司需要两到三年才能擅长人工智能。 不仅要接受一个AI项目，还要接受一系列有价值的AI项目，并且变得更加有效。 但是我希望本周做的事情可以帮助你描绘一个组织可以在更长的时间内完成任务的愿景。 但也可以在本周结束，你可以立即采取非常具体的步骤。 所以让我们开始吧。 详细地说，这些是你将在本周看到的主题。 首先是复杂AI产品的案例研究。 而不是像上周所看到的那样，单机器学习或数据科学模块。 本周，您将看到多个模块如何组合在一起构建更复杂的AI产品，如智能扬声器或自动驾驶汽车。 您还将了解AI团队中的主要角色。 因此，如果您认为您的公司可以建立一个拥有可能数十人甚至数百人的大型AI团队，那么这些人会做些什么呢？我们将开始绘制构建AI团队的路线图。 第三，您还将了解如何帮助您的公司擅长AI的AI转型手册。 除了做一个或多个有价值的项目之外，还有关于让整个公司擅长AI并希望更有效和更有价值的结果。 最后，其中一些步骤可能需要很短的时间才能完成。 我们将在本周的视频中详细介绍如何立即迈出第一步，在公司内建立人工智能。 除了这些主要话题之外，我们最后还会有几个可选视频，您可以在其中查看主要AI应用领域和技术的调查。 因此，在本周的视频之后，我希望您对如何帮助您的公司使用AI有一个良好的愿景，并且还有您可以立即采取的第一步。 让我们开始下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2-8 Technical tools for AI teams (optional) 人工智能团队的技术工具（可选）]]></title>
    <url>%2F2019%2F03%2F04%2Fweek2-08-technical-tools-for-ai-teams-optional%2F</url>
    <content type="text"><![CDATA[当您与AI团队合作时，您可能会听到他们使用的工具来构建这些AI系统。 在本视频中，我想与您分享最常用的AI工具的一些细节和名称，以便您能够更好地了解这些AI工程师正在做什么。 我们很幸运，今天的AIworld非常开放，许多团队将公开分享彼此的想法。 有很多机器学习开源框架，许多团队将使用它们来构建他们的系统。 所以，如果你听说过这些：TensorFlow，PyTorch，Keras，MXNet，CNTK，Caffe，PaddlePaddle，Scikit-learn，R或Weka，所有这些都是开源的机器学习框架，帮助AI团队在写作方面更有效率软件。 与AI技术一起，在这个名为Arxiv的网站上也可以在互联网上免费发布突破。 像这样拼写。 我希望其他学术界也可以自由地分享他们的研究，因为我已经亲眼目睹了在整个人工智能领域加速进步的程度。 最后，许多团队还将在互联网上免费分享他们的代码，最常见的是在名为GitHub的网站上。 这已经成为AI和AI其他领域开源软件的事实上的存储库。 通过使用适当的开源软件，许多团队可以比从头开始构建所有东西的速度快得多。 因此，例如，如果我在GitHub上在线搜索面部识别软件，您可能会找到这样的网页。 如果你向下滚动，这实际上有一个非常好的，非常易读的软件描述，可以在这个网站上找到识别人脸，甚至找到人脸的部分。 只有一吨软件可以免费下载，可以在互联网上做各种各样的事情，只需仔细检查许可证，或者AI团队会在产品中使用之前仔细检查许可证，但很多这些软件都是开源的，或者非常允许任何人使用的许可。 虽然GitHub是一个为工程师建立的技术网站，但如果你想要，你应该随意玩GitHub，看看人们在网上发布的人工智能软件的类型。 除了这些开源技术工具之外，您还经常听到AI工程师谈论CPU和GPU。 以下是这些术语的含义。 CPU是计算机中的计算机处理器，无论是您的桌面，笔记本电脑还是云中的计算机服务器。 CPU代表中央处理器，CPU由Intel，AMD和其他几家公司制造。 这在您的计算机中进行了大量的计算。 GPU代表图形处理单元。 从历史上看，GPU是用来处理图片的。 所以，如果你玩视频游戏，它可能是一个正在绘制花哨图形的GPU。 但是我们几年前发现的是，最初为处理图形而构建的硬件对于构建大型神经网络而言非常非常强大。 所以非常大的学习算法。 鉴于需要构建非常大的深度学习或非常大的神经网络系统，人工智能社区已经对越来越多的计算能力进行了无法满足的渴望，以培养更大和更大的神经网络。 事实证明，GPU非常适合我们需要用来训练超大神经网络的这种类型的计算。 因此，这就是为什么GPU在深度学习的兴起中扮演重要角色的原因。 而视频就是出售许多GPU的公司。 但包括高通在内的其他公司，以及制造自己的CPU的谷歌正在越来越多地制造专用硬件来为这些超大型神经网络供电。 最后，您可能会听到有关云计算与内部部署或简称的本地部署。 如果您从Amazon的AWS，Microsoft的Azure或Google的GCP租用计算服务器，以便使用其他人的服务来进行计算，则云部署需要参考。 然而，本地部署意味着购买您自己的计算服务器并在您自己的公司本地运行服务。 详细探讨这两个选项的优缺点超出了本视频的范围。 世界上很多人正在转向云部署。 无论您是在线搜索，都可以找到许多文章，讨论云与本地部署的优缺点。 您可能会听到最后一个术语，即Edge部署。 如果您正在构建自动驾驶汽车，则没有足够的时间将数据从自动驾驶汽车发送到云服务器以决定是否应该停止汽车，然后将该消息发送到自动驾驶汽车。 因此，计算必须通常发生在汽车内部的计算机中。 这称为边缘部署，您可以将处理器放在收集数据的位置，以便您可以快速处理数据并做出决策，而无需通过Internet传输数据以在其他地方进行处理。 如果你看看你家里的一些智能扬声器，这也是一个边缘部署，其中一些，而不是全部，但一些语音识别任务是由一个处理器完成的，该处理器就在你家里面的智能语言中。 。 Edge部署的主要优点是它可以增加系统的响应时间，还可以减少发送网络所需的数据量。 但是，有关Edgeversus Cloud和本地部署的优点和缺点，您还可以在线搜索以了解更多信息。 感谢在AI工程师使用的技术工具上完成这个可选视频。 希望当你听到他们提到这些工具时，你会开始对他们的意思有所了解。 我期待下周为你服务。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2-7 Working with an AI team 与人工智能团队合作]]></title>
    <url>%2F2019%2F03%2F04%2Fweek2-07-working-with-an-ai-team%2F</url>
    <content type="text"><![CDATA[假设您找到了一个令人兴奋的项目，您想要执行该项目，您如何与该项目的aAI团队合作？ 在本视频中，您将了解AI团队如何思考数据，以及如何与AI团队进行交互以帮助他们在项目上取得成功。 现在，有一点需要注意的是，无论你有一个很酷的想法，但你没有访问AI团队，你没有任何AI工程师的访问权限。 幸运的是，在今天的世界里，如果你有任何一个你可以鼓励你的一些工程学朋友参加机器学习或深度学习的在线课程，通常会给他们足够的知识来开始尝试，做一个合理的尝试这些项目类型。 那么，让我们谈谈你如何与AI团队合作。 首先，如果您可以为项目指定验收标准，它确实有助于您的AI团队。 我在自动视力检测方面做了很多工作。 因此，我将在少数幻灯片中将其用作运行示例。 假设您的目标是检测咖啡杯中的缺陷，其准确度至少达到95％。 因此，这可能是您接受此项目的标准。 但95％的准确度，你如何测量准确度？ AI团队需要的一个东西是用于测量准确性的数据集。 因此，数据集只是一组像这样的图片与标签一起，设计输出B表示前两个咖啡杯是好的，第三个是有缺陷的。 因此，作为您接受标准的规范的一部分，您应该确保AI团队有一个数据库，用于衡量性能，如果他们达到95％的准确率，他们就可以知道。 此数据集的正式术语称为测试集。 测试集可能不会太大，也许1000张图片对于这个例子来说就好了。 但是，如果您咨询AI专家，他们可以让您更好地了解测试集需要多大才能评估他们是否达到95％的准确率。 EA系统的一个新颖部分是它们的性能通常以统计方式指定。 因此，不是要求人工智能系统完美地完成某些事情，而是经常看到我们想要的AI系统能够像这个例子那样以一定的百分比精度执行。 因此，在指定您的验收标准时，请考虑您是否需要以统计方式指定您的验收标准，而您在平均时间指定的时间或其得到正确答案的时间百分比。 让我们更深入地探讨测试集的概念。 这就是AI团队关于数据的方式。 AI团队将数据分组到两个主要数据集。 第一个称为训练集，第二个称为测试集，我们已经讨论了一下。 训练集只是一组图片以及标签，显示这些图片中的每一张是咖啡杯还是有缺陷的咖啡杯。 因此，训练集给出了输入的示例，即咖啡杯的图片以及所需的输出B，无论是可能的还是有缺陷的。 所以，考虑到这个训练集，机器学习算法将要做的是学习，换句话说，计算或计算从A到B的一些映射，你现在有一个软件可以输入输入A并试图弄清楚是什么适当的输出B. 因此，训练集是机器学习软件的输入，可以让它弄清楚这个A到B的映射是什么。 AI团队将使用的第二个数据集是测试集。 正如您所见，这只是另一组图像，与训练集不同，也提供了标签。 AI团队评估其学习算法性能的方式是将图像放入AI软件的测试集中，并查看AI软件输出的内容。 例如，如果在这三个测试集图像上，AI软件输出就可以了，对此可以，也可以，然后我们会说他们有三个例子中的两个正确，所以这是一个66。 精度7％。 在这个图中，上面的训练集和测试集只有三张图片，实际上这两个数据集当然都会更大。 你发现训练集的表格问题比测试集大得多。 但您可以与AI工程师交谈，了解他们在给定问题中需要多少数据。 最后，由于技术原因，一些AI团队不仅需要一个，而且还需要两个不同的测试集。 如果你听到人工智能团队谈论开发或者验证测试，那就是他们正在使用的第二个测试集。 他们需要两个测试集的原因是技术性很强，超出了本课程的范围，但如果AI团队要求您提供两种不同的测试集，那么尝试将它们提供给他们是相当合理的。 在结束这段视频之前，我想敦促你避免期待从你的AI软件中获得100％的准确性。 这就是我的意思，让我们说这是你在上一张幻灯片中看到过的测试集。 但是，让我在这个测试集中添加一些示例。 以下是一些人工智能软件可能无法100％准确的原因。 首先，今天的机器学习技术尽管功能非常强大，但仍然存在局限性，它们只能做到一切。 所以，你可能正在研究一个问题，即使对于今天的机器学习技术来说这也是非常困难的。 第二，数据不足。 如果您没有足够的数据，如果您没有足够的AI软件培训数据来学习，那么可能很难达到非常高的准确度。 第三，数据混乱，有时数据可能被错误标记。 例如，这里的绿色咖啡杯看起来对我来说完全没问题，因此，它的标签看起来像是一个不正确的标签，这会损害你的AI软件的性能。 数据也可能不明确。 例如，看起来这个咖啡杯在那边有一个小划痕，这是一个非常小的划痕，所以，也许我们会想到这一点虽然没问题。 但也许这实际上应该是一个缺陷，或者甚至不同的专家都不同意，如果这个特定的咖啡杯是好的，应该通过检查步骤。 其中一些问题可以得到改善。 例如，如果您没有足够的数据，则可以尝试收集更多数据，而更多数据通常会有所帮助。 或者您也可以尝试清理错误标记的数据，或尝试让您的factoriesexperts更好地同意这些模糊的标签。 因此，有很多方法可以让这些东西变得更好，但是，即使没有达到100％的准确度，许多AI系统仍然具有极高的价值。 因此，我将敦促您与您的AI工程师讨论试图达到的合理准确度水平？ 然后尝试找到既通过技术尽职调查又需要商业勤奋的东西，而不一定需要100％的准确性。 恭喜您完成了本周的视频。 您现在知道它是什么样的以及构建AI项目需要什么。 我希望你开始头脑风暴并探索一些想法。 还有一个可选的视频编程可以帮助AI团队使用的一些技术工具。 但无论哪种方式，我都期待着在下周见到你，在那里你将了解AI项目是否适合大公司的背景。 期待下周为你服务。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2-6 How to choose an AI project (Part 2) 如何选择人工智能项目（第2部分）]]></title>
    <url>%2F2019%2F03%2F04%2Fweek2-06-how-to-choose-an-ai-project-part-2%2F</url>
    <content type="text"><![CDATA[也许你对可能的AI项目有很多想法。 但是在承诺之前，你如何确保这真的是一个值得的项目？如果这是一个快速的项目，可能只需要几天就可以立即跳进去看看它是否有效，但是一些人工智能项目可能需要几个月的时间执行。 在这个视频中，我想引导您完成我用来仔细检查项目是否值得花费数月时间的过程。 让我们来看看。 在投入大型人工智能项目之前，我通常会对此进行努力。 尽职调查在法律世界中具有特定的意义。 但非正式地说，它只是意味着你想花一些时间来确保你所希望的真实是真的。 你已经看到了最好的AI项目是如何可行的。 所以，这是AI可以做的事情，也是有价值的。 我们真的想选择这两组的交叉项目。 因此，为了确保项目的可行性，我通常会进行技术调查，并确保项目有价值，我通常会经历业务尽职调查。 让我告诉你更多这两个步骤。 技术勤勉是确保您构建的AI系统真正可行的过程，真的是可行的。 因此，您可以与AI专家讨论AI系统是否能够真正满足所需的性能水平。 例如，如果您希望构建一个准确率为95％的语音系统，那么咨询AI专家或者阅读一些贸易文献可以让您了解这是否可行。 或者，如果您希望系统检查工厂中的咖啡杯，您需要系统准确率达到99％。 再次，这实际上是否适用于当今的技术？技术尽职调查的第二个重要问题是需要多少数据才能达到理想的性能水平，您是否有办法获得如此多的数据。 第三，将是工程时间表，试图确定需要多长时间以及建立一个你想建立的系统需要多少人。 除了技术上的勤奋，我还经常进行商业努力，以确保您设想的项目真正对业务有价值。 因此，许多人工智能项目将通过降低成本来推动估值。 例如，通过自动执行一些任务或通过在系统中挤压更多的效率。 许多人工智能系统也可以增加收入。 例如，驾驶更多人查看您的购物车，或者您可能正在构建AI系统，以帮助您推出新产品或新业务。 因此，业务勤奋是仔细思考您正在构建的AI系统的过程，例如95％准确的语音识别系统或99的视觉检查系统。 9％准确，可以让您实现您的业务目标。 您的业​​务目标是改善您当前的业务，还是在您的公司中创建全新的业务。 在进行业务调查时，我经常会建立电子表格财务模型来定量估算价值，例如估算实际节省了多少美元，或者我们认为在条目收入方面是合理的假设，并建模以前与项目相关的经济学承诺在一个项目上做了几个月的努力。 虽然没有在这张幻灯片上明确列出，但我希望你也可以考虑做第三种勤奋工作，即道德勤奋。 我认为人工智能可以做很多事情甚至可以赚很多钱，但这可能不会让人更好。 因此，除了技术勤勉和商业勤勉之外，我希望你们也要进行道德操守，并确保无论你做什么，实际上都会让人性和社交能力更好。 我们也会在本课程的最后一周谈论这个问题。 当你计划你的AI项目时，你还必须决定你想要建立还是购买？这是IT世界中一个古老的问题，我们也在AI中面对这个问题。 例如，现在几乎没有公司建立自己的计算机。 他们购买了某人的计算机，几乎没有公司建立自己的Wi-Fi路由器，只需购买商用Wi-Fi路由器。 机器学习和数据科学怎么样？机器学习项目可以在内部或外包。 我已经成功地看到了这两种模型。 有时，如果您外包机器学习项目，您可以更快地访问人才并在项目上快速完成工作。 如果您最终建立自己的内部AI团队并且可以在内部进行这些项目，那就太好了。 下周我们将更详细地讨论AI翻译手册时，你会听到更多关于这个的消息。 与机器学习项目不同，数据科学项目更常见于内部。 他们并非不可能外包，你有时可以将它们外包，但我所看到的是，数据科学项目与你的业务密切相关，因此需要对你的业务进行非常深入的日常知识才能实现最佳的数据科学项目。 因此，作为一个百分比，作为一个分数，我看到内部数据科学项目比机器学习项目更多。 最后，在每个行业中，有些事情将成为行业标准，你应该避免建立这些标准。 构建与购买问题的常见答案是，构建对您来说非常专业或对您完全专业化的东西，或者他们将允许您建立一个独特的防御优势，但是那些将成为行业标准的东西可能是其他公司将构建和你购买它而不是在公司内部建造它会更有效率。 我的一个团队有一个非常诗意的短语，“不要在火车前冲刺”，这意味着，如果这是一列在铁路轨道上运行的火车，那就是带有烟雾的小烟囱。 你不想做的就是那个试图快速冲刺和紧固火车的人或工程师。 列车是行业标准的解决方案，因此，如果有一家公司可能是一家初创公司，也许一家大公司或者可能是开源行业正在构建行业标准解决方案，那么您可能希望避免尝试更快更快地运行火车。 因为即使你可以在短期内冲刺得更快，最终火车会赶上并撞到有人试图在火车前进行冲刺。 因此，当建立一个行业标准解决方案的巨大力量时，你可能会更好地接受行业标准或拥抱别人的平台，而不是试图在内部完成所有工作。 我们都生活在一个有限的资源，有限的时间，有限的数据，有限的工程资源的世界，所以，我希望你可以把这些资源集中在项目上最独特的，并将为你的公司带来最大的不同。 通过技术培训和业务尽职调查，我希望您可以开始识别具有潜在价值或对您的业务有前途的项目。 如果该项目是一家大公司，也许需要花费几个月的时间。 在承诺参与项目之前，我甚至花了几周的时间进行这种勤奋。 现在，假设您找到了一些很有前途的项目，您如何与AI团队合作？您如何与AI团队合作以尝试完成这些项目？让我们在下一个视频中讨论这个问题。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2-5 How to choose an AI project (Part 1) 如何选择人工智能项目（第1部分）]]></title>
    <url>%2F2019%2F03%2F04%2Fweek2-05-how-to-choose-an-ai-project-part-1%2F</url>
    <content type="text"><![CDATA[如果你想在AI项目上尝试一下，你如何选择一个有价值的项目来工作呢？不要指望一个想法在一夜之间过来。 有时会发生这种情况，但有时候还需要几天或几周的时间来提出一个值得追求的想法。 在这个视频中，您将看到一个用于头脑风暴的框架，用于追求可能令人兴奋的AI项目。 假设您想为您的企业构建AI项目。 你已经看到了AI无法做到的一切，所以人工智能可以做的事情就会出现。 所以让我们让圆圈代表AI可以做的事情。 现在，还有一些对您的业务有价值的事情。 因此，让我们让第二个圆圈代表一组对您的业务有价值的东西。 您想要做的是尝试选择位于这两个集合交叉点的项目，因此您选择既可行又可以通过AI完成的项目，这对您的业务也很有价值。 因此，AI专家将倾向于很好地理解左边的集合中的内容和内容。 领域专家，您的业务专家，无论是销售和市场营销，还是农业或其他方面，都能最好地了解对您的业务有何实际价值。 因此，当集体讨论人工智能并且对您的业务有价值的项目时，我会经常组建一个团队，其中包括熟悉AI的人员，以及您商业领域的专家，共同集思广益。 因此，他们可以一起尝试在这两个集合的交叉点识别项目。 因此，有时我们也称这些跨职能团队，这意味着团队既包括AI专家，也包括领域专家，这意味着您所在领域的专家。 头脑风暴项目时，有一个框架，我已经使用了很多我认为有用的公司。 因此，让我与您分享三个原则或三个想法，了解如何开展一个茶馆项目。 首先，即使有很多关于人工智能自动化工作的新闻报道，这是一个需要解决的重要的社会问题，在考虑具体的人工智能项目时，我发现考虑自动化任务而不是自动化工作更有用。 在呼叫中心的运营中，呼叫中心会发生很多任务。 从接听电话的人接听电话到回复电子邮件，采取特定行动，例如在客户请求的一半上发出退款。 但是，在呼叫中心的所有这些任务中，可能有一个，呼叫路由或电子邮件路由，这可能特别适合机器学习自动化。 通过查看员工团队所做的所有这些任务，并选择一个可以让您在短期内选择最有成效的自动化项目。 让我们看另一个例子，放射科医生的工作。 有很多关于我自动化放射科医师工作的新闻，但放射科医生实际上有很多东西。 他们阅读X光片，这非常重要，但他们也参与了他们的继续教育。 他们咨询其他医生，他们可能会指导年轻的医生，其中一些医生也会直接咨询患者。 因此，通过查看放射科医师所做的所有这些任务，您可以确定其中一个，让我们说用于阅读X射线的AI辅助或人工智能自动化，这使您可以选择最有成效的项目。 所以我建议的是，如果你看看你的业务，考虑一下人们所做的任务，如果你只能识别其中一个，或者只是其中一个，那么可以使用机器学习来自动化。 当我与公司的大型公司头脑风暴人工智能项目的首席执行官会面时，我还要问的一个常见问题是，商业价值的主要推动因素是什么？有时候找到人工智能解决方案或数据科学解决方案来增强这一点可能非常有价值。 最后，第三个问题，我曾经问过，有时候会提出有价值的项目想法，这是你企业的主要痛点吗？其中一些问题可以通过人工智能解决，其中一些问题无法用人工智能解决。 但通过了解业务中的主要观点，这也可以为集思广益AI项目创造一个有用的起点。 我有最后一条关于脑力激励项目的建议，即使没有大量数据，即使没有大数据，你也可以取得进步。 现在不要误解我的意思，让更多的数据几乎从不伤害，除了可能需要为磁盘空间或网络带宽支付更多的费用来传输和存储数据，拥有更多的数据总是只有帮助。 而且我喜欢拥有大量数据。 数据也是如此，因为网络搜索等一些有线网络可以防范。 网络搜索是一项长尾业务，这意味着有很多非常非常罕见的网络查询。 因此，当您搜索所有这些罕见的Web查询时，查看人们点击的内容确实有助于领先的网络搜索引擎获得更好的搜索体验。 如此大的数据是很好的，当你可以得到它，但我认为大数据有时也过度炒作，即使使用小数据集，你仍然可以经常取得进展。 这是一个例子，假设你正在为咖啡杯建立一个自动视觉检测系统。 所以你想自动检测右边的咖啡杯有缺陷。 好吧，如果你有一百万张好咖啡杯和有缺陷的咖啡杯的图片，那么就会有很多好的咖啡杯照片供你的AI系统使用。 但是我希望你没有制造出100万个有缺陷的咖啡杯，因为这样的东西就像扔掉一样非常昂贵。 因此，有时只需要100，或者1000，或者有时可能只有10，您就可以在机器学习项目中开始。 您需要的数据量非常依赖于问题，与AI工程师或AI专家交谈可以帮助您更好地理解。 有一些问题，1000张图片可能不够，你需要大数据获得良好的性能。 但我的建议是，不要因为你没有大量的数据而放弃。 即使使用小型数据集，您仍然可以取得进步。 在这段视频中，您看到了一个头脑风暴的框架，以及一套试图提出可以用AI实现的项目的标准，这些标准对您的业务也很有价值。 现在，已经集思广益一个项目列表，你如何选择一个或选择一小部分实际承诺和工作？让我们在下一个视频中谈论这个。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2-4 Every job function needs to learn how to use data 每个工作职能都需要学习如何使用数据]]></title>
    <url>%2F2019%2F03%2F04%2Fweek2-04-every-job-function-needs-to-learn-how-to-use-data%2F</url>
    <content type="text"><![CDATA[数据正在改变各种不同的工作职能，无论您是在招聘或销售，营销还是制造业或农业，数据可能会改变您的工作职能。 过去几十年发生的事情是我们社会的数字化。 因此，调查更像​​是以数字格式进行调查，或者医生仍然会写一些手写笔记，而医生手写笔记本可能更像是一个数字记录，因此在几乎所有单一的工作职能中，而不是像这样进行报纸调查。 这种数据可用性意味着很有可能通过数据科学或机器学习等工具帮助您的工作职能。 让我们来看看。 在这个视频中，我想了解许多不同的工作职能，并讨论数据科学和机器学习如何能够或将会影响不同类型的工作。 让我们从销售开始吧。 您已经在最后一个视频中看到了数据科学如何用于优化销售漏斗。 机器学习怎么样？如果你是一个销售人员，你可能会有一套关于不同人的线索，你可以伸出手来说服他们从你的公司购买东西。 机器学习可以帮助您优先考虑这些线索。 因此，您可能希望优先考虑召集大型公司的首席执行官而不是小型公司的实习生，这种类型的自动化潜在客户排序使销售人员更有效率。 让我们看看更多的例子。 假设您正在制造直线经理。 您已经看到数据科学可以帮助您优化生产线。 机器学习怎么样？这个制造过程的一个步骤是最终检查。 事实上，在今天，在许多工厂中，可能有数百或数千人使用人类眼球检查物品，也许是咖啡杯，也许是其他人，看看它们是否有划痕或凹痕，这就是所谓的检查。 因此，机器学习可以接受这样的输入，这样的数据集，并学会自动判断咖啡杯是否有缺陷。 通过自动查找划痕或凹痕，可以降低人工成本并提高工厂质量。 这种类型的自动视觉检查是我认为会对制造产生重大影响的技术之一。 这也是我一直在努力的事情。 让我们看看更多的例子。 如何招聘？当招募某人加入贵公司时，可能会有一个非常可预测的步骤，招聘人员或其他人会向候选人发送电子邮件然后与他们打电话，带他们到现场进行面试，然后延长报价并且可以接近报价。 类似于数据科学如何用于优化销售漏斗，招聘也可以使用数据科学来优化招聘渠道，事实上许多招聘组织今天都这样做。 例如，如果您发现几乎没有人从手机屏幕步骤到现场采访步骤，那么您可能会得出结论，可能有太多人进入手机屏幕阶段或者可能正在进行电话屏幕的人 太难了，你应该让更多的人进入现场采访阶段。 这种类型的数据科学已经对招聘产生了影响。 机器学习项目怎么样？嗯，招聘的一个步骤是筛选大量的简历，以决定谁与你联系。 所以，你可能不得不看一下简历并说：“是的，让我们给他们发电子邮件”，看一下不同的说法，“不，让我们不要继续前进这个候选人。“ 机器学习正在开始进入自动化的简历筛选。 是否提出了一些重要的问题，例如确保您的AI软件没有表现出不良形式的偏见并公平对待人们，但机器学习开始进入这一点，我希望可以这样做，同时确保系统符合道德和公平。 在AI For Everyone课程的最后一周，您还将了解AI中的公平和道德问题。 如果您从事营销工作会怎么样？优化网站性能的常用方法之一就是AB测试，您可以在其中启动两个版本的网站。 此处版本A有一个红色按钮，版本B有一个绿色按钮，您可以测量哪些网站会让人们点击更多。 因此，通过这种类型的数据，数据科学团队可以帮助您获得洞察力并建议优化网站的假设或操作。 机器学习和营销怎么样？今天很多网站都会提供定制的产品推荐，向您展示您最有可能想要购买的东西，这实际上大大增加了这些网站的销售量。 例如，一个服装网站在看到我购物之后的路上，希望只是向我推荐蓝色衬衫，因为坦率地说这是我买过的唯一一种类型的衬衫，但也许其他客户会比我的更多样化和更有趣的建议。 但是今天，这些定制的产品推荐实际上在许多大型在线商务网站上占据了很大比例的销售额。 完全不同的部门的最后一个例子。 假设你在农业工作。 也许你是一个在轻工业农场工作的农民，数据科学如何帮助你？今天农民已经在使用数据科学进行作物分析，你可以在这里获取土壤条件，天气条件，不同作物的存在的数据市场和数据科学团队建议种植什么，何时种植以改善使用，同时保持农场土壤的状况。 这种类型的数据科学将在农业中发挥越来越大的作用。 让我们看看机器学习的例子。 我认为农业最令人兴奋的变化之一就是精准农业。 这是我用手机拍摄的农场照片。 在右上方是棉花植物，中间显示的是杂草。 通过机器学习，我们开始看到可以进入农场的产品，拍摄照片并以非常精确的方式将杂草杀手喷到杂草上，这样它就可以去除杂草，但不必喷洒过多的杂草。杂草杀手。 这种机器学习技术既有助于农民提高作物产量，又有助于保护环境。 在这段视频中，您了解了所有这些工作职能，从销售，招聘到营销到制造农业农业，所有这些工作职能如何受到数据，数据科学和机器学习的影响。 似乎你可以用AI做很多不同的事情。 但是，你如何选择一个有前途的项目呢？让我们在下一个视频中讨论这个问题。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2-3 Workflow of a data science project 数据科学项目的工作流程]]></title>
    <url>%2F2019%2F03%2F04%2Fweek2-03-workflow-of-a-data-science-project%2F</url>
    <content type="text"><![CDATA[与机器学习项目不同，数据科学项目的输出通常是一组可操作的见解，一组可能导致您以不同方式执行操作的见解。 因此，数据科学项目的工作流程与机器学习项目不同。 让我们来看看数据科学项目的一个步骤。 作为我们的运行示例，假设您想要优化销售渠道。 假设您经营电子商务或在线购物网站销售咖啡杯，以便用户向您购买咖啡杯，通常会有一系列步骤。 首先，他们会看到我们的网站，看看不同的咖啡杯报价，然后最终，他们必须进入产品页面，然后他们将不得不穿上他们的购物车，然后去购物车页面，然后他们终于要结账了。 因此，如果您想优化销售渠道以确保尽可能多的人了解这些步骤，您如何使用数据科学来帮助解决这个问题？ 让我们看看数据科学项目的关键步骤。 第一步是收集数据。 因此，在我们看到的网站上，您可能拥有一个数据集，用于存储不同用户何时访问不同的网页。 在这个简单的例子中，我假设你可以找出用户来自的国家，例如，通过查看计算机的地址，称为IP地址，并弄清楚他们来自哪个国家。 但实际上，您通常可以获得有关用户的更多数据，而不仅仅是他们来自的国家。 第二步是分析数据。 您的数据科学团队可能会对影响销售渠道绩效的因素有很多想法。 例如，他们可能会认为海外客户会被国际运输成本吓跑，这就是为什么很多人都会去结账页面而不是实际结账的原因。 如果这是真的，那么您可能会考虑是否将运输成本的部分纳入实际产品成本，或者您的数据科学团队可能会认为数据中存在明显的假期。 也许更多的人会在假日购物，因为他们正在购买礼物，或者更少的人会在假期购物，因为他们待在家里，而不是有时从他们的工作电脑购物。 在一些国家，可能会有一些时间的情况，在那里观察午睡，所以休息时间就像下午休息一样，在线购物者可能会减少，而且大豆的销售可能会下降。 然后，他们可能会建议您在午睡期间减少广告费用，因为那时人们会更少上网购买。 因此，一个优秀的数据科学团队可能会有很多想法，所以他们会尝试很多想法，或者会说多次迭代以获得良好的见解。 最后，数据科学团队将这些见解提炼到较少数量的假设，这些假设是关于哪些方面可能进展顺利，哪些方面可能会变得很糟糕，以及少数建议的行动，例如将运输成本纳入产品成本而不是将其纳入产品成本单独的订单项。 当您采取一些建议的操作并将这些更改部署到您的网站时，您就会开始获取新数据，因为用户在午睡时不同地宣传或者有不同的检查策略时会表现出不同的行为。 然后，您的数据科学团队可以继续收集数据，我们会定期分析新数据，看看他们是否能够提出更好的假设，以及随着时间的推移采取更好的行动。 因此，数据科学项目的关键步骤是收集数据，分析数据，然后建议假设和行动，然后继续获取数据并定期重新分析数据。 让我们采用这个框架并将其应用于一个新问题，以优化制造生产线。 因此，我们将采取这三个步骤，并在下一张幻灯片中使用它们。 假设您经营的工厂每月生产数千个咖啡杯，您希望优化生产线。 因此，这些是制造咖啡杯的关键步骤。 第一步是混合粘土，所以要确保加入适量的水。 第二步是采用这种粘土来塑造杯子。 然后你必须添加釉料，所以添加着色，保护盖。 然后你必须加热这个杯子，我们称之为烧窑。 最后，你会检查马克杯，以确保马克杯中没有凹痕，并且在将它送给顾客之前它没有破裂。 因此，一个常见的问题制造是优化该生产线的产量，以确保尽可能少的损坏的咖啡杯生产，因为那些是你扔掉的咖啡杯，导致时间和材料浪费。 数据科学项目的第一步是什么？ 我希望你记得从最后一张幻灯片开始，第一步是收集数据。 因此，例如，您可以保存关于您混合的不同批次粘土的数据，例如谁提供粘土以及混合了多长时间，或者粘土中含有多少水分，您添加了多少水。 您可能还会收集有关您制作的不同批次杯子的数据。 那批次的湿度是多少？ 窑内的温度是多少？你在窑里烧了多久？ 鉴于所有这些数据，您将要求数据科学团队分析数据，他们将像以前一样，迭代许多时间以获得良好的见解。 所以，他们可能会发现，例如，每当湿度太低而且温度太高以至于杯子里有裂缝，或者他们可能会发现因为下午的温暖，你需要调整湿度和温度，这取决于一天中的时间。 根据您的数据科学团队的见解，您可以获得关于如何改变操作和生产线以提高生产线生产率的假设和行动的建议。 部署更改后，您将获得可以重新分析的新数据，以便他们可以继续优化您的生产线的性能。 总而言之，数据科学项目的关键步骤是收集数据，分析数据，然后建议假设和行动。 在这个视频和最后一个视频中，您看到了一些机器学习项目和数据科学项目的例子。 事实证明，机器学习和数据科学正在影响几乎所有单一的工作职能。 我想在下一个视频中做的是向您展示这些想法如何影响许多工作职能，包括您的工作职能，当然也包括您的许多同事。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2-2 Workflow of a machine learning project 机器学习项目的工作流程]]></title>
    <url>%2F2019%2F03%2F04%2Fweek2-02-workflow-of-a-machine-learning-project%2F</url>
    <content type="text"><![CDATA[机器学习算法可以学习输出到输出或A到B映射。 那么，你如何建立机器学习项目？在这个视频中，你将了解机器学习项目的工作流程。 让我们来看看。 作为一个运行的例子，我将使用语音识别。 因此，你们中的一些人可能在家中安装了Amazon Echo或Google Home或Apple Siri设备或BaiduDuerOS设备。 几年前，我在Google的语音识别系统上做了一些工作，这也引领了百度的DuerOS项目。 今天，我的厨房里竟然有一个亚马逊回声。 因此，每次我煮鸡蛋时，我会说，“Alexa，设定计时器三分钟”，然后它让我知道三分钟什么时候，我的鸡蛋准备好了。 那么，你如何建立一个语音识别系统，可以识别你说“Alexa”，“嘿，谷歌”，“嘿，Siri”或“你好，百度”？让我们来看看关键步骤机器学习项目。 为简单起见，我将使用Amazon Echo或检测Alexa关键字作为此运行示例。 如果您想构建AI系统或构建机器学习系统以确定用户何时说出Alexa这个词，那么第一步就是收集数据。 所以，这意味着，你可以四处走动，让一些人为你说“Alexa”这个词，然后你录制它的音频。 你也会得到一群人说“你好”之类的其他词，或说出很多其他的话，并记录下来的音频。 收集了大量的音频数据之后，很多人都说“Alexa”或其他事情，第二步就是对这个模型进行解读。 这意味着您将使用机器学习算法来学习输出到A到B映射的输入，其中输入A将是音频剪辑。 在上面的第一个音频剪辑的情况下，希望它会告诉你用户说“Alexa”，并且在右边显示的音频剪辑2的情况下，希望系统将学习识别用户说“你好。“ 每当AI团队开始训练模型时，意味着要学习A toB或输入输出映射，每次都会发生什么事情，这是第一次尝试不能正常工作。 总是如此，团队需要多次尝试或在AI中，我们多次调用此迭代。 你必须迭代多次，希望模型看起来很好。 第三步是实际部署模型。 这意味着您将此AI软件输入到实际的智能语言中，并将其发送给一小组测试用户或大量用户。 许多AI产品中发生的事情是，当您发货时，您会看到它开始获取新数据，并且它可能无法像您最初希望的那样工作。 所以，例如，我来自英国。 所以，我要去英国人。 但是，假设你已经在美国口音的扬声器上训练了你的语音识别系统，然后你将这个聪明的英语发送到英国，你开始让英国口音的人说“Alexa。“ 他们可能会发现它并不像你所希望的那样认出演讲。 当这种情况发生时，希望你可以获得数据，例如英国口音的扬声器可能不像你希望的那样工作，然后使用这些数据来维护和更新模型。 因此，总而言之，机器学习项目的关键步骤是收集数据，训练模型，A到B映射，然后部署模型。 在这些步骤中，通常需要进行大量的迭代，这意味着微调可以使模型更好地工作或者甚至在将数据发送到数据库后获取数据，希望产品更好，这可能会也可能不会取决于您是否可行能够获得数据。 让我们看看这三个步骤，看看它们如何应用于构建自动驾驶汽车关键部件的不同项目。 因此，请记住关键步骤，收集数据，训练模型，部署模型，因为我们将在下一张幻灯片中重新审视这些步骤。 假设你正在建造一辆自动驾驶汽车。 自动驾驶汽车的关键部件之一是机器学习算法，它可以作为输入，比如图片，显示汽车前面的东西，并告诉您其他车辆的位置。 那么，构建这个机器学习系统的第一步是什么呢？希望你能从最后一张幻灯片中记得第一步是收集数据。 因此，如果您的目标是使用机器学习算法，可以将图像作为输入并输出其他车辆的位置，那么您需要收集的数据既可以是图像，也可以是您希望AI系统输出的其他车辆的位置。 所以，让我们假设您从这样的一些图片开始。 这些是机器学习算法的输入。 你还需要告诉它你想要的输出B. 因此，对于每张图片，您都会在想要检测的图片中围绕汽车绘制一个矩形。 在这张幻灯片上，我手绘这些矩形，但在实践中，你会使用一些软件，让你绘制完美的矩形而不是这些手绘的矩形。 然后，创建了这个数据集，第二步是什么？希望你记住，第二步是训练模型。 现在，当你的AI工程师开始训练一个模型时，他们最初会发现它并不能很好地发挥作用。 例如，鉴于这张照片，也许软件，前几次尝试，认为这是一辆汽车。 只有通过多次迭代，你才能获得更好的结果，然后才能确定汽车实际上是哪里。 最后，第三步是什么？它是部署模型。 当然，在自动驾驶世界中，重要的是将安全视为第一，并部署模型或仅以可以保护安全的方式测试模型。 但是当你将汽车中的软件放在路上时，你可能会发现有新型车辆，比如高尔夫球车，软件检测得不是很好。 因此，您可以获取数据，比如这些高尔夫球车的图片，使用新数据来维护和更新模型，希望您可以让您的AI软件不断变得更好，直到您最终可以做到的软件检测其他类似汽车的相当不错的工作。 在本视频中，您了解了机器学习项目的关键步骤，即收集数据，训练模型，然后部署模型。 接下来，让我们来看看数据科学项目的关键步骤或工作流程是什么。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2-1 Week 2 Introduction 第 2 周 简介]]></title>
    <url>%2F2019%2F03%2F04%2Fweek2-01-week-2-introduction%2F</url>
    <content type="text"><![CDATA[欢迎回来。 上周，您了解了人工智能和机器学习技术的基础知识。 但是如果你想在一个项目中使用这项技术，或者如果你想在一个更大的公司做项目，或者甚至有什么东西能够与你的公司战略保持一致，那么你如何在项目中使用这项技术呢？让我们来看看。 首先，在本周，您将了解AI项目的工作流程。 不同的项目有不同的步骤。 因此，就像生日派对有一系列可预测的步骤一样。 首先，你计算出客人名单，找到一个场地，然后订购生日蛋糕，发送邀请，等等。 因此，AI项目也有一系列可预测的步骤。 因此，通过这个，您可以了解AI项目的工作流程，了解在AI项目中工作的感受。 第二，你如何选择一个AI项目？似乎你可以做很多事情。 本周你学到的第二件事是一个集思广益和选择潜在促进项目的框架，无论是你自己还是一些朋友，或者作为更大的公司努力的一部分。 最后，您还将学习如何组织数据以及团队，这也可能只是您是一些朋友或更大的企业团队。 我们学习如何组织数据和团队以执行AI项目。 到本周末，你知道它的感觉以及如何建立你自己的AI项目，也许你将能够开始探索你的一些朋友的想法。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week1-9 Non-technical explanation of deep learning (Part 2, optional) 深度学习的非技术性解释（第2部分，可选）]]></title>
    <url>%2F2019%2F03%2F04%2Fweek1-09-non-technical-explanation-of-deep-learning-part-2-optional%2F</url>
    <content type="text"><![CDATA[在上一个视频中，您看到了神经网络如何应用于需求预测，但是新网络如何看待图片并弄清楚图片中的内容？或者听一个音频片段并了解音频片段中的内容？让我们来看看看一下将神经网络应用于人脸识别的更复杂的例子。 假设您想构建一个系统来识别图片中的人物，一个软件如何看待这张图片并找出其中人物的身份？让我们放大到这样的小方块，以便更好地了解计算机如何看待图片。 在你和我看到人眼的地方，计算机会看到它，并且看到这个像素亮度值的网格告诉它，对于图像中的每个像素，该像素有多亮。 如果它是黑色和白色或灰度图像，那么每个像素将对应于一个数字，告诉你这个像素是否明亮。 如果它是彩色图像，那么每个像素都会有三个数字，对应于该像素的红色，绿色和蓝色元素。 所以，神经网络工作就是把很多数字作为输入，然后告诉你图片中人物的名字。 在上一个视频中，您看到了神经网络如何将四个数字作为输入对应于价格，运输成本，营销金额以及T恤和布料需求的布料。 在这个例子中，神经网络只需输入更多的数字，对应于该图像的所有像素亮度值。 如果这张图片的分辨率是1000像素乘1000像素，那么这是一百万像素。 因此，如果它是一个黑色和白色或灰度图像，这个神经网络作为输入一百万个数字对应于该图像中所有一百万个像素的亮度，或者如果是一个彩色图像，它将作为输入三百万个数字对应于红色，绿色，以及此图像中这一百万像素中的每一个的蓝色值。 与以前类似，你会有许多这些人工神经元计算各种值，并且你不应该弄清楚这些神经元应该计算什么。 神经网络将自行配置。 通常情况下，当你给它一个图像时，神经网络早期部分的神经元将学习检测图像中的边缘，然后检测叶片，然后学会检测对象的部分。 因此，他们学会检测眼睛和鼻子以及脸颊的形状和嘴巴的形状，然后后面的神经元，进一步向右，将学会检测不同形状的面部，最后，将所有这些放在一起输出身份图像中的人。 再一次，神经网络的神奇之处在于你并不需要担心它在中间的情况。 所有你需要做的就是给它提供很多这样的图片数据，A，以及正确的身份B和学习算法将自己弄清楚中间的每个神经元应该在计算什么。 恭喜您完成了本周的所有视频。 您现在知道机器学习和数据科学是如何工作的。 我期待着在下周的视频中看到你，以及你将如何建立自己的机器学习者数据科学项目。 下周见。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week1-8 Non-technical explanation of deep learning (Part 1, optional) 深度学习的非技术性解释（第1部分，可选）]]></title>
    <url>%2F2019%2F03%2F04%2Fweek1-08-non-technical-explanation-of-deep-learning-part-1-optional%2F</url>
    <content type="text"><![CDATA[深度学习和神经网络这两个术语在AI中几乎可以互换使用。 即使它们非常适合机器学习，但它们也有一些炒作和一点点神秘感。 这段视频将揭开深度学习的神秘面纱，让您了解深度学习和神经网络究竟是什么。 让我们使用需求预测的例子。 假设您经营一家销售T恤的网站。 而且你想知道，根据你对T恤的价格，你期望销售的单位数量，你希望销售多少件T恤。 然后，您可以创建这样的数据集，其中T恤的价格越高，需求越低。 所以你可能会对这个数据有一条直线，表明随着价格上涨，需求下降。 现在需求永远不会低于零，所以也许你说需求会在零点上变平，超过某一点你会发现很多人都不会购买任何T恤。 事实证明，这条蓝线可能是最简单的神经网络。 您输入价格A，并且您希望它输出估计的需求，B。 因此，你将这个作为一个神经网络的方式得出的结果就是价格将在那里输入这个小圆形的东西，并且这个小圆形的东西输出估计的需求。 在AI的术语中，这个小圆形的东西在这里被称为神经元，或者有时它被称为人工神经元，它所做的就是计算我在左边画的这条蓝色曲线。 这可能是具有单个人工神经元的最简单的神经网络，其仅输入价格并输出估计的需求。 如果你想到这个橙色的圆圈，这个人工神经元就像一个小小的乐高积木，所有的神经网络，如果你把很多这些乐高积木堆叠在一起，直到你得到一个大国，这些大网络神经元。 让我们看一个更复杂的例子。 假设您不仅仅知道T恤的价格，而且还要承担客户为获得T恤而必须支付的运费。 可能是你在一个星期内花费更多或更多的营销，你也可以制作厚重的，昂贵的棉质或更便宜，更轻质的材料的T恤衫。 这些是您认为会影响T恤需求的一些因素。 让我们看看更复杂的神经网络可能是什么样子。 你知道你的消费者对可负担性很重视。 所以，假设你有一个神经元，让我用蓝色绘制这个神经元，其工作是估计T恤的可承受性。 因此，承受能力主要取决于衬衫的价格和运输成本。 第二件事虽然影响了你对T恤的需求，但却是意识。 消费者知道你卖这件T恤多少钱？ 所以影响意识的主要因素是你的营销。 因此，让我在这里画一个第二个人工神经元，它输入您的营销预算，您在营销上花多少钱，并输出您的T恤消费者的意识。 最后，您的产品的感知质量也会影响需求，感知质量会受到营销的影响。 营销试图说服人们这是一件高品质的T恤，有时候某些东西的价格也会影响感知质量。 因此，我将在这里绘制第三个人工神经元，它输入价格，营销和材料，并试图估计你的T恤的感知质量。 最后，现在早期的神经元，这三个蓝色神经元，已经找出了可承受的价格，消费者的意识以及感知质量的多少，你可以在这里再生一个神经元，将这三个因素作为输入并输出估计的需求。 所以这是一个神经网络，它的工作是学习从这四个输入，即输入A到输出B，到需求。 所以它学习了这个输入输出或A到B的映射。 这是一个相当小的神经网络，只有四个人工神经元。 在实践中，今天使用的神经网络要大得多，容易上千，数万甚至比神经元数量大得多。 现在，我想清理这个描述的最后一个细节，就是在我描述神经网络的方式中，就好像你必须弄清楚关键因素是负担能力，意识和感知质量。 关于使用神经网络的一个奇妙的事情是训练神经网络，换句话说，使用神经网络构建机器学习系统，所有你需要做的就是输入A和输出B. 并且它自己计算出中间的所有东西。 因此，要建立一个神经网络，你要做的就是输入大量的数据或输入A，并有一个看起来像这样的神经网络，有一些蓝色神经元喂养黄色开放神经元。 然后你必须给它带有需求B的数据。 并且软件的工作是弄清楚这些蓝色神经元应该计算什么，以便它可以完全自动地学习从输入A到输出B的最准确的可能函数映射。 事实证明，如果给予足够多的数据并训练足够大的神经网络，这可以做出令人难以置信的良好工作，从输入A到输出B. 所以这是一个神经网络，是一组人工神经元，每个人工神经元计算一个相对简单的功能。 但是当你像Lego砖一样堆叠它们时，它们可以计算出非常复杂的功能，从输入A到输出B可以提供非常精确的映射。 现在，在本视频中，您看到了应用于需求预测的神经网络示例。 让我们继续下一个视频，看一个更复杂的神经网络应用于人脸识别的例子。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week1-7 More examples of what machine learning can and cannot do 机器学习能做什么和不能做什么的更多例子]]></title>
    <url>%2F2019%2F03%2F04%2Fweek1-07-more-examples-of-what-machine-learning-can-and-cannot-do%2F</url>
    <content type="text"><![CDATA[善于识别人工智能可以做什么和不能做什么的挑战之一就是看到一些人工智能的混凝土和失败的例子。 如果你平均每年工作一个新的人工智能项目，那么看三个例子会带你三年的工作经验，这只是很长一段时间。 在我之前的视频和本视频中，我希望做的是快速向您展示一些成功和失败的例子，或者它可以做什么和不能做什么，以便在更短的时间内，您可以看到多层离散的例子来帮助磨练你的直觉和选择有价值的项目。 那么，我们来看几个例子吧。 让我们说你正在建造一辆自动驾驶汽车，这是一件可以做得非常好的东西，它可以拍摄汽车前面的东西，也许只是使用相机，也许还可以使用雷达或激光雷达等其他感官。 然后弄清楚，什么是位置，或其他车辆在哪里。 因此，这将是一个AI，其中输入A，是汽车前方的图像，或者可能是雷达和其他传感器读数。 输出B是，其他车在哪里？ 今天，自驾车行业已经找到了如何收集足够的数据并且具有良好的算法，可以很好地完成这项工作。 那么，这就是今天人工智能所能做的。 这是一个今天人工智能无法做到的事情的例子，或者至少使用今天的人工智能非常困难，这就是输入图片并输出人类试图在你车上尝试的任何意图。 所以，这是一名建筑工人伸出一只手托着你的车停下来。 这是一个试图挥动汽车的搭便车者。 这是一个骑自行车的人举起左手来表示他们想要左转。 所以，如果你试图构建一个系统来学习A到B的映射，其中输入A是我们在你的汽车上的人类生命的短视频，输出B是，这个人想要的意图或者是什么，今天是非常困难的。 部分问题在于人们对你做出的姿势非常非常大。 想象一下，有人可以想象的所有手动提示要求你放慢速度或去或停止。 人们可以向你示意的方式非常多，非常大。 因此，很难从数以千计的不同人群中获取足够的数据，以及捕获人类手势丰富性的所有不同方法。 因此，从视频中学习这个人想要什么，这实际上是一个有点复杂的概念。 事实上，即使是人们也很难搞清楚有人在你车上想要的东西。 第二，因为这是一个安全关键的应用程序，你会想要一个非常准确的人工智能计算出来，建筑工人是想让你停下来，还是他或者你想要去？ 这也使得人工智能系统变得更加困难。 所以，今天如果你只收集10,000张其他汽车的照片，很多团队都会建立一个至少具有检测其他汽车的基本能力的aAI系统。 相比之下，即使您收集了10,000人的照片或视频，也很难找到10,000名在您的车上挥手的人。 即使有了这个数据集，我认为现在很难建立一个人工智能系统来识别人类的意图，他们的姿势需要非常高的准确度才能安全地驾驭这些人。 所以，这就是为什么今天，许多自驾车队有一些组件来检测其他车辆，他们依靠这项技术来安全驾驶。 但很少有自驾车队试图依靠theAI系统来识别各种各样的人类手势，并且只是在人们身边安全地计算。 让我们看一个例子。 假设你想建立AI系统来观察X射线图像和诊断肺炎。 所以，所有这些都是胸部X光片。 因此，输入A可以是X射线图像，输出B可以是诊断。 该患者是否患有肺炎？ 所以，这是AI可以做的事情。 AI不能做的事情就是从解释肺炎的医学教科书章节的10张照片中诊断出肺炎。 人类可以看一小部分图像，可能只是几十张图像，并从医学教科书中读取几段并开始感觉。 但实际上不知道，给定一本医学教科书，什么是A，什么是B？ 或者如何将此作为一个人工智能问题，如知道如何编写一个软件来解决，如果你只有10幅图像和几段文字解释胸部X光片中的肺炎是什么样的。 虽然年轻的医生可能会很好地阅读医学教科书，只看几十张图片。 相比之下，人工智能系统今天真的无法做到这一点。 总而言之，以下是机器学习的一些优点和缺点。 当你尝试容忍一个简单的概念时，机器学习会很好地运作，例如你可以用不到一秒的心理思维来做的事情，以及当有大量数据时。 当您从大量数据中学习复杂概念时，机器学习往往效果不佳。 人工智能的第二个被低估的弱点是，当它被要求执行与数据集中所见数据不同的新数据时，它往往很不好。 让我举个例子来解释一下。 假设您建立了一个监督学习系统，该系统使用A到B来学习从这些图像中诊断出肺炎。 这些是非常高质量的胸部X光图像。 但现在，让我们假设您使用这个人工智能系统并将其应用于不同的医院或不同的医疗中心，也许X射线技术人员在某种程度上奇怪地让患者始终处于某个角度或有时存在这些缺陷。 不确定您是否可以在图像中看到失效的结构。 这些低的其他物体位于患者的顶部。 如果人工智能系统已经从您左边的数据中学习，可能是从高质量的医疗中心采取的，并且你采用了这个系统并将其应用到生成右侧图像的不同医疗中心，那么它的表现将会很差。好。 一个优秀的AI团队可以改善或减少这些问题，但这样做并不容易。 这是AI实际上比人类弱得多的事情之一。 如果一个人从左边的图像中学到了东西，那么他们就更有可能适应像右边的那些图像，他们发现患者只是躺在一个角度上。 但是，人工智能系统在推广或配置如何处理新类型的数据方面可能不如人类医生强大。 我希望这些例子可以帮助你磨练你对AI能做什么和不能做什么的直觉。 如果它能够或不能做什么之间的界限看起来仍然模糊不清，请不要担心。 这是完全正常的，完全没问题。 事实上即使在今天，我仍然无法看到一个项目，并立即告诉它是否可行。 在形成对某些事情是否可行的坚定信念之前，我经常需要数周或数周的技术调查。 但我希望这些例子至少可以帮助你开始想象你公司中可能可行的一些事情，并且可能会更多地探索。 接下来的两个视频是可选的，是对什么是神经网络以及什么是深度学习的非技术性描述。 请随意观看。 接下来，我们将更深入地了解构建AI项目的过程。 我期待下周为你服务。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week1-6 What machine learning can and cannot do 机器学习能做什么，不能做什么]]></title>
    <url>%2F2019%2F03%2F04%2Fweek1-06-what-machine-learning-can-and-cannot-do%2F</url>
    <content type="text"><![CDATA[在这个视频和下一个视频中，我希望能帮助你发展关于AI能做什么和不能做什么的直觉。 在实践中，在我投入特定的AI项目之前，我通常会让自己或工程师对项目进行技术调查，以确保它是可行的。 这意味着：查看数据，查看输入，输出A和B，并且只考虑这是否是真正可以做的事情。 不幸的是，我看到一些CEO可能会对人工智能的期望过高，并且可以要求工程师做一些今天人工智能根本无法做到的事情。 媒体以及学术文献的挑战之一往往只是报告使用AI的成功故事的积极结果，我们看到一系列成功故事而不是故障故事，人们有时候会认为艾可以做任何事情。 不幸的是，这不是真的。 所以，我想在这个和下一个视频中做的是向你展示当今人工智能技术可以做什么，以及它不能做什么的几个例子，我希望这会帮助你，磨练你的直觉，看看可能更多或者为您的公司选择不太有希望的项目。 以前，您从垃圾邮件过滤到语音识别，机器翻译等中看到了此AI应用程序列表。 一个不完美的规则可以用来决定监督学习可能会或者可能不会做的是，几乎任何你可以做的事情，我们现在或许很快就可以使用这种输入输出映射自动使用监督学习。 因此，举例来说，为了确定其他汽车的位置，这是你用不到一秒的时间。 为了判断手机是否有划痕，您可以查看它，您可以在不到一秒的时间内辨别出来。 为了理解或至少转录所说的内容，它不需要那么多的思考。 虽然这是一个不完美的经验法则，但它可能会让您快速思考AI系统可以执行的一些任务示例。 相比之下，人工智能今天做不到的事情就是：分析市场并撰写50页的报告，人类不能在一秒钟内写出50页的分析报告，这是非常困难的，至少我不知道。 我不认为当今世界上的任何团队都知道如何让人工智能系统进行市场调查并运行扩展市场报告。 我发现了磨练直觉的最好方法之一就是找出具体的例子。 那么，让我们看一个与客户支持自动化相关的具体示例。 让我们看看一个随机的网站出售东西，所以一个电子商务公司，你有一个客户支持部门，收到这样的电子邮件，“玩具迟到了两天，所以我无法把它送给我的侄女为她的生日。 我可以退货吗？“如果你想要的是一个人工智能系统来查看这个，并决定这是退款请求，那么让我给它退回退税部门，然后我会说，你有很好的机会建立一个人工智能系统来做到这一点。 人工智能系统将作为输入，客户文本，客户通过电子邮件发送给您，并输出，这是退款请求或者这是运输问题，还是其他请求，以便将此电子邮件发送到最合适的部分您的客户支持中心。 因此，输入A是文本，输出B是这三种结果之一，是退货或运输问题，还是运输查询，或者是不同的请求。 所以，这就是今天AI可以做的事情。 这是AI今天无法做到的事情，如果你想让AI输入一个自动生成的电子邮件，它就会响应，“哦，很抱歉听到这个。 我希望你的侄女过上好日子。 是的，我们可以提供帮助，等等。“ 因此，对于人工智能今天输出一个复杂的文本，今天很难通过今天的人工智能标准，事实上甚至同情你的侄女的生日，对于你可能收到的每一种可能类型的电子邮件来说都很难做到。 现在，如果您使用像深度学习算法这样的机器学习工具来尝试这样做，会发生什么。 因此，假设您试图让AI系统输入用户的电子邮件，并输出两个段落，同情和适当的响应。 假设您有一个适度大小的数据集，例如1,000个用户电子邮件和适当的响应示例。 事实证明，如果你在这类数据上运行AI系统，在1000个例子的小数据集上，这可能是你得到的性能，如果用户发电子邮件，“我的盒子被损坏了”，他们会说，“谢谢你对于你的电子邮件，“它说，”我在哪里写areview？“，”谢谢你的电子邮件。“ ”什么是退货政策？“，”谢谢你的电子邮件。“ 但是建造这种类型的人工智能的问题在于，只有1000个例子，人工智能系统没有足够的数据来学习如何写出三段，适当的反感。 因此，无论客户发送给您什么，您最终都可能会生成相同的简单响应，例如“感谢您的留言”。 另一件可能出错的事情，AI系统失败的另一种方式是，如果它产生了一些乱码，例如：“我的盒子什么时候开始”，它说，“谢谢，是的，现在你的，”胡言乱语。 这是一个足够困难的问题，即使有10,000或100,000个邮件示例，我也不知道这是否足以让AI系统做到这一点。 whatAI可以做什么和不能做的规则不会先加强，我通常最终不得不要求工程团队花一些时间做深入的技术调查，以便自己决定项目是否可行。 但是为了磨练你的想法以帮助你快速过滤可行或不可行的项目，这里有一些关于什么使机器学习问题更容易或更可行的其他经验法则。 一，学习一个简单的概念更可能是可行的。 嗯，简单的概念意味着什么？ 对此没有正式的定义，但这是一个让你少于一秒的心理思想或极少数的精神思想得出一个结论，然后倾向于它是否是一个简单的概念。 因此，你正在寻找一辆自动驾驶汽车的车窗，以发现其他相对简单概念的汽车。 然而，如何写出移情反应，那么复杂的用户投诉，那将是一个简单的概念。 其次，如果你有可用的数据，机器学习问题更可能是可行的。 这里，我们的数据意味着输入A和输出B，你希望AI系统在你的A到B中输入到输出映射。 因此，例如，在客户支持应用程序中，输入A将是来自客户的电子邮件的示例，并且B可以标记这些客户电子邮件中的每一个是关于它是退款请求还是运送查询，或者是三个结果之一的其他问题。 然后，如果你有成千上万的电子邮件同时包含A和B，那么建立一个机器学习系统来实现这一目标的几率非常高。 人工智能是新的电力，它正在改变每个行业，但它也不是魔术，它不能在阳光下做所有事情。 我希望通过这个视频来帮助你磨练你对它能做什么和不能做什么的直觉，并增加你选择可行和有价值的项目的可能性，也许你的团队可以尝试一下。 为了帮助您继续发展您的直觉，我想向您展示更多关于theAI能做什么和不能做什么的例子。 我们进入下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week1-5 What makes an AI company? 是什么让一家公司擅长人工智能]]></title>
    <url>%2F2019%2F03%2F04%2Fweek1-05-what-makes-an-ai-company%2F</url>
    <content type="text"><![CDATA[是什么让一家公司擅长人工智能？或许更重要的是，你的公司需要什么才能使用人工智能？我之前曾领导谷歌大脑团队和百度的AI团队，我分别帮助谷歌和百度成为伟大的人工智能公司。 那么，你能为自己的公司做些什么呢？这是我从中学到的关于洗涤互联网崛起的教训，我认为这与我们所有人如何驾驭崛起有关。 让我们来看看。 我们从互联网的兴起中吸取的教训是，如果你选择了最喜欢的购物中心。 所以，我和我的妻子有时会在斯坦福购物中心购物，并为购物中心建立一个网站。 也许在网站上卖东西，这本身并没有把购物中心变成互联网公司。 事实上，几年前我和一家大型零售公司的首席执行官谈话时，他对我说：“嘿Andrew，我有一个网站，我在网站上卖东西。“ 亚马逊有一个网站，亚马逊在网站上销售的东西是一回事。 但当然不是，在一个网站的购物中心与一流的互联网公司不同。 那么，如果它不仅仅是你在网站上销售的东西是什么，它定义了互联网公司是什么？我认为一个互联网公司是一家做互联网让你做得很好的公司。 例如，我们参与和普遍的AB测试。 这意味着我们经常抛出两个不同版本的网站，看看哪个更好，因为我们可以。 所以，我们学得更快。 在传统购物中心，很难在两个平行的宇宙中拥有两个购物中心，而且每六分之一或每六个月你都可以改变一些东西。 互联网公司的迭代时间非常短。 您可以每周或甚至每天发货新产品，因为您可以重新设计购物中心，我们每隔几个月就会受到保护。 互联网公司也倾向于将决策从首席执行官推向工程师，以及其他专业规则，如产品经理。 这与传统的购物中心形成鲜明对比。 我们可以让首席执行官决定所有关键决策，然后每个人都做首席执行官所说的。 事实证明，传统模型在互联网时代并不起作用，因为工程师和其他专业角色（如产品经理）对技术，产品和用户做出了足够的了解，从而做出了很好的决策。 所以，这些是互联网公司为确保互联网不太好的事情所做的一些事情。 这是我们从互联网时代学到的一课。 人工智能时代怎么样？我想今天，你可以采取任何公司，并使用一些神经网络或少数深度学习算法。 这本身并没有将陪伴变成AI公司。 相反，是什么让一个伟大的AI公司，有时候是人工智能的第一家公司，你做的事情是你能让你做得很好吗？例如，AI公司非常擅长战略数据的收​​购。 这就是为什么许多大型消费技术公司可能有三种产品没有货币化，它允许他们获取可以在其他地方货币化的数据。 服务较少的策略团队，我们会故意推出不会为了数据采集而赚钱的产品。 思考如何获取数据是伟大AI公司的关键部分。 AI公司发送统一数据仓库。 如果您有50个不同的副总裁控制50个不同的数据库或50个不同的数据仓库，那么工程师就不可能将数据放到一个地方，以便他们可以连接点和点模式。 因此，许多优秀的人工智能公司已经预先投入将数据整合到单个数据仓库中，以增加团队连接点的几率。 主题当然是上流保证，也适用于欧洲的GDPR等数据监管。 AI公司非常擅长发现自动化机会。 我们非常擅长说，哦！让我们插入监督学习算法，并在这里有一个ATP映射，这样我们就不必让人们完成这些任务，而是我们可以自动化它。 人工智能公司还有许多新的角色，例如MLE或机器学习工程，以及在团队的不同成员之间划分任务的新方法。 因此，对于一家公司来说，擅长人工智能意味着，为公司设计能够做到人工智能使其成为可能做得很好的事情。 现在，对于一个擅长AI的公司来说，确实需要一个流程。 事实上，10年前，谷歌和百度以及像Facebook和微软这样的公司，我不是其中的一员，我们今天的方式并不是很好的AI。 那么，一家公司如何才能擅长人工智能？事实证明，对AI的擅长并不是一个神秘的过程。 相反，有一个系统的过程，许多公司，几乎任何大公司都可以通过它来擅长人工智能。 这是五步AI转型手册，我推荐想要在使用AI时有效的对公司。 我将在这里简要介绍一下这本手册，他们将在下周详细介绍。 第一步是执行试点项目以获得动力。 因此，只需要几个小项目就可以更好地了解AI能做什么或不能做什么，并更好地了解做AI项目的感受。 这可以在内部完成，也可以与外包团队合作。 但最终，你需要做第二步，即内部人工智能团队建设和提供人工智能培训，不仅对工程师而且对管理人员，部门负责人和高管以及他们如何看待人工智能。 在做了这个oras之后你就是这样做了，你对AI是什么有了更好的认识，然后对于很多公司制定人工智能战略很重要。 最后，调整内部和外部通信，以便所有来自员工，客户和投资者的利益相关者都能与您的公司如何驾驭AI的兴起保持一致。 人工智能在软件行业中创造了巨大的价值，并将继续这样做。 它还将在软件行业之外创造巨大价值。 如果你可以帮助你的公司擅长AI，我希望你能在创造很多这个价值方面发挥主导作用。 这是一个视频，你认为它使公司成为一个优秀的人工智能公司，并简要介绍了我的转型手册，我将在稍后的一周内更详细地介绍帮助公司在AI工作的路线图。 如果您有兴趣，还可以在线发布一个人工智能转型手册，其中详细介绍了这五个步骤，您可以在以后的几周内看到更多这些内容。 现在，执行AI项目的挑战之一，例如第一步中的试点项目，就是了解AIcan和不能做什么。 在下一个视频中，我想向您展示并提供一些关于whatAI能做什么和不能做什么的例子，以帮助您更好地选择可能对您的公司有效的项目AI。 那是下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week1-4 The terminology of AI 人工智能术语]]></title>
    <url>%2F2019%2F03%2F04%2Fweek1-04-the-terminology-of-ai%2F</url>
    <content type="text"><![CDATA[您可能从AI听过机器学，例如机器学习或数据科学或神经网络或深度学习。 这些术语意味着什么？在这个视频中，您将看到人工智能的最重要概念的术语是什么，以便您与其他人讨论并开始思考这些事情如何适用于您的业务。 让我们开始吧。 假设你有一个这样的房屋数据集，房子的大小，卧室的数量，浴室的数量，房子是否是新装修的价格。 如果你想建立一个移动应用程序到helppeople价格公司，所以这将是输入A，这将是输出B. 然后，这将是一个机器学习系统，特别是那些学习输出输入或A到B映射的机器学习系统之一。 因此，机器学习会导致运行的AI系统。 所以，它是一个软件，随时随地都可以自动输入A的这些属性和输出B. 因此，如果你有AI系统运行，为数十万或数千万用户提供服务，那通常就是机器学习系统。 相比之下，这里有一些你可能想要做的事情，那就是让团队分析你的数据集，以获得洞察力。 所以，一个团队可能会得出一个结论，比如，“嘿，你知道你是否有两个相似大小的房子，他们有相似的平方英尺，如果房子有三间卧室，那么它们花费的房子要多得多两间卧室，即使这个方块也是一样的。“ 或者，”你知道吗，新装修的房屋有15％的溢价，这可以帮助你做出决定，例如，考虑到类似的平方英尺，你想建造两间卧室或三间卧室的房间，以便最大化价值吗？“或者， “翻新房屋是否值得投资，希望翻新能增加你卖房子的价格？”因此，这些将是数据科学项目的例子，其中一个数据科学项目的输出是一组可以帮助的见解你做出商业决策，比如建造什么类型的房子或是否要进行翻新。 这两个术语之间的界限，机器学习和数据科学实际上有点喧嚣，这些术语即使在今天的行业中也没有得到一致的使用。 但我在这里给出的可能是这些术语最常用的定义，但你不会发现这些定义的普遍遵守。 为了使这些特征更加正式化，机器学习是一个研究领域，它为计算机提供了学习的能力，而不需要进行明确的编程。 这是几十年前阿瑟塞缪尔的定义。 亚瑟·塞缪尔（Arthur Samuel）是机器学习的先驱之一，他以建立跳棋玩家计划而闻名。 他们可以玩跳棋，甚至比他自己更好，发明者可以玩游戏。 因此，机器学习项目通常会产生一个运行的软件，输出B给出A. 相比之下，数据科学是从数据中提取知识和见解的大小。 因此，数据科学项目的输出通常是幻灯片，PowerPoint演示文稿总结了高管采取业务行动的结论，或者总结了产品团队决定如何改进网站的结论。 让我举一个在线广告行业的机器学习与数据科学的例子。 今天，为了推出我们的平台，所有人都有一个人工智能，可以快速告诉他们你最有可能点击的广告。 所以，这是一个机器学习系统。 事实证明，这是一个令人难以置信的利润丰厚的人工智能系统，可以丰富您和您点击此处或不点击的广告和输出。 这些系统运行24-7。 这些机器学习系统推动了我们对这些公司的重视，例如运行的软件。 相比之下，我也在网络广告行业做过数据科学项目。 如果分析数据告诉你，例如，旅游业并没有购买大量广告，但如果你派出更多的销售人员向旅游公司出售广告，你可以说服他们使用更多广告，那么这就是数据科学的一个例子项目和数据科学结论，结果和管理人员决定要求销售团队花更多的时间与旅游业联系。 因此，即使在一家公司，您也可能拥有不同的机器学习和数据科学项目，这两个项目都具有不可或缺的价值。 你也听说过深度学习。 那么，什么是深度学习呢？假设你想要最高房价，你想要房价。 所以，你会有一个输入，告诉你房子的大小，卧室的数量，浴室的数量以及是否新装修。 价格之所以最有效的方式之一，考虑到这一点，我们应该把它送到这里，以便输出价格。 中间的这个大事叫做神经网络，有时候我们也称为人工神经网络。 这是为了将它与你脑中的神经网络区分开来。 因此，人类的大脑是由神经元组成的。 所以，当我们说人工神经网络时，这只是为了强调这不是生物大脑，而是一个软件。 神经网络做什么，或者人工神经网络做什么就是接受这个输入A，这是所有这四个东西，然后输出B，这是房子的估计价格。 现在，在本周的后续可选视频中，我将向您展示更多，这个人工神经网络究竟是什么。 但是所有的人类认知都是由你脑中的神经元组成的，通过电脉冲，彼此传递小的消息。 当我们绘制一个人工神经网络的图片时，对于大脑来说，这是一个非常松散的类型。 这些小圆圈被称为人工神经元，或简称神经元。 这也将神经元传递给对方。 这个大型的人工神经网络只是一个很大的数学方程，它告诉它给定输入A，你如何计算价格B. 如果这里看起来有很多细节，请不要担心。 我们稍后会详细讨论这些细节。 但关键的一点是神经网络是学习A到B或输入输出映射的一种非常有效的技术。 今天，术语神经网络和深度学习几乎可以互换使用，它们的意思基本相同。 几十年前，这种类型的软件被称为神经网络。 但是近年来，我们发现深度学习只是一个非常好的品牌，所以无论好坏，这个词最近都被淘汰了。 那么，神经网络或人工神经网络与大脑有什么关系呢？事实证明几乎没有。 神经网络最初是由大脑启发的，但是它们如何工作的细节几乎与生物学大脑的工作无关。 所以，我今天选择在人工神经网络和生物大脑之间进行任何类比，即使在那里有松散的灵感。 因此，AI有许多不同的工具。 在这个视频中，您了解了什么是机器学习和数据科学，以及什么是深度学习，以及什么是神经网络。 您可能还会在媒体中听到其他流行语，如无监督学习，强化学习，图形模型，计划，知识图等。 您不需要知道所有这些其他术语的含义，但这些只是让AI系统智能化计算机的其他工具。 我会尝试让您了解这些术语中的哪些术语也意味着内置视频。 但是，我希望你了解的最重要的工具是机器学习和数据科学以及深度学习和神经网络，这是一种非常强大的机器学习方式，有时也是数据科学。 如果我们要绘制一个展示所有这些概念如何组合在一起的维恩图，这就是它的样子。 人工智能是一套巨大的工具，可以智能地制作电脑。 关闭人工智能，最大的子集是来自机器学习的草原工具，但人工智能确实有其他机器学习工具，例如其中一些流行语，列在底部。 目前最重要的机器学习部分是神经网络或深度学习，这是一个非常强大的工具，用于执行监督学习或A到B映射以及其他事情。 但也有其他机器学习工具不仅仅是深度学习工具。 那么，数据科学如何适应这种情况呢？术语的使用方式不一致。 有些人会告诉你，数据科学是人工智能的一个子集。 有些人会告诉你AI是数据科学的一个子集。 所以，这取决于你问的是谁。 但我想说数据科学可能是所有这些工具的交叉子集，它们使用了许多AI机器学习和深度学习的工具，但是还有其他一些独立的工具可以解决一系列重要的问题，从而推动商业洞察力。 在这个视频中，你了​​解机器学习，什么是数据科学，什么是深度学习和神经网络。 我希望这能让您了解使用AI的最常见和最重要的语言，并且您可以开始思考这些事情如何适用于您的公司。 现在，公司擅长AI是什么意思？让我们在下一个视频中讨论这个问题。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week1-3 What is data? 什么是数据？]]></title>
    <url>%2F2019%2F03%2F04%2Fweek1-03-what-is-data%2F</url>
    <content type="text"><![CDATA[您可能听说过数据对于构建AI系统非常重要。 但是，真正的数据是什么？让我们来看看。 让我们看一下数据表的一个例子，我们也提供了一个数据集。 如果您正在尝试设置如何为正在购买或出售的房屋定价，您可能会收集这样的数据集，这可能只是一个电子表格，就像一个MS excel数据电子表格，其中一列是房子的大小，比如说平方英尺或平方米，第二列是房子的价格。 因此，如果您正在尝试构建AI系统或MachineLearning系统来帮助您设置房屋价格或弄清楚房屋的价格是否合适，您可能会认为房屋的大小是A而且房屋的价格是B，并且有一个AI系统学习输入到输出A到B的映射。 现在，你可能会说：“好吧，我们还会收集有关这栋房子卧室数量的数据，而不仅仅根据房屋大小定价。” 在这种情况下，A可以是前两列，而B可以只是房子的价格。 因此，给定数据表，给定数据集，实际上取决于您，直到您的业务用例来决定什么是A，什么是B. 数据通常是您的业务的唯一数据，这是一个农村国家机构可能会帮助定价房屋的数据集的示例。 由您决定什么是A，什么是B，以及如何选择A和B的定义以使其对您的业务有价值。 再举一个例子，如果你有一定的预算，而你想要决定你能买得起的房子的大小，那么你可能会认为输入A是某人花了多少钱而B只是平方英尺的房子大小，那个A和B的完全不同的选择告诉你，给定一定的预算，你应该看看房子的大小是多少。 这是数据集的另一个例子。 假设您想构建一个AI系统来识别图片中的猫。 我不确定你为什么要这样做，但也许是有趣的移动应用程序，你想要标记猫的图片。 因此，您可能会收集数据集，其中输入A是一组不同的图像，输出B是标记，上面写着“第一张图片是猫，不是猫。 这是一只猫，这不是一只猫“并且有一个AI输入一张图片 A和输出B有没有猫，所以你可以标记你的照片或你的移动应用程序上的所有猫图片。 在机器学习传统中，机器学习实际上有很多人。 我认为有些这是从我离开谷歌大脑团队时开始的，我们发布的结果有点臭名昭着的Google猫，其中一个AI系统可以通过观看YouTube视频来检测猫。 但是从那时起，在谈论机器学习时，有一种传统的习惯是将猫作为一种运行样本，并向所有爱好者们道歉。 我也爱狗。 因此，数据很重要。 但是你如何获得数据？ 你如何获得数据？ 嗯，getdata的一种方法是手动标记。 例如，您可能会在这里收集一组这样的图片，然后您可能会自己或者让其他人浏览这些图片并标记每个图片。 所以，第一个是猫，第二个不是猫，第三个是猫，第四个不是猫。 通过手动标记这些图像，您现在可以获得用于构建猫探测器的数据集。 要做到这一点，你实际上需要超过四张图片。 您可能需要数十万张图片，但手动标记是获取A和B两者的数据集的经过验证的真实方式。 geta数据集的另一种方法是观察用户行为或其他类型的行为。 因此，举例来说，假设您运营一个在线销售网站的网站。 因此，电子商务或电子商务网站，您可以以不同的价格向用户提供商品，您可以观察他们是否购买了您的产品。 因此，只需购买或不购买您的产品，您就可以收集这样的数据集，您可以存储用户ID，用户访问您网站的时间，以及您向用户提供产品的价格无论他们是否购买它。 因此，只需使用您的网站，用户就可以从您那里生成这些数据。 这是一个观察用户行为的例子。 我们还可以观察其他东西的行为，例如机器。 如果您在工厂中运行大型机器并且想要预测机器是否有故障或者有故障，那么只需观察机器的行为，就可以像这样记录数据集。 有机器ID，机器温度，机器内有压力，然后机器故障。 如果您的应用程序是防止维护，假设您想要弄清楚机器是否即将发生故障，那么您可以选择此作为输入A并选择输出B作为输出B以试图判断机器是否即将发生故障在哪种情况下，您可以对机器进行预防性维护。 获取数据的第三种也是非常常见的方法是从网站下载或从合作伙伴处获取数据。 由于开放的互联网，有很多，你可以免费下载，从计算机视觉图像数据集到自动驾驶汽车数据集，到语音识别数据集，到医学成像数据集等等。 因此，如果您的应用程序需要一种类型的数据，那么您只需从网上下载以保持注意力和版权，那么这可能是开始使用该应用程序的好方法。 最后，如果你和一个合作伙伴一起工作，说你正在和一个工厂合作，那么他们可能已经收集了一个大的数据集，机器和温度，并且对机器的压力并不是他们能给你的。 数据很重要，但也有点过分炒作，有时也被滥用。 让我直接介绍两种最常见的误用或者对数据进行思考的不良方法。 当我谈到大公司的封条时，他们中的一些人甚至对我说：“嘿Andrew，给我三年时间建立我的IT团队，我们收集了这么多数据。 然后三年后，我将拥有这个完美的数据集，然后我们将做AI。“ 事实证明这是一个非常糟糕的策略。 相反，我推荐给每个公司的是，一旦你开始收集一些数据，继续开始展示它或将其提供给AI团队。 因为通常，AI团队可以向您的IT团队提供反馈，了解哪些类型的数据可以选择以及哪些类型的IT基础架构可以继续构建。 例如，可能一个 AI团队可以查看您的工厂数据和数据，“嘿，你知道吗？如果你可以从这个大型制造机器收集数据，不仅是每十分钟一次，而是每一分钟一次，那么我们可以为你建立预防性维护系统做得更好。“ 因此，在IT和AI团队之间有这种来回的相互作用，我的建议通常会尝试早些时候从AI获得反馈，因为它可以帮助您指导您的IT基础架构的开发。 第二，滥用数据。 不幸的是，我看到一些CEO读到了使用趋势的重要性，然后说：“嘿，我有这么多数据。当然，AI团队可以使它变得有价值。“ 不幸的是，这并不总能奏效。 更多的数据通常比较少的数据更好，但我不会因为你拥有许多兆兆字节或几千兆字节的数据而让它成为可能，因此AI团队实际上可以提供有价值的数据。 因此，我的建议是不要将数据投入AI团队并假设它很有价值。 事实上，在一个极端的案例中，我看到有一家公司在医学上获得了一大堆其他公司，在论文中，假设他们的数据非常有价值。 现在，几年后，据我所知，工程师还没有弄清楚如何获取所有这些数据并实际创造价值。 所以，有时候它会起作用，有时却不起作用。 但是，他们不会为了数据而过度投资只是获取数据，除非你还要让AI团队去看一下。 因为，他们可以帮助您思考实际上最有价值的数据。 最后，数据很混乱。 您可能已经在垃圾中听到了垃圾话，如果您有不良数据，那么AI将会学到不准确的信息。 以下是数据问题的一些示例。 假设您拥有房屋大小，卧室数量和价格的数据集。 您可以使用不正确的标签或不正确的数据。 例如，这栋房子可能不会以0美元的价格出售。 1只需1美元。 或者，数据也可以具有丢失值，例如我们在这里有一大堆未知值。 因此，您的AI团队需要弄清楚如何清理数据或如何处理这些不正确的标签和所有缺失的值。 还有多种数据类型。 例如，有时您会听到图像，音频和文本。 这些是人类发现它很容易解释的数据类型。 这是一个术语。 这被称为非结构化数据，并且有某些类型的AI技术可以与图像一起识别猫或音频以识别语音或文本，或者理解该电子邮件是垃圾邮件。 然后，还有像右边那样的数据集。 这是结构化数据的示例。 这基本上意味着数据存在于一个巨大的电子表格中，处理非结构化数据的技术与处理结构化数据的技术略有不同。 但AI技术可以很好地适用于这些类型的数据，非结构化数据和结构化数据。 在这段视频中，您了解了什么是数据，您还看到了hownot滥用数据，例如过度投资IT基础架构，希望它在将来对AI有用，但我们实际上在检查它们是否真的如此对于你想要构建的AI应用程序非常有用。 最后，你看到的数据很混乱。 但是，一个优秀的AI团队将帮助您解决这些问题。 现在，当人们抛出像AI，机器学习，数据科学这样的术语时，AI就会有一个复杂的术语。 我想在下一个视频中做的是与您分享这些术语的实际含义，以便您能够自信而准确地与他人讨论这些概念。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week1-2 Machine Learning 机器学习]]></title>
    <url>%2F2019%2F03%2F04%2Fweek1-02-machine-learning%2F</url>
    <content type="text"><![CDATA[人工智能的兴起在很大程度上是由人工智能学中的一种工具驱动的。 在本视频中，您将了解什么是机器学习，因此最终，您希望我们将开始思考如何将机器学习应用于您的公司或行业。 最常用的机器学习类型是一种学习A到B或输入到输出映射的AI。 这称为监督学习。 我们来看一些例子。 如果输入A是电子邮件而输出B是否是垃圾邮件，则为零。 然后，这是用于构建垃圾邮件过滤器的核心AI。 或者，如果输入是音频剪辑，并且AI的工作是输出文本记录，则这是语音识别。 更多的例子，如果你想输入英语并输出不同的语言，中文，西班牙语等等，那就是机器翻译。 或者最有利可图的监督学习形式，这种类型的机器学习可能是在线广告，其中所有大型广告平台都有一块人工智能输入关于广告的一些信息，以及一些关于你的信息，并试图弄明白，你点击这个广告了吗？ 通过向您展示您最有可能点击的广告，这可能非常有利可图。 也许不是最具启发性的应用程序，但今天肯定会产生巨大的经济影响。 或者，如果你想建造一辆自动驾驶汽车，人工智能的关键部分之一就是在人工智能中输入图像，从雷达或其他传感器获取一些信息，并输出其他汽车的位置，这样你的自我驾驶carcan避开其他车。 或者在制造业。 我实际上已经在制造业中做了很多工作，你可以把你刚刚制造的东西的图片作为输入，例如手机装配线上的照片。 这是一张手机的照片，而不是手机拍的照片，你想要输出，是否存在刮痕，或者是否存在凹痕，或者是否有任何其他缺陷？ 这是视觉检查，它帮助制造商减少或防止他们正在制造的东西中的缺陷。 这组AI称为监督学习，只是学习输出到输出，或A到B映射。 一方面，输入到输出，A到B似乎非常有限。 但是，当您找到正确的应用场景时，这可能非常有价值。 现在，监督学习的想法已存在了数十年。 但它在过去几年里真的兴起了。 为什么是这样？ 好吧，我的朋友问道，“嘿Andrew，为什么现在监督学习兴起了？”有一张图片我为他们画画。 我现在想向你展示这张照片，你也可以为那些问你同样问题的人提供这张照片。 让我们说在水平轴上绘制一个任务的数据量。 因此，对于语音识别，这可能是您拥有的音频数据和转录的数量。 在许多行业中，在过去的几十年中，数据量的增长确实增长了。 由于互联网的兴起，计算机的兴起。 现在，许多曾经说过纸张的东西都被记录在数字计算机上。 所以，我们刚收到越来越多的数据。 现在，让我们说在纵轴上绘制AI系统的性能。 事实证明，如果你使用传统的AI系统，那么性能就会像这样增长，因为当你输入更多数据时，性能会变得更好。 但是超过某一点它没有那么好。 因此，就好像你的语言识别系统没有那么准确，或者你的在线广告系统没有那么准确地表示最相关的广告，即使你展示了更多的数据。 由于神经网络的兴起和深度学习，人工智能最近真正兴起。 我将在后面的视频中更准确地定义这些术语，所以不要太担心它现在意味着什么。 但是对于现代AI，神经网络和深度学习，我们看到的是，如果你使用小型神经网络，那么性能就像这样，在你为它们提供更多数据时，性能会持续更长时间。 如果你训练一个甚至更大的神经网络，比如中型神经网络，那么性能可能就是这样。 如果你训练一个非常大的神经网络，那么表现就会越来越好。 对于应用程序喜欢语音识别，在线广告，构建自动驾驶汽车，具有高性能，高度准确，说语音识别系统很重要，使这些AI系统更好，并使语音识别产品更容易被用户接受，对公司和用户更有价值。 现在，这个数字的几个例子。 如果你想要最好的性能水平，你的性能在这里，达到这个级别的性能，那么你需要两件事：一个是，它确实有助于拥有大量数据。 这就是为什么有时你会听到大数据的原因。 拥有更多的数据总是有帮助的。 第二件事是，你希望能够训练一个非常大的神经网络。 因此，包括摩尔定律在内的快速计算机的兴起，以及图形处理单元或GPU等专用处理器的兴起，您将在后来的视频中听到更多，这使得许多公司，而不仅仅是一家大型科技公司，许多其他公司能够在足够大的数据量上训练大型神经网络，以获得非常好的性能和商业价值。 AI中最重要的思想是机器学习，基本上是监督学习，即A到B，或输入到输出映射。 使数据更好地工作的是数据。 在下一个视频中，让我们来看看数据是什么以及数据可能已经有了什么？ 以及如何考虑将其馈入AI系统。 让我们继续下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week1-1 Week 1 Introduction 第 1 周 简介]]></title>
    <url>%2F2019%2F03%2F04%2Fweek1-01-week-1-introduction%2F</url>
    <content type="text"><![CDATA[欢迎大家参加AI。 人工智能正在改变我们工作和生活的方式，这个非技术课程将教你如何驾驭人工智能的兴起。 无论你想知道流行语背后的内容，还是想要在个人环境或公司或其他组织中使用AI，本课程都会教你如何。 如果你想了解AI如何影响社会，以及如何进行导航，你也可以从这门课程中学习。 在第一周，我们将从切入炒作开始，并让您真实地了解AI的真实情况。。 让我们开始吧。 您可能已经看过有关AI正在创造多少价值的新闻文章。 根据麦肯锡全球研究所的一项研究，人工智能估计到2030年每年将创造额外的13亿美元的价值。 尽管人工智能已经为软件行业创造了巨大的价值，但未来创造的很多价值都在软件行业之外。 在零售，旅游，运输，汽车，材料，制造等行业。 我应该很难想到一个我不认为人工智能将在未来几年内产生巨大影响的行业。 我和我的朋友们互相挑战了名称和行业，我们认为不会对其产生巨大影响。 我最好的例子是美发行业，因为我们知道如何使用AI机器人来自动化美发。 但是，我曾经在舞台上说过这一天，我的一位机器人教授的朋友当天在观众席上，她实际上站了起来，她在眼睛里看着我，她说：“你知道Andrew，大多数人的发型，我无法让一个机器人以这种方式剪掉他们的头发。“ 但她看着我说，”你的发型Andrew，一个机器人可以做的。“ 有许多兴奋，但也有很多关于人工智能的不必要的炒作。 其中一个原因是因为AI实际上是两个独立的想法。 我们今天在人工智能中看到的几乎所有进展都是 ANI (狭隘人工智能)。 这些AI可以做一件事，例如智能扬声器或自动驾驶汽车或AI在工厂的农业工作者中进行网络搜索或AI应用。 这些类型的AI是一个小技巧，但是当你找到合适的技巧时，这可能是非常有价值的。 不幸的是，AI也提到了AGI (通用人工智能)或人工智能的第二个概念。 这是构建AI的目标。 他们可以做任何人类可以做的事情，甚至可能是超级智能，甚至比任何人都能做的事情更多。 我在ANI中看到了很多进展，人工狭隘的智力，几乎没有进展到AGI或通用人工智能。 这两个值得注意的目标，不幸的是ANI的治疗进展非常有价值，这使得人们得出结论认为人工智能有很多进步，这是事实。 但这导致人们错误地认为AGI也可能取得很大进展，这导致人们对邪恶的聪明的机器人过去接管人类现在的非理性担忧。 我认为AGI对于研究人员而言是一个令人兴奋的目标，但在我们到达之前它将需要大部分技术突破，而且可能需要几千年或数百年才能实现。 鉴于AGI有多远，我认为没有必要过分担心它。 在本周，您将了解ANI可以做什么以及如何将它们应用到您的问题中。 在后面的课程中，您还将看到一些案例研究，了解ANI，这一个技巧可以用来构建真正有价值的应用程序，如智能扬声器和自动驾驶汽车。 在这个星期，你将了解为什么这个人工智能。 您可能听说过机器学习，下一个视频将教您什么是机器学习。 您还将了解什么是数据以及哪些类型的数据有价值，但这些数据也没有什么价值。 你了解到什么使公司成为人工智能公司或人工智能第一公司，这样你或许可以开始思考是否有办法改善你的公司或其他组织使用人工智能的能力，重要的是，你本周也学到了什么机器学习可以做什么不能做。 在我们的社会中，报纸和研究论文只谈论机器学习和成功案例的成功故事，我们几乎没有看到任何失败的故事，因为他们只是没有那么有趣的报道。 但是为了让你对人工智能和机器学习能力或不能做什么有一个现实的看法，我认为重要的是你看到两者的例子，你可以做出更准确的判断，你可能会做什么，也许不应该尝试使用这些技术。 最后，很多机器学习的兴起是通过深度学习的兴起推动的。 有时也称为神经网络。 在本周的最后两个可选视频中，您还可以看到深度学习的直观解释，您将更好地理解他们可以做什么，特别是对于一组狭窄的ANI任务。 所以，这就是你本周所学到的知识，到本周末，你对AI技术以及它们能做什么和不能做什么都有所了解。 在第二周，您将学习如何使用这些AI技术来构建有价值的项目。 您将了解构建AI项目所需要的内容，以确保您选择技术上可行且对您或您的企业或其他组织有价值的项目。 在了解了构建AI项目的内容之后，在第三周，您将学习如何在公司中构建AI。 特别是，如果你想采取一些措施让你的公司擅长AI，你会看到AI转型手册，并学习如何建立AI团队以及构建复杂的AI产品。 最后，人工智能正在对社会产生巨大影响。 在第四周也是最后一周，您将了解AI系统可能存在偏见以及如何减少或消除此类偏差。 您还将了解到如何影响发展中经济体，以及人工智能如何影响工作，并且可以为您自己和您的组织引导人工智能的增长。 在这四种资源的最后阶段，你对大多数大公司的首席执行官在理解对我们的技术以及你帮助自己或你的公司或其他组织的能力方面更加知识和更有资格，因为我可以帮助我希望在这个课程之后，你将能够为他人提供领导以及他们解决这些问题。 现在，推动最近崛起的主要技术之一是机器学习。 但什么是机器学习呢？让我们来看看下一个视频。 讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务一-数据集探索]]></title>
    <url>%2F2019%2F03%2F03%2Fnlp-task1%2F</url>
    <content type="text"><![CDATA[数据集数据集：中、英文数据集各一份 中文数据集 THUCNewsTHUCNews数据子集：https://pan.baidu.com/s/1hugrfRu 密码：qfud 英文数据集 IMDB数据集IMDB数据集 Sentiment Analysis IMDB数据集下载和探索参考TensorFlow官方教程：影评文本分类 | TensorFlow 科赛 - Kesci.com THUCNews数据集下载和探索参考博客中的数据集部分和预处理部分：CNN字符级中文文本分类-基于TensorFlow实现 - 一蓑烟雨 - CSDN博客 参考代码：text-classification-cnn-rnn/cnews_loader.py at mas… 学习召回率、准确率、ROC曲线、AUC、PR曲线这些基本概念 TP : 把正类预测为正类¶ FP : 把负类预测为正类 TN : 把正类预测为负类 FN : 把负类预测为负类 准确率(accuracy) = (TP + TN) / (TP + FN + FP + TN) 精确率(precision) = TP / (TP + FP) 召回率(recall) = TP / (TP + FN) ROC曲线(受试者工作特征曲线)：横轴为FPR，纵轴为TPR。 FPR = FP / (FP + TN) TPR = TP / (TP + FN) AUC(Area under curve):ROC曲线下的面积AUC的值一般在0.5-1之间，小于0.5表示分类器比随机分还要差。 PR曲线展示的是准确率和召回率的曲线，PR曲线与ROC曲线的相同点是都采用了TPR (Recall)，都可以用AUC来衡量分类器的效果。不同点是ROC曲线使用了FPR，而PR曲线使用了Precision，因此PR曲线的两个指标都聚焦于正例。类别不平衡问题中由于主要关心正例，所以在此情况下PR曲线被广泛认为优于ROC曲线 参考机器学习之类别不平衡问题 (2) —— ROC和PR曲线_慕课手记]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务二-逻辑回归算法梳理]]></title>
    <url>%2F2019%2F03%2F03%2Fbasic-task2%2F</url>
    <content type="text"><![CDATA[逻辑回归与线性回归的联系与区别 逻辑回归是一个非线性模型，sigmoid函数又称逻辑回归函数。 线性回归要求变量服从正态分布，logistic回归对变量分布没有要求。线性回归要求因变量是连续性数值变量，logistic回归要求因变量是分类型变量。线性回归要求自变量和因变量呈线性关系，而logistic回归不要求自变量和因变量呈线性关系。 线性回归中使用的是最小化平方误差损失函数，对偏离真实值越远的数据惩罚越严重；逻辑回归使用对数似然函数进行参数估计，使用交叉熵作为损失函数，对预测错误的惩罚是随着输出的增大，逐渐逼近一个常数 逻辑回归以及线性回归同属于广义线性模型(generalized linear model)，不同的就是因变量不同，如果是连续的，就是多重线性回归，如果是二项分布，就是logistic回归。logistic回归的因变量可以使二分类的，也可是多分类的。 逻辑回归的原理线性回归可以预测连续值，但是不能解决分类问题，我们需要根据预测的结果判定其属于正类还是负类。所以逻辑回归就是将线性回归的(−∞,+∞) 的结果通过 sigmiod 函数映射到0与1之间从而实现分类。 逻辑回归损失函数推导及优化逻辑回归： $h(x) = \frac{1} {1 + e^{-(w^Tx+b)}}$设$y_i$=1的概率为$p_i$，$y_i$=0的概率为$1-p_i$则观测概率：$p(y_i) = p_i^{y_i}(1-p_i)^{1-y_i}$概率由逻辑回归公式求解，带进去得到极大似然函数：$\prod_i^N h(x_i)^{y_i} * (1-h(x_i))^{1-y_i}$ 正则化与模型评估指标正则化正则化就是在损失函数后加上一个正则化项（惩罚项），其实就是常说的结构风险最小化策略，即经验风险（损失函数）加上正则化。一般模型越复杂，正则化值越大。正则化是用来对模型中某些参数进行约束，目的是防止过拟合。 评估指标分类模型 准确率（Accuracy） 精确率（Precision） 召回率（Recall） $F_1$-score(精确率和召回率的调和平均) AUC（ROC曲线下面积） 回归模型 平方根误差（RMSE） 误差分位数（Quantiles of Errors） 逻辑回归的优缺点 优点： 适合二分类问题 计算代价不高，容易理解实现。可用于分布式计算 LR对于数据中小噪声的鲁棒性很好，并且不会受到轻微的多重共线性的特别影响。（L2正则化可帮助解决） 缺点： 容易欠拟合，分类精度不高。 数据特征有缺失或者特征空间很大时表现效果并不好。 只能解决二分类问题（softmax除外） 样本不均衡问题解决办法过采样将稀有类别的样本进行复制，通过增加此稀有类样本的数量来平衡数据集。该方法适用于数据量较小的情况。 欠采样从丰富类别的样本中随机选取和稀有类别相同数目的样本，通过减少丰富类的样本量啦平衡数据集。该方法适用于数据量较大的情况。 SMOTE构造采样基于距离度量的方式计算两个或多个稀有类样本之间的相似性。然后选择其中的一个样本作为基础样本，再在邻居样本中随机选取一定数量的样本对那个基础样本的一个属性进行噪声。每次处理一个属性，通过这样的方式产生新生数据。 对原数据的权值进行改变通过改变多数类样本和少数类样本数据在训练时的权重来解决样本不均衡的问题，是指在训练分类器时，为少数类样本赋予更大的权值，为多数类样本赋予较小的权值。 通过组合集成方法解决将多数类数据随机分成少数类数据的量N份，每一份与全部的少数类数据一起训练成为一个分类器，这样反复训练会生成很多的分类器。最后再用组合的方式(bagging或者boosting)对分类器进行组合，得到更好的预测效果。简单来说若是分类问题可采用投票法，预测问题可以采用平均值。这个解决方式需要很强的计算能力以及时间，但效果较好，相当于结合了组合分类器的优势。 通过特征选择在样本数据较为不均衡，某一类别数据较少的情况下，通常会出现特征分布很不均衡的情况。例如文本分类中，有大量的特征可以选择。因此我们可以选择具有显著区分能力的特征进行训练，也能在一定程度上提高模型的泛化效果。 sklearn参数Sklearn.linear_model.penalty:’l1’ or ‘l2’ ,默认’l2’ #惩罚 dual:bool 默认False ‘双配方仅用于利用liblinear解算器的l2惩罚。’ tol: float, 默认: 1e-4 ‘公差停止标准’ C:float 默认:1.0 正则化强度， 与支持向量机一样，较小的值指定更强的正则化。 fit_intercept: bool 默认:True 指定是否应将常量（a.k.a. bias或intercept）添加到决策函数中。 intercept_scaling:float ,默认:1 仅在使用求解器“liblinear”且self.fit_intercept设置为True时有用。 在这种情况下，x变为[x，self.intercept_scaling]，即具有等于intercept_scaling的常数值的“合成”特征被附加到实例矢量。 截距变为intercept_scaling * synthetic_feature_weight class_weight: dict or ‘balanced’ 默认:None 与{class_label：weight}形式的类相关联的权重。 如果没有给出，所有类都应该有一个权重。“平衡”模式使用y的值自动调整与输入数据中的类频率成反比的权重，如n_samples /（n_classes * np.bincount（y））。请注意，如果指定了sample_weight，这些权重将与sample_weight（通过fit方法传递）相乘。 random_state:int,RandomState实例或None，可选，默认值：None 在随机数据混洗时使用的伪随机数生成器的种子。 如果是int，则random_state是随机数生成器使用的种子; 如果是RandomState实例，则random_state是随机数生成器; 如果为None，则随机数生成器是np.random使用的RandomState实例。 在求解器==’sag’或’liblinear’时使用。 参考资料西瓜书 cs229吴恩达机器学习课程 李航统计学习 谷歌搜索]]></content>
      <categories>
        <category>初级算法梳理</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI For Everyone 课件]]></title>
    <url>%2F2019%2F03%2F02%2Fppt%2F</url>
    <content type="text"><![CDATA[讲师：Andrew Ng课程：https://www.coursera.org/learn/ai-for-everyone]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
        <tag>PPT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务一-算法梳理进阶线性回归]]></title>
    <url>%2F2019%2F03%2F01%2Flr-task1%2F</url>
    <content type="text"><![CDATA[机器学习的一些概念(有监督、无监督、泛化能力、过拟合欠拟合(方差和偏差以及各自解决办法)、交叉验证)有监督、无监督、泛化能力、过拟合欠拟合(方差和偏差以及各自解决办法)、交叉验证 有监督学习：数据集有有已知的y值（label 结果） 无监督学习：数据集中没有y值，需要根据近似性关系分成一簇一簇的聚类来当作y值来评估 泛化能力：指算法对具有同一规律的学习集以外的数据，的适用程度，对其它样本的适应能力 过拟合：over-fitting，指模型在训练样本中表现过好，要求过于精细，导致泛化能力减弱，在验证数据集和测试集中表现不佳。用图表示就是曲线起伏过大，不平稳。也称方差较高。 解决办法：过拟合可以通过减少参数，加入正则惩罚项 L1(绝对值项) L2，变化学习率，尽可能扩大数据集选取范围等方式解决。还要注意训练模型如果出现测试精度超1000次以上都在持续下降，而训练集精度较高时，要及时停止训练 欠拟合:under-fitting，与上相反，指模型过于简单或训练样本做的不够，比如特征过省，导致的模型在验证集测试集数据中表现不好，没有代表性。用图表现就是一条无起伏的线。也称高偏差 解决办法：欠拟合可以通过交叉验证，让特征较少的情况多次迭代交替使用训练集和验证集，达到优化，或跟据相关性添加其它特征项，减少正则化参数。神经网络可以加结点加层数。 增加训练迭代，加数据，加节点，加层数（3层以内） 方差和偏差的概念扩展： 算法的预测误差可以分解为三个部分: 偏差(bias)， 方差(variance) 和噪声(noise). 偏差：指偏离真实label导致的误差，反映了学习算法本身的拟合能力 方差：随机变量在其期望值附近的波动程度，即预测值在真实值附近的波动，如同样大小的训练集的变动所导致的学习性能的变化。它反映了数据扰动所造成的影响。 噪声：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界， 即 刻画了学习问题本身的难度 . 巧妇难为无米之炊， 给一堆很差的食材， 要想做出一顿美味， 肯定是很有难度的. 交叉验证：把特征分成几部分：一些作为训练集一些做验证集，下一次交换角色，用验证集数据做训练集，训练集做验证集，交替多次充份训练验证数据。 线性回归的原理建立模型，通过输入特征项加误差项，找到最合适的最好拟合结果y值的数据点。（误差项是独立并有相同分布，服从均值为0方法为θ^2的高斯分布正态分布，即符合中心极限定理。） 线性回归损失函数、代价函数、目标函数的概念 损失函数：模型的样本误差，用于度量预测值与真实值的拟合程度，损失函数越小说明模型越好。它是定义在单个样本上的。 代价函数：定义在整个训练集上的，整个样本误差的平均，即，损失函数的平均值。 目标函数：表示误差的损失函数，代价函数，加入了正则惩罚项后得到的最终优化函数。 一元线性回归的参数求解公式推导y = wx+b 多元线性回归的参数求解公式推导线性回归的评估指标有哪些？原理是什么？ SSE(误差平方和)：误差平方和，即(真实值-预测值)的平方和同样的数据集的情况下，SSE越小，误差越小，模型效果越好缺点：随着样本增加，SSE必然增加，也就是说，不同的数据集的情况下，SSE比较没有意义 R-square(决定系数)：1- 误差平方和/原始真实数据与平均值差方和。综合考虑了预测数据和原始数据的误差以及原始数据的离散程度。消除了原始数据离散程度的影响。R^2 越接近1，表示方程变量对y的解释能力越强，模型对数据拟合越好。R^2 越接近0，表明模型拟合越差。缺点：数据集的样本越大，R^2越大，所以，不同数据集的模型结果比较会有一定的误差 Adjusted R-square：校正决定系数。加入样本数据和特征数据评价指标，消除了样本数据和特征数量的影响。 sklearn参数详解（sklearn包里面线性回归的每个参数的作用）sklearn 线性回归LinearRegression()参数： 参数 意义 fit_intercept 是否有截据，如果没有则直线过原点 normalize 是否将数据归一化 copy_X 默认为True，当为True时，X会被copied，否则X将会被覆写 n_jobs 默认值为1，计算时使用的核数]]></content>
      <categories>
        <category>算法梳理进阶线性回归</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务一-线性回归算法梳理]]></title>
    <url>%2F2019%2F03%2F01%2Fbasic-task1%2F</url>
    <content type="text"><![CDATA[机器学习的一些概念有监督、无监督、泛化能力、过拟合欠拟合(方差和偏差以及各自解决办法)、交叉验证 有监督学习：数据集有有已知的y值（label 结果） 无监督学习：数据集中没有y值，需要根据近似性关系分成一簇一簇的聚类来当作y值来评估 泛化能力：指算法对具有同一规律的学习集以外的数据，的适用程度，对其它样本的适应能力 过拟合over-fitting，指模型在训练样本中表现过好，要求过于精细，导致泛化能力减弱，在验证数据集和测试集中表现不佳。用图表示就是曲线起伏过大，不平稳。也称高方差。 解决办法过拟合可以通过减少参数，加入正则惩罚项 L1(绝对值项) L2，变化学习率，尽可能扩大数据集选取范围等方式解决。 还要注意训练模型如果出现测试精度超1000次以上都在持续下降，而训练集精度较高时，要及时停止训练 欠拟合under-fitting，与上相反，指模型过于简单或训练样本做的不够，比如特征过省，导致的模型在验证集测试集数据中表现不好，没有代表性。用图表现就是一条无起伏的线。也称高偏差。 解决办法欠拟合可以通过交叉验证，让特征较少的情况多次迭代交替使用训练集和验证集，达到优化，或跟据相关性添加其它特征项，减少正则化参数。神经网络可以加结点加层数。 增加训练迭代，加数据，加节点，加层数（3层以内） 方差和偏差的概念扩展：算法的预测误差可以分解为三个部分: 偏差(bias)， 方差(variance) 和噪声(noise). 偏差：指偏离真实label导致的误差，反映了学习算法本身的拟合能力 方差：随机变量在其期望值附近的波动程度，即预测值在真实值附近的波动，如同样大小的训练集的变动所导致的学习性能的变化。它反映了数据扰动所造成的影响。 噪声：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界， 即 刻画了学习问题本身的难度 . 巧妇难为无米之炊， 给一堆很差的食材， 要想做出一顿美味， 肯定是很有难度的. 交叉验证：把特征分成几部分：一些作为训练集一些做验证集，下一次交换角色，用验证集数据做训练集，训练集做验证集，交替多次充份训练验证数据。 线性回归的原理建立模型，通过输入特征项加误差项，找到最合适的最好拟合结果y值的数据点。（误差项是独立并有相同分布，服从均值为0方法为θ^2的高斯分布正态分布，即符合中心极限定理。） 线性回归损失函数、代价函数、目标函数 损失函数：模型的样本误差，用于度量预测值与真实值的拟合程度，损失函数越小说明模型越好。它是定义在单个样本上的。 代价函数：定义在整个训练集上的，整个样本误差的平均，即，损失函数的平均值。 目标函数：表示误差的损失函数，代价函数，加入了正则惩罚项后得到的最终优化函数。 优化方法(梯度下降法、牛顿法、拟牛顿法等) 梯度下降法：通过一步一步迭代，边训练数据，边调整参数，计算偏导，使回归使终是保持梯度下降的，即最优，来得到最小化的损失函数和此时的模型参数值 牛顿法：在梯度下降原理基础上，优化的二阶收敛，下降过程中采用二次曲面，考虑了每走一步对当前最大角度产生的影响，梯度下降是一阶收敛，一个平面下静态的拟合局部，只考虑了本步静态的最大方向。所以牛顿法比梯度下降法下降要快。 拟牛顿法：在每一步迭代时只要求知道目标函数梯度，通过测量梯度变化构造一个目标函数的模型，使之产生超线性收敛性。不需要二阶层数信息。可以用来解决无约事，约事，和大规模的优化问题。它是解非线性方程组及最优化计算中最有效的方法之一。是一类使每步迭代计算量少而又保持超线性收敛的牛顿型迭代法。 线性回归的评估指标 SSE(误差平方和)：误差平方和，即(真实值-预测值)的平方和同样的数据集的情况下，SSE越小，误差越小，模型效果越好缺点：随着样本增加，SSE必然增加，也就是说，不同的数据集的情况下，SSE比较没有意义 R-square(决定系数)：1- 误差平方和/原始真实数据与平均值差方和。综合考虑了预测数据和原始数据的误差以及原始数据的离散程度。消除了原始数据离散程度的影响。R^2 越接近1，表示方程变量对y的解释能力越强，模型对数据拟合越好。R^2 越接近0，表明模型拟合越差。缺点：数据集的样本越大，R^2越大，所以，不同数据集的模型结果比较会有一定的误差 Adjusted R-square：校正决定系数。加入样本数据和特征数据评价指标，消除了样本数据和特征数量的影响。 sklearn 参数详解sklearn 线性回归LinearRegression()参数： 参数 意义 fit_intercept 是否有截据，如果没有则直线过原点 normalize 是否将数据归一化 copy_X 默认为True，当为True时，X会被copied，否则X将会被覆写 n_jobs 默认值为1，计算时使用的核数 Sklearn 逻辑回归LogisticRegression()参数: 参数 意义 penalty 正则惩罚项，值为L1 L2，默认L2 random_state 随机种子，设置为0则，保证每次随机生成的数据比例一致 C 正则强度，较小的值指定更强的正则化。默认为1]]></content>
      <categories>
        <category>初级算法梳理</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP预备任务]]></title>
    <url>%2F2019%2F03%2F01%2Fnlp-pre%2F</url>
    <content type="text"><![CDATA[tensorflow安装推荐Anaconda（针对自己操作系统和位数下载对应版本）；推荐用conda create创建对应的python环境（注：某些python版本可能不支持tensorflow）；通过pip install来安装tensorflow。 参考tensorflow安装教程 TensorFlow 安装教程 | TensorFlowNews tensrflow基础关注图、会话、tensor、变量、feed和fetch。 使用图(graphs)来表示计算任务、在被称之为会话(Session)的上下文(context)中执行图、使用tensor表示数据、通过变量(Variable)维护状态；使用feed和fetch为任意的操作赋值或者从其中获取数据。 参考TENSORFLOW从入门到精通之——TENSORFLOW基本操作 Tensorflow从入门到精通之——Tensorflow基本操作 | TensorFlowNews tensorflow简介 简介 - TensorFlow 官方文档中文版 - 极客学院Wiki tensorflow基本使用 基本使用 - TensorFlow 官方文档中文版 - 极客学院Wiki 莫凡tensorflow Tensorflow 教程系列 | 莫烦Python TensorFlow-Examples https://github.com/aymericdamien/TensorFlow-Examples(关注Hello World、Basic Operations、Linear Regression、Simple Neural Network) 史上最全的Tensorflow学习资源汇总 【干货】史上最全的Tensorflow学习资源汇总 - 知乎 NLP关注NLP基础技术、NLP核心技术、NLP+的介绍。 参考微软周明：自然语言处理的历史与未来 微软周明：自然语言处理的历史与未来_新华网]]></content>
      <categories>
        <category>NLP实践</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的 2019 年]]></title>
    <url>%2F2019%2F03%2F01%2F2019%2F</url>
    <content type="text"><![CDATA[网址：2019https://mixlabpro.github.io 服务器配置服务器：https://bandwagonhost.com系统：ubuntu 18.04 ssh 远程登录123456789iosgouiMac:~ iosdevlog$ ssh -p xxxx root@xxx.xxx.xxx.xxxroot@ Server's password:Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantageLast login: Thu Feb 28 22:24:41 2019 from 119.137.55.244 上传下载文件1234$ scp -P xxxx local username@xxx.xxx.xxx.xxx:/home/username/xxx$ scp -P xxxx username@xxx.xxx.xxx.xxx:/home/username/xxx local$ sftp -P xxxx username@xxxx.xxx.xxx.xxx&gt; get xxx.tar.gz 用户添加用户1234567891011121314151617root@ubuntu:~# adduser iosdevlogAdding user `iosdevlog' ...Adding new group `iosdevlog' (1000) ...Adding new user `iosdevlog' (1000) with group `iosdevlog' ...Creating home directory `/home/iosdevlog' ...Copying files from `/etc/skel' ...Enter new UNIX password:Retype new UNIX password:passwd: password updated successfullyChanging the user information for iosdevlogEnter the new value, or press ENTER for the default Full Name []: Room Number []: Work Phone []: Home Phone []: Other []:Is the information correct? [Y/n] 分配 sudo 权限1root@ubuntu:~# usermod -aG sudo iosdevlog 测试 sudo 权限123456789101112131415root@ubuntu:~# echo $USERrootroot@ubuntu:~# su - iosdevlogTo run a command as administrator (user "root"), use "sudo &lt;command&gt;".See "man sudo_root" for details.iosdevlog@ubuntu:~$ echo $USERiosdevlogiosdevlog@ubuntu:~$ sudo ls -la /roottotal 24drwx------ 4 root root 4096 Apr 30 2018 .drwxr-xr-x 22 root root 4096 Feb 28 22:39 ..-rw-r--r-- 1 root root 3106 Apr 9 2018 .bashrcdrwx------ 2 root root 4096 Apr 30 2018 .cachedrwxr-xr-x 3 root root 4096 Apr 30 2018 .local-rw-r--r-- 1 root root 148 Aug 17 2015 .profile 更新更新源123456789iosdevlog@ubuntu:~$ sudo apt update[sudo] password for iosdevlog:Hit:1 http://us.archive.ubuntu.com/ubuntu bionic InRelease...Fetched 4,040 kB in 2s (1,660 kB/s)Reading package lists... DoneBuilding dependency treeReading state information... Done103 packages can be upgraded. Run 'apt list --upgradable' to see them. 更新软件1234567891011$ sudo apt upgrade -yReading package lists... DoneBuilding dependency treeReading state information... DoneCalculating upgrade... DoneThe following NEW packages will be installed:...Found initrd image: /boot/initrd.img-4.15.0-20-genericdoneProcessing triggers for initramfs-tools (0.130ubuntu3.6) ...update-initramfs: Generating /boot/initrd.img-4.15.0-45-generic 软件命令行终端切换 GNU Screen1$ sudo apt install screen -y 创建一个名为 “download” 的窗口12345$ screen -S download$ screen -listThere is a screen on: 26633.download (03/01/2019 12:48:02 AM) (Attached)1 Socket in /run/screen/S-iosdevlog. 脱离当前窗口: C-a d12345[detached from 26633.download]$ screen -listThere is a screen on: 26633.download (03/01/2019 12:48:03 AM) (Detached)1 Socket in /run/screen/S-iosdevlog. 恢复 “download” 窗口12345$ screen -r download$ screen -listThere is a screen on: 26633.download (03/01/2019 12:48:02 AM) (Attached)1 Socket in /run/screen/S-iosdevlog. 版本控制 git1$ sudo apt install git -y 文本编辑 vim1234$ sudo apt install vim -y$ git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime$ sh ~/.vim_runtime/install_awesome_vimrc.shInstalled the Ultimate Vim configuration successfully! Enjoy :-) 翻越万里长城 shadowsocks12345678910111213141516171819202122232425$ mkdir .bin$ cd .bin$ git clone https://github.com/teddysun/shadowsocks_install$ cd shadowsocks_install/$ sudo bash shadowsocks-all.sh...2019-02-28 23:00:45 INFO loading libcrypto from libcrypto.so.1.1startedStarting Shadowsocks successCongratulations, Shadowsocks-Python server install completed!Your Server IP : xxx.xxx.xxx.xxxYour Server Port : xxxxYour Password : xxxxxxxxYour Encryption Method: rc4-md5Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients) ss://cmM0LW1kNTpwYXNzd29yZEA2Ny4yMTguMTMyLjUwOjEwMDAxYour QR Code has been saved as a PNG file path: /home/iosdevlog/.bin/shadowsocks_install/shadowsocks_python_qr.pngWelcome to visit: https://teddysun.com/486.htmlEnjoy it!$ sudo apt install w3m -y$ w3m https://www.google.com Node Version Manager nvm1$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash Node.js®12345678$ nvm install stableDownloading and installing node v11.10.1...Downloading https://nodejs.org/dist/v11.10.1/node-v11.10.1-linux-x64.tar.xz...############################################################################################################################################################################ 100.0%Computing checksum with sha256sumChecksums matched!Now using node v11.10.1 (npm v6.7.0)Creating default alias: default -&gt; stable (-&gt; v11.10.1) 搭建网站 hexo12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 主题 NexT12$ mkdir themes/next$ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d '"' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 管理插件 Hexo Admin12$ npm install --save hexo-admin$ hexo server -d 打开浏览器: http://localhost:4000/admin/ 发布到 GitHub Page参考：http://theme-next.iissnan.com 创建仓库：MixLabPro.github.io 1234567$ npm install -g hexo-cli$ hexo init MixLabPro$ cd MixLabPro/$ npm install$ mkdir themes/next$ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d '"' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1$ npm install hexo-deployer-git --save 搜索安装搜索插件： hexo-generator-searchdb1$ npm install hexo-generator-searchdb --save 配置博客安装完成，编辑博客配置文件：_config.yml 12345search: path: search.xml field: post format: html limit: 10000 配置主题Next 主题自带搜索设置，编辑主题配置文件：_config.yml 找到文件中 Local search 的相关配置，设为 true 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 数学公式12$ npm un hexo-renderer-marked --save$ npm i hexo-renderer-kramed --save 创建脚本一键发布deploy.sh12345678910111213141516171819$ cat deploy.sh#!/bin/shhexo cleanhexo g # hexo generatehexo d # hexo deploy$ chmod +x deploy.sh$ ./deploy.sh...Counting objects: 153, done.Delta compression using up to 4 threads.Compressing objects: 100% (136/136), done.Writing objects: 100% (153/153), 1.21 MiB | 541.00 KiB/s, done.Total 153 (delta 21), reused 0 (delta 0)remote: Resolving deltas: 100% (21/21), completed with 1 local object.To https://github.com/MixLabPro/MixLabPro.github.io f5de7d7..c94e3e9 HEAD -&gt; masterBranch 'master' set up to track remote branch 'master' from 'https://github.com/MixLabPro/MixLabPro.github.io'.INFO Deploy done: git]]></content>
      <categories>
        <category>时间</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2019%2F03%2F01%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 2. 谁创造了它？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀，有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 天才都有早逝的归途。 3. 为什么要使用它？ 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. 怎么使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。 Markdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 4.1 标题两种形式：1）使用=和-标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题二级标题 2）使用#，可表示1-6级标题。 # 一级标题# 二级标题## 三级标题### 四级标题#### 五级标题##### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 4.3 区块引用在段落的每行或者只在第一行使用符号&gt;，还可使用多个嵌套引用，如： > 区块引用>&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){ printf(“Hello, Markdown.”);} 代码区块： void main() { printf(&quot;Hello, Markdown.&quot;); } 注意:需要和普通段落之间存在空行。 4.5 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，斜体粗体，粗体 4.6 列表使用·、+、或-标记无序列表，如： -（+*） 第一项-（+*） 第二项- （+*）第三项 注意：标记后面最少有一个空格或制表符。若不在引用区块中，必须和前方段落之间存在空行。 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字，并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 4.8 链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。 效果： younghz的Markdown库。 参考式： [younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown” 效果： younghz的Markdown库1younghz的Markdown库2 注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。 4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 4.10 反斜杠\相当于反转义作用。使符号成为普通符号。 4.11 符号’`’起到标记作用。如： `ctrl+a` 效果： ctrl+a 5. 谁在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 6. 尝试一下 Chrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。 在线的dillinger.io评价也不错 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。 Linux下的ReText不错。 当然，最终境界永远都是笔下是语法，心中格式化 :)。 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。 以上基本是所有traditonal markdown的语法。 其它：列表的使用(非traditonal markdown)： 用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。 代码库 链接 MarkDown https://github.com/younghz/Markdown 2019 https://github.com/MixLabPro/2019 数学公式\begin{equation} e=mc^2 \end{equation}\label{eq1}\begin{equation} \begin{aligned} a &= b + c \\ &= d + e + f + g \\ &= h + i \end{aligned} \end{equation}\label{eq2}\begin{align} a &= b + c \label{eq3} \\ x &= yz \label{eq4}\\ l &= m - n \label{eq5} \end{align}关于其它扩展语法可参见具体工具的使用说明。 参考https://github.com/younghz/Markdown]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>tortuial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI For Everyone 适合每个人的人工智能]]></title>
    <url>%2F2019%2F03%2F01%2Fai-for-every-one%2F</url>
    <content type="text"><![CDATA[AI不仅适用于工程师。如果您希望您的组织更好地使用AI，那么这就是告诉每个人 - 尤其是您的非技术同事 - 的过程。 在本课程中，您将学习： 常见AI术语背后的含义，包括神经网络，机器学习，深度学习和数据科学 人工智能实际上可以 - 和不能 - 做什么 如何发现将AI应用于您自己组织中的问题的机会 构建机器学习和数据科学项目的感觉如何 如何与AI团队合作并在贵公司制定AI策略 如何引导围绕AI的道德和社会讨论 虽然本课程主要是非技术性的，但工程师也可以通过本课程学习人工智能的业务方面。 您将获得的技能 机器学习项目的工作流程 AI术语 AI策略 数据科学项目的工作流程 教学大纲 - 您将从这门课程中学到什么第 1 周 什么是人工智能？完成时间为 2 小时 9 个视频 （总计 69 分钟）, 1 个测验 9 个视频 第 1 周 简介7分钟 机器学习6分钟 什么是数据？11分钟 人工智能术语9分钟 是什么让一家公司擅长人工智能？7分钟 机器学习能做什么，不能做什么7分钟 机器学习能做什么和不能做什么的更多例子8分钟 深度学习的非技术性解释（第1部分，可选）7分钟 深度学习的非技术性解释（第2部分，可选）3分钟 1 个练习 第 1 周 测验30分钟 第 2 周 建立AI项目完成时间为 1 小时 8 个视频 （总计 52 分钟）, 1 个测验 8 个视频 第 2 周 简介1分钟 机器学习项目的工作流程6分钟 数据科学项目的工作流程6分钟 每个工作职能都需要学习如何使用数据6分钟 如何选择AI项目（第1部分）7分钟 如何选择AI项目（第2部分）8分钟 与AI团队合作8分钟 AI团队的技术工具（可选）6分钟 1 个练习 第 2 周 测验30分钟 第 3 周 在您的公司中建立AI完成时间为 2 小时 10 个视频 （总计 90 分钟）, 1 个测验 10 个视频 第 3 周 简介2分钟 案例研究：智能扬声器9分钟 案例研究：自动驾驶汽车6分钟 AI团队的示例角色8分钟 AI转型手册（第1部分）10分钟 AI转型手册（第2部分）14分钟 要避免的AI陷阱2分钟 迈出AI的第一步4分钟 AI主要应用领域调查（可选）17分钟 AI主要技术调查（可选）15分钟 1 个练习 第 3 周 测验30分钟 第 4 周 人工智能和社会完成时间为 1 小时 8 个视频 （总计 50 分钟）, 1 个测验 8 个视频 第 4 周 简介2分钟 AI的现实观点7分钟 歧视/偏见9分钟 对人工智能的对抗性攻击7分钟 人工智能的不利用途4分钟 AI和发展中经济体7分钟 人工智能和工作7分钟 结论3分钟 1 个练习 第 4 周 测验30分钟]]></content>
      <categories>
        <category>AI For Everyone</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>DL</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Quick StartWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
